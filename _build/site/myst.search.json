{"version":"1","records":[{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL"},"type":"lvl1","url":"/hello-triangle","position":0},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL"},"content":"For our first WebGL example we are going to display a simple triangle to the screen, this “hello triangle” is the computer graphics version of the classic “hello world!” example.","type":"content","url":"/hello-triangle","position":1},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl2":"Setup HTML and JavaScript Files"},"type":"lvl2","url":"/hello-triangle#setup-html-and-javascript-files","position":2},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl2":"Setup HTML and JavaScript Files"},"content":"To start with we need two files, an HTML file that includes a <canvas> element which acts as a rendering surface for WebGL, and JavaScript file that controls everything that happens inside the canvas using the WebGL API.\n\nThese notes use a code-along principle in that as you work through these notes you will be tasked to create files, enter text and run code (the first of these tasks is below). Through working this way you will build an understanding of the concepts and techniques used in computer graphics. Where you are asked to enter code into your files, try to avoid the temptation of simply copying and pasting code, instead type out the code. Whilst this does have the risk of making typos and creating bugs, it does have an effect of helping you understand what each line of code is doing.\n\nTask\n\nCreate a folder called 01 Hello Triangle inside which create a HTML file called index.html and enter the following code.<!doctype html>\n\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n    <title>01 Hello Triangle</title>\n\n    <style>\n      html, head, body {\n        margin: 0;\n        padding: 25px;\n        background-color: #000;\n      }\n\n      #demo-canvas {\n        width: 800px;\n        height: 600px;\n        background-color: #8AcE00; // \n        image-rendering: crisp-edges;\n      }\n    </style>\n  </head>\n  <body>\n    <canvas id=\"demo-canvas\" width=\"800px\" height=\"600px\">\n      HTML5 canvas not supported in your browser! These demos will not work.\n    </canvas>\n  </body>\n</html>\n\nIf you open your index.html file in a web browser you will see that we have created a <canvas> element that is 800 pixels wide by 600 pixels high that is a particularly lurid shade of green. The reason for this horrible colour is that we will be clearing the canvas in our WebGL app so if we see this green colour we know something has gone wrong.\n\n\n\nTask\n\nInside your 01 Hello Triangle folder, create a JavaScript file hello_triangle.js that contains the following.// Main function\nfunction main() {\n\n  // Setup WebGL\n  const canvas = document.getElementById('demo-canvas');\n  if (!canvas) {\n    showError('Could not find HTML canvas element - check for typos, or loading JavaScript file too early');\n    return;\n  }\n  const gl = canvas.getContext('webgl2');\n  if (!gl) {\n    const isWebGL1Supported = !!(document.createElement('canvas')).getContext(`webgl`);\n    if (isWebGL1Supported) {\n      showError('WebGL 1 is supported, but not v2 - try using a different device or browser');\n    } else {\n      showError('WebGL is not supported on this device - try using a different device or browser');\n    }\n    return;\n  }\n\n  // Clear the canvas\n  canvas.width = canvas.clientWidth;\n  canvas.height = canvas.clientHeight;\n  gl.viewport(0, 0, canvas.width, canvas.height);\n  gl.clearColor(0.1, 0.1, 0.1, 1.0); // dark gray background\n  gl.clear(gl.COLOR_BUFFER_BIT);\n}\n\ntry {\n  main();\n} catch (e) {\n  console.error(`Uncaught JavaScript exception: ${e}`);\n}\n\nHere we have created our main function main() inside which we have set up the WebGL canvas. Some functions used here are defined below\n\ngl.viewport(0, 0, canvas.width, canvas.height);\n\nDefines the rectangular area of the canvas where rendering will take place that maps to the normalised device co-ordinates (-1 to 1 in the x, y and z axes). Here our viewport fills the <canvas> element.\n\ngl.clearColor(0.1, 0.1, 0.1, 1.0);\n\nDefines the background colour. Colours are defined using RGBA values (Red, Green, Blue and Alpha) so here our background is dark grey.\n\ngl.clear(gl.COLOR_BUFFER_BIT);\n\nClears the specified buffer, in this case it’s the colour buffer.\n\nRefresh the browser window by pressing CTRL + R or ⌘ + R if you are using a Mac, and you should still see that the horrible lurid green background. But hang on, haven’t we defined our background colour to be dark grey? The reason for this is that we haven’t embedded the JavaScript file into our HTML file.\n\nTask\n\nEdit the <body> tag near the bottom of the index.html file so that it looks like the following....\n<body>\n  <canvas id=\"demo-canvas\" width=\"800px\" height=\"600px\">\n    HTML5 canvas not supported in your browser! These demos will not work.\n  </canvas>\n\n  <script src=\"hello_triangle.js\"></script>\n</body>\n...\n\nNow if you refresh your browser you should see a dark grey background. If something has gone wrong, and you still see the green background, open up the JavaScript console using CTRL + SHIFT + J or ⌥ + ⌘ + J on a Mac, and it should give you an indication of what has gone wrong. The life of a graphics programmer is mostly problem-solving and debugging, so get used to doing this.\n\n","type":"content","url":"/hello-triangle#setup-html-and-javascript-files","position":3},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl2":"Define the Triangle Co-ordinates"},"type":"lvl2","url":"/hello-triangle#define-the-triangle-co-ordinates","position":4},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl2":"Define the Triangle Co-ordinates"},"content":"We are going to display a simple red triangle on our canvas similar to the one below.\n\n\n\nTask\n\nEnter the following just before we clear the canvas.// Define triangle vertices\nconst triangleVertices = new Float32Array([\n  // x     y    z\n   -0.5, -0.5, 0.0, // vertex 0       2\n    0.5, -0.5, 0.0, // vertex 1     /   \\\n    0.0,  0.5, 0.0, // vertex 2    0 --- 1\n]);\n\nHere we have defined an array called triangleVertices containing 9 values for the co-ordinates of the 3 triangle vertices. WebGL works best with 32-bit floats, and the default JavaScript float precision is 64-bit, so we use the new Float32Array() command to convert these into 32-bit float array.\n\nThe data in the triangleVertices array is stored in the CPU (RAM) and not in the GPU. To move data across to the GPU we create a WebGL buffer object and copy in the data.\n\nTask\n\nEnter the following after we have defined the triangle vertices array.// Create triangle buffer\nconst triangleVerticesBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, triangleVerticesBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, triangleVertices, gl.STATIC_DRAW);\ngl.bindBuffer(gl.ARRAY_BUFFER, null);\n\nThe commands used here are explained below\n\nconst triangleVerticesBuffer = gl.createBuffer();\n\nCreates a buffer object on the GPU. Here we have given it the name triangleVerticesBuffer.\n\ngl.bindBuffer(gl.ARRAY_BUFFER, triangleVerticesBuffer);\n\nBinds our triangleVerticesBuffer buffer object to an array buffer so that WebGL knows where to send the data. The word bind in graphics programming means to make it the currently active resource for a particular purpose so subsequent WebGL operations affect it.\n\ngl.bufferData(gl.ARRAY_BUFFER, triangleVertices, gl.STATIC_DRAW);\n\nCopies the data from the triangleVertices array into the array buffer that is currently bound. The gl.STATIC_DRAW input is a performance hint to WebGL, here we are saying that that triangle vertices will not change.\n\ngl.bindBuffer(gl.ARRAY_BUFFER, null);\n\nHere we unbind the current array buffer, so no subsequent commands will mistakenly affect it.","type":"content","url":"/hello-triangle#define-the-triangle-co-ordinates","position":5},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl2":"Create a Shader Program"},"type":"lvl2","url":"/hello-triangle#create-a-shader-program","position":6},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl2":"Create a Shader Program"},"content":"The next step is create a shader program that runs on the GPU and uses WebGL to determine which pixels on the display are to be rendered and in what colour. This shader program comprises two separate programs known as “shaders”: the vertex shader and the fragment shader. Shaders are written in GLSL (webGL Shader Language) which is similar to C.","type":"content","url":"/hello-triangle#create-a-shader-program","position":7},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl3":"Write and Compile the Vertex Shader","lvl2":"Create a Shader Program"},"type":"lvl3","url":"/hello-triangle#write-and-compile-the-vertex-shader","position":8},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl3":"Write and Compile the Vertex Shader","lvl2":"Create a Shader Program"},"content":"The vertex shader is called once for each vertex and transforms the vertex co-ordinates from model space (the local object co-ordinates) to the clip space that defines the region that is displayed on the canvas. We have defined our triangle using co-ordinates between [-1, 1], so they are already in clip space and our vertex shader just needs to output each vertex. The shader code for a simple vertex shader is#version 300 es\nprecision mediump float;\n\nin vec3 aPosition;\n\nvoid main() {\n  gl_Position = vec4(aPosition, 1.0);\n}\n\nThis code is explained below\n\n#version 300 es\n\nTells the shader we are using GLSL ES 3.00, the shader language used with WebGL 2.0.\n\nprecision mediump float;\n\nSets the default float precision to medium (16-bit).\n\nin vec3 aPosition;\n\nTells the shader that we are inputting a 3-element vector for the vertex position. The a in aPosition is short for attribute.\n\ngl_Position = vec4(aPosition, 1.0);\n\nOutputs a 4-element vector for the clip space co-ordinates of the vertex (there reason why it’s a 4-element vector will be covered later when we look at transformations). The gl_Position variable is a required output of every vertex shader.\n\nThe simplest way of entering shader code into our JavaScript file is to define it as a multiline string.\n\nTask\n\nAdd the following after we have created the triangle buffer. Note the use of backticks `...` to define the string using a literal so that we can use a multiline string.// Define vertex shader code\nconst vertexShaderSource = `#version 300 es\nprecision mediump float;\n\nin vec3 aPosition;\n\nvoid main() {\n  gl_Position = vec4(aPosition, 1.0);\n}`;\n\n// Compile vertex shader\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER);\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\nif (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n  console.log(`Error compiling vertex shader:\\n`, gl.getShaderInfoLog(vertexShader));\n  gl.deleteShader(vertexShader);\n}\n\nAs well as defining a string for the vertex shader code, we then create a vertex shader object, attach the shader code to it and compile it. There’s no easy way to check for errors in shader code, so it is good practice to do a check to see if it has compiled ok, if not a message is logged to the console.","type":"content","url":"/hello-triangle#write-and-compile-the-vertex-shader","position":9},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl3":"Write and Compile the Fragment Shader","lvl2":"Create a Shader Program"},"type":"lvl3","url":"/hello-triangle#write-and-compile-the-fragment-shader","position":10},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl3":"Write and Compile the Fragment Shader","lvl2":"Create a Shader Program"},"content":"The other shader we need to write is the fragment shader. This takes in information on a fragment that has been identified as being part of the primitive (i.e., triangle) and determines the colour that it will be rendered. We are going to render all fragments in the triangle as red, so the fragment shader code is as follows.#version 300 es\nprecision mediump float;\n\nout vec4 outColour;\n\nvoid main() {\n  outColour = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nThis is similar to the vertex shader with a couple of exceptions. The vertex shader has a required output of gl_Position, so this doesn’t need to be declared, fragment shaders can have a number of outputs, so we need to declare these. Here we have declared an output of a 4-element vector using out vec4 outColour;. Within the main() function, we set the output vector to (1, 0, 0, 1), i.e., all red with no blue or green components and the Alpha value is set to 1 so that it is opaque.\n\nTask\n\nAdd the following after we have compiled the vertex shader.// Define fragment shader code\nconst fragmentShaderSource = `#version 300 es\nprecision mediump float;\n\nout vec4 outColour;\n\nvoid main() {\n outColour = vec4(1.0, 0.0, 0.0, 1.0);\n}`;\n\n// Compile fragment shader\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\nif (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n  console.log(`Error compiling fragment shader:\\n`, gl.getShaderInfoLog(fragmentShader));\n  gl.deleteShader(fragmentShader);\n}\n\nThis code is very similar to the one used for the vertex shader. Later we will be using a helper function for DRY (Don’t Repeat Yourself).","type":"content","url":"/hello-triangle#write-and-compile-the-fragment-shader","position":11},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl3":"Link the Shaders into a WebGL Program","lvl2":"Create a Shader Program"},"type":"lvl3","url":"/hello-triangle#link-the-shaders-into-a-webgl-program","position":12},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl3":"Link the Shaders into a WebGL Program","lvl2":"Create a Shader Program"},"content":"The next step is to create a WebGL program and link the vertex and fragment shader to it. In doing this it manages the inputs and outputs, attributes and uniforms between our two shaders.\n\nTask\n\nAdd the following to the main() function// Create WebGL shader program and link the vertex and fragment shaders\nconst shaderProgram = gl.createProgram();\ngl.attachShader(shaderProgram, vertexShader);\ngl.attachShader(shaderProgram, fragmentShader);\ngl.linkProgram(shaderProgram);\nif (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n console.log(`Failed to link WebGL program : ${gl.getProgramInfoLog(shaderProgram)}`);\n return;\n}\n\nThe commands used here are similar to those used for the vertex and fragment shader. Instead of compiling the program we are simply linking the two shaders using the gl.linkProgram() function. We also do a check to see if the linking has been successful.","type":"content","url":"/hello-triangle#link-the-shaders-into-a-webgl-program","position":13},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl3":"Draw the Triangle","lvl2":"Create a Shader Program"},"type":"lvl3","url":"/hello-triangle#draw-the-triangle","position":14},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl3":"Draw the Triangle","lvl2":"Create a Shader Program"},"content":"So far we have done a fair bit of work creating a buffer object for the triangle vertices, written and compiled the vertex and fragment shader and linked these into a WebGL program. But we haven’t drawn anything yet! To do this we need to tell WebGL which shader program to use, tell it how to interpret the vertex data and then tell it to draw the triangle.\n\nTask\n\nEnter the following after we have cleared the canvas.// Set the shader program\ngl.useProgram(shaderProgram);\n\nThe gl.useProgram() function tells WebGL which shader program to use. It will use the currently selected program until told differently by another call to this function.\n\nEarlier we created the vertex buffer triangleVerticesBuffer in the GPU and copied across our vertex data. We now need to tell WebGL where this data is and how to read it, so it can work its magic with the shaders.\n\nTask\n\nEnter the following after the you have set the shader program.// Tell WebGL how to read data from the vertex buffer  \nconst positionLocation = gl.getAttribLocation(shaderProgram, \"aPosition\");\ngl.enableVertexAttribArray(0);\ngl.bindBuffer(gl.ARRAY_BUFFER, triangleVerticesBuffer);\ngl.vertexAttribPointer(\n  positionLocation, // index\n  3,                // size\n  gl.FLOAT,         // type\n  false,            // normalised\n  0,                // stride\n  0);               // offset\n\nThe functions used here are explained below;\n\nconst positionLocation = gl.getAttribLocation(shaderProgram, 'aPosition');\n\nGets the location of the aPosition attribute from the WebGL shader program.\n\ngl.enableVertexAttribArray(0);\n\nEnables a vertex attribute so that WebGL know to read data form a buffer and pass it to the vertex shader.\n\ngl.bindBuffer(gl.Array_BUFFER, triangleVerticesBuffer);\n\nMake the triangle buffer the currently active buffer.\n\ngl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);\n\nTells WebGL how to read the data from the currently bound buffer and pass it to the vertex shader. The inputs are explained in the table below.\n\nInput\n\nDescription\n\nindex\n\nAttribute location. We stored this in the positionLocation variable using the gl.getAttribLocation() function.\n\nsize\n\nNumber of components per vertex, We have 3D (x, y, z) co-ordinates, so this is 3.\n\ntype\n\nData type. We are using floats.\n\nnormalised\n\nWhether integer values should be mapped to [0, 1] or [-1, 1]. Our vertex co-ordinates are in NDC, so we don’t need to do this.\n\nstride\n\nNumber of bytes between first attribute of each vertex. Our data is tightly packed, so we can set the stride to 0, if the array buffer contained other data, e.g., colours, then we would need to determine the number of bytes between the first attribute, e.g., the x co-ordinates.\n\noffset\n\nNumber of bytes from the start of the buffer the attribute of the first vertex. Our first vertex co-ordinate is the first element in the buffer, so this is 0.\n\nThe last thing we need to do is actually tell WebGL to draw the triangle.\n\nTask\n\nEnter the following after the you have told WebGL how to read the data from the vertex buffer.// Draw the triangle\ngl.drawArrays(gl.TRIANGLES, 0, 3);\n\nThe gl.drawArrays() function tells the GPU to draw the primitives. The inputs are the type of primitive (we have a triangle), the index of the first vertex and the number of vertices to draw (we have one triangle, so we want to draw 3 vertices). Refresh your browser window, pray to the programming gods and if everything has gone to plan you should see the red triangle displayed on the canvas.\n\n","type":"content","url":"/hello-triangle#draw-the-triangle","position":15},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl2":"Shader Compiler Utility Functions"},"type":"lvl2","url":"/hello-triangle#shader-compiler-utility-functions","position":16},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl2":"Shader Compiler Utility Functions"},"content":"Looking at our main() function we see that the code to compile and link the shaders is very similar for the vertex and fragment shaders. In the spirit of DRY, we will now write some utility functions to simplify the code.\n\nTask\n\nCreate a new JavaScript files called utils.js within the 01 Hello Triangle/ folder and enter the following code.// Compile shader helper function\nfunction compileShader(gl, type, code) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, code);\n  gl.compileShader(shader);\n  \n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.log(`Error compiling ${shaderType === gl.VERTEX_SHADER ? 'vertex' : 'fragment'} shader:\\n`, gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return;\n  }\n\n  return shader;\n}\n\n// Link shaders into a shader program\nfunction createShaderProgram(gl, vertexShaderSource, fragmentShaderSource) {\n  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n  if (!vertexShader || !fragmentShader) {\n    return;\n  }\n\n  const shaderProgram = gl.createProgram();\n  gl.attachShader(shaderProgram, vertexShader);\n  gl.attachShader(shaderProgram, fragmentShader);\n  gl.linkProgram(shaderProgram);\n\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    console.log('Error linking shader program:\\n', gl.getProgramInfoLog(shaderProgram));\n    gl.deleteProgram(program);\n    return;\n  }\n\n  return shaderProgram;\n}\n\nThis new file utils.js is used to contain any utility (helper) functions. Here we have defined the functions compileShader() which compiles a vertex or fragment shader depending on the type input, and createShaderProgram() that calls compileShader() to create the vertex and fragment shaders and links them to create a WebGL program. If you compare them to the equivalent code in the main() function you can see that they are similar. To enable our main file to use these functions we also need to add utils.js to the index.html file using a script tag.\n\nTask\n\nAdd the following just before the hello_triangle.js script tag. <script src=\"utils.js\"></script>\n\nWe can now tidy up the main() function and make a call to out new createShaderProgram() function.\n\nTask\n\nCut and paste the vertexShaderSource and fragmentShaderSource to the top of the hello_triangle.js file. Delete the code in the main() function that compiles and links the shaders and replace it with the following.// Create WebGL program \nconst shaderProgram = createShaderProgram(gl, vertexShaderSource, fragmentShaderSource);\n\nRefresh your browser window and if everything has gone to plan you should see your red triangle as before. This effort is not wasted, we can now easily create WebGL programs from the source code without lots of copying and pasting of existing code. We will be using the utils.js and other JavaScript files to help organise and simplify our code in the future.","type":"content","url":"/hello-triangle#shader-compiler-utility-functions","position":17},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl2":"Exercises"},"type":"lvl2","url":"/hello-triangle#exercises","position":18},{"hierarchy":{"lvl1":"Drawing a Simple Shape in WebGL","lvl2":"Exercises"},"content":"Change the vertex shader so that the following results are achieved.\n\n  (a) The triangle is shifted by 0.75 to the right.\n\n\n\nHint\n\nWe can access individual elements of the aPosition vectors using aPosition.x, aPosition.y and aPosition.z -- this is known as \n\nswizzling.\n\n  (b) The triangle is drawn upside-down.\n\n\n\n  (c) The x and y co-ordinates are swapped.\n\n\n\nUse two triangles to draw a green rectangle with lower-left vertex at (-0.5, -0.5, 0) and the upper-right vertex at (0.5, 0.5, 0).\n\n\n\nUse multiple triangles to draw a circle.\n\n\n\nHint\n\nWe can draw and approximation of a circle using multiple triangles with one vertex at the (0, 0) and the other two vertices at points on the circle.\n\n\n\nThe (x, y) co-ordinates of a point on a circle centred at (0, 0) with radius r can be calculated using\\begin{align*}\n  x &= r \\cos(\\theta), &\n  y &= r \\sin(\\theta),\n\\end{align*}\n\nwhere \\theta is the angle between the x-axis and a line pointing from (0,0) to the point. Therefore, if we want a circle constructed using n triangles the co-ordinates of the 3 triangle vertices are\\begin{align*}\n&( 0, 0 ), &\n&( r\\cos(\\theta_1), r\\sin(\\theta_2)), &\n&( r\\cos(\\theta_2), r\\sin(\\theta_2)),\n\\end{align*}\n\nwhere \\theta_1 = \\dfrac{2i\\pi}{n} and \\theta_2 = \\dfrac{2(i+1)\\pi}{n} for the i-th triangle. You may also need to scale the y co-ordinates to preserve the aspect ratio of the circle. ---\n\n## Code\n\nIf you are having difficulty with a particular task, you can use the following files to help you.\n\n- [`index_base.html`](../_webgl/01%20Hello%20Triangle/index_base.txt), [`hello_triangle_base.js`](../_webgl/01%20Hello%20Triangle/01_hello_triangle_base.js) -- base versions of the HTML and JavaScript files that draw a blank canvas.\n- [`index.html`](../_webgl/01%20Hello%20Triangle/index_no_utils.txt), [`hello_triangle.js`](../_webgl/01%20Hello%20Triangle/hello_triangle_no_utils.js) -- HTML and JavaScript file to draw the hello triangle example.\n-  [`index.html`](../_webgl/01%20Hello%20Triangle/index.txt), [`hello_triangle.js`](../_webgl/01%20Hello%20Triangle/hello_triangle.js), [`utils.js`](../_webgl/01%20Hello%20Triangle/utils.js) -- HTML and JavaScript files to draw hello triangle example using utility functions.\n\n### Exercise solutions\n\n-  [`Q1a.js`](../_webgl/01%20Hello%20Triangle/Q1a.js)\n-  [`Q1b.js`](../_webgl/01%20Hello%20Triangle/Q1b.js)\n-  [`Q1c.js`](../_webgl/01%20Hello%20Triangle/Q1c.js)\n-  [`Q2.js`](../_webgl/01%20Hello%20Triangle/Q2.js)\n-  [`Q3.js`](../_webgl/01%20Hello%20Triangle/Q3.js) ","type":"content","url":"/hello-triangle#exercises","position":19},{"hierarchy":{"lvl1":"More Colours and Shapes"},"type":"lvl1","url":"/colours-and-shapes","position":0},{"hierarchy":{"lvl1":"More Colours and Shapes"},"content":"In the previous page we were able to draw triangles using WebGL of a single colour. Whilst this is awesome, wouldn’t it be better if we were able to draw triangles using different colours. In this page we will see how we can add colour data to each vertex, add more shapes to the scene and make use of VAOs (Vertex Array Objects) and EBOs (Element Buffer Objects).","type":"content","url":"/colours-and-shapes","position":1},{"hierarchy":{"lvl1":"More Colours and Shapes","lvl2":"Hello Colourful Triangle"},"type":"lvl2","url":"/colours-and-shapes#hello-colourful-triangle","position":2},{"hierarchy":{"lvl1":"More Colours and Shapes","lvl2":"Hello Colourful Triangle"},"content":"We are going to build upon the code we used to draw the boring red triangle example and jazz it up a bit by defined colour data for each vertex. Instead of starting from scratch, let’s copy the code from the previous page.\n\nTask\n\nCreate a folder called 02 Colours and more shapes and copy across the files index.html, hello_triangle.js, and utils.js into this new folder.\n\nChange the filename of hello_triangle.js to colours_and_more_shapes.js\n\nEdit index.html so that the page title is “02 Colours and More Shapes” and the script tag uses the new filename.\n\nOpen index.html in a web browser to check that the red triangle is displayed.\n\n\n\nRecall that the basic steps to draw the hello triangle were\n\nWrite and compile a vertex shader and fragment shader and link these in a WebGL program.\n\nCreate a vertex buffer on the GPU and copy across vertex co-ordinate data from the CPU.\n\nTell WebGL how to read the vertex buffer.\n\nTell WebGL to draw the triangle.\n\nTo add colour data to our triangle we need to modify the vertex and fragment shaders to work with an additional input of colour data, add a buffer containing the colours of the vertices and tell WebGL how to read this buffer.","type":"content","url":"/colours-and-shapes#hello-colourful-triangle","position":3},{"hierarchy":{"lvl1":"More Colours and Shapes","lvl3":"Vertex and Fragment Shaders","lvl2":"Hello Colourful Triangle"},"type":"lvl3","url":"/colours-and-shapes#vertex-and-fragment-shaders","position":4},{"hierarchy":{"lvl1":"More Colours and Shapes","lvl3":"Vertex and Fragment Shaders","lvl2":"Hello Colourful Triangle"},"content":"Our current vertex shader simply takes in an input of a 3-element vector containing the (x, y, z) vertex co-ordinates and outputs a 4-element vector of these co-ordinates to the fragment shader. The vertex co-ordinates are outputted using the gl_Position variable which is a required output and is not specifically declared. To add colour data to our co-ordinates we need to declare a second 3-element input vector for the attribute colour as well as an output vector for the vertex colour. So our vertex shader is#version 300 es\nprecision mediump float;\n\nin vec3 aPosition;\nin vec3 aColour;\n\nout vec3 vColour;\n\nvoid main() {\n  gl_Position = vec4(aPosition, 1.0);\n\n  // Output fragment colour\n  vColour = aColour;\n}\n\nAs for the fragment shader, we will simply output the colour data of the vertex. Our current fragment shader does not have an input declared because it expects gl_Position by default, so we need to add an input declaration for the vertex colour outputted by the vertex shader and use this to create the 4-element RGBA output vector.#version 300 es\nprecision mediump float;\n\nin vec3 vColour;\n\nout vec4 outColour;\n\nvoid main() {\n  outColour = vec4(vColour, 1.0);\n}\n\nTask\n\nEdit the vertex shader code at the top of the more_colours_and_shapes.js file so that is contains the modified vertex and fragment shaders shown above.","type":"content","url":"/colours-and-shapes#vertex-and-fragment-shaders","position":5},{"hierarchy":{"lvl1":"More Colours and Shapes","lvl3":"Vertex Colours","lvl2":"Hello Colourful Triangle"},"type":"lvl3","url":"/colours-and-shapes#vertex-colours","position":6},{"hierarchy":{"lvl1":"More Colours and Shapes","lvl3":"Vertex Colours","lvl2":"Hello Colourful Triangle"},"content":"To add colour data to the triangle vertices we add 3 more float values for the red, green and blue colours to the triangleVertices array.\n\nTask\n\nAmend the triangleVertices array so that it looks like the following.// Define triangle vertices\nconst triangleVertices = new Float32Array([\n  // x     y    z        r    g    b\n   -0.5, -0.5, 0.0,     1.0, 0.0, 0.0, // vertex 0       2\n    0.5, -0.5, 0.0,     0.0, 1.0, 0.0, // vertex 1     /   \\\n    0.0,  0.5, 0.0,     0.0, 0.0, 1.0, // vertex 2    0 --- 1\n]);\n\nHere we have specified vertex 0 is pure red, vertex 1 is pure green and vertex 2 is pure blue. If you refresh your web browser you should see that the red triangle is now black and it appears that the top vertex has been moved to the right-hand edge of the canvas. The reason why its skewed is that when we told WebGL how to read the vertex buffer using gl.vertexAttribPointer(colourLocation, 3, gl.FLOAT, false, 0, 0);. This means that WebGL is expected no gaps between the vertex co-ordinate data since the stride input (the second to last input) is 0, so it thinks the 3 vertex co-ordinates are (-0.5, -0.5, 0), (1, 0, 0) and (0.5, -0.5, 0).\n\nThis is where the stride input for the gl.vertexAttribPointer() function comes in. This is the number of bytes from the start of the attribute (in our case the vertex co-ordinates) for one vertex to the start of the same attribute of the next vertex. We added 3 floats for the RGB data, so our stride is the number of bytes used to store 6 float values, i.e., 3 for the (x, y, z) values and 3 for the RGB values.\n\n\n\nTask\n\nChange the gl.vertexAttribPointer(); function so that it looks like the following.gl.vertexAttribPointer(\n  positionLocation,                   // index\n  3,                                  // size\n  gl.FLOAT,                           // type\n  false,                              // normalised\n  6 * Float32Array.BYTES_PER_ELEMENT, // stride\n  0);                                 // offset\n\nRefresh your browser, and you should see that the triangle vertices has returned to its previous state, but it’s still black. The reason for this is that we have not yet told WebGL about our new vertex colours. To do this we get the location of the aColour attribute from the vertex shader, enable the attribute array and point WebGL to where it can find the colour data.\n\nTask\n\nEnter the following code after we told WebGL how to read the co-ordinate data.const colourLocation = gl.getAttribLocation(shaderProgram, 'aColour');\ngl.enableVertexAttribArray(colourLocation);\ngl.vertexAttribPointer(\n  colourLocation,                      // index\n  3,                                   // size\n  gl.FLOAT,                            // type\n  false,                               // normalised\n  6 * Float32Array.BYTES_PER_ELEMENT,  // stride\n  3 * Float32Array.BYTES_PER_ELEMENT); // offset\n\nNote that here the offset value is 3 lots of the number of bytes used to store a 32-bit float. This is because the colour data comes after the 3 floats for the co-ordinate values.\n\nRefresh your browser you should see the triangle in all its glorious colourfulness.\n\n\n\nYou can see that the 3 triangle vertices are red, green and blue going anti-clockwise from the bottom-left vertex. The colour of the pixels across the interior of the triangle have been interpolated by the rasteriser so that we have a smooth transition of colours.","type":"content","url":"/colours-and-shapes#vertex-colours","position":7},{"hierarchy":{"lvl1":"More Colours and Shapes","lvl2":"More Shapes"},"type":"lvl2","url":"/colours-and-shapes#more-shapes","position":8},{"hierarchy":{"lvl1":"More Colours and Shapes","lvl2":"More Shapes"},"content":"To keep our colourful triangle company we are going to introduce another shape, a square, to our scene. In most graphics applications shapes are constructed using triangle primitives. Triangles are the simplest 2D shape and all other shapes are constructed using triangles. So to construct a square we need two triangles.\n\nTask\n\nEnter the following code after we defined the triangle vertex buffer.// Define square vertices\nconst squareVertices = new Float32Array([\n  // x    y    z       r    g    b             \n    0.5, 0.2, 0.0,    1.0, 0.0, 0.0, // vertex 0     3 -- 2\n    0.8, 0.2, 0.0,    0.0, 1.0, 0.0, // vertex 1     |  / |    \n    0.8, 0.6, 0.0,    0.0, 0.0, 1.0, // vertex 2     | /  | \n    0.5, 0.2, 0.0,    1.0, 0.0, 0.0, // vertex 0     0 -- 1 \n    0.8, 0.6, 0.0,    0.0, 0.0, 1.0, // vertex 2\n    0.5, 0.6, 0.0,    1.0, 1.0, 1.0, // vertex 3\n]);\n\n// Create square vertex buffer\nconst squareBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, squareVertices, gl.STATIC_DRAW);\ngl.bindBuffer(gl.ARRAY_BUFFER, null);\n\nHere we have defined the co-ordinates and colours for vertices of a square. We are using 2 triangles to construct the square, so we have 6 vertices in total. Like with the triangle, we have also created a vertex buffer for the square and copied the data across to the GPU. We now need to tell WebGL how to read the square vertex buffer and to draw the 2 triangles that make up the square.\n\nTask\n\nEnter the following code after we have drawn the triangle.// Tell WebGL how to read data from the square vertex buffer\ngl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer);\ngl.enableVertexAttribArray(positionLocation);\ngl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);\ngl.enableVertexAttribArray(colourLocation);\ngl.vertexAttribPointer(colourLocation, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);\n\n// Draw the square\ngl.drawArrays(gl.TRIANGLES, 0, 6);\n\nThis is very similar to what we did for the triangle object, i.e., we bind the vertex buffer for the square, enable the vertex attribute array and tell WebGL where the data is. Note that we already know the location of the position and colour attributes. Since we are drawing two squares, we change the 3 to a 6 in the gl.drawArrays() function.\n\n","type":"content","url":"/colours-and-shapes#more-shapes","position":9},{"hierarchy":{"lvl1":"More Colours and Shapes","lvl2":"Vertex Array Objects (VAO)"},"type":"lvl2","url":"/colours-and-shapes#vertex-array-objects-vao","position":10},{"hierarchy":{"lvl1":"More Colours and Shapes","lvl2":"Vertex Array Objects (VAO)"},"content":"You may have noticed that telling WebGL how to read the vertex buffer for both the triangle and square objects required repetition of code. Every time we draw a different object we are repeating this code, with just 2 objects this isn’t too bad, but when we are dealing with hundreds of objects it will become unmanageable. A Vertex Array Object (VAO) is a WebGL object that stores all the state related to the vertex, i.e., vertex attributes and bindings to attribute locations, so that once it is set up we only need a single block of code to bind the VAO and draw the object.\n\nTask\n\nDelete (or comment out) the code used to tell WebGL how to interpret the vertex buffers for the triangle and square as well as the draw command.\n\nEnter the following code after we have created the shader program.// Get attribute locations\nconst positionLocation = gl.getAttribLocation(shaderProgram, \"aPosition\");\nconst colourLocation = gl.getAttribLocation(shaderProgram, \"aColour\");\n\n// Create VAO for the triangle\nconst triangleVAO = gl.createVertexArray();\ngl.bindVertexArray(triangleVAO);\ngl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer);\ngl.enableVertexAttribArray(positionLocation);\ngl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);\ngl.enableVertexAttribArray(colourLocation);\ngl.vertexAttribPointer(colourLocation, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);\ngl.bindVertexArray(null);\n\n// Create VAO for the triangle\nconst squareVAO = gl.createVertexArray();\ngl.bindVertexArray(squareVAO);\ngl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer);\ngl.enableVertexAttribArray(positionLocation);\ngl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 0);\ngl.enableVertexAttribArray(colourLocation);\ngl.vertexAttribPointer(colourLocation, 3, gl.FLOAT, false, 6 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);\ngl.bindVertexArray(null);\n\nEach VAO is created using the gl.createVertexArray() function. We then bind the vertex array, copy across the vertex data to the GPU and tell WebGL how to access this data. The last thing we do for each VAO is to unbind it using gl.bindVertexArray(null) so that we don’t accidentally make changes to it.\n\nNow whenever we want to draw the triangle or square we just need to bind it’s VAO and called the draw command.\n\nTask\n\nEnter the following code after we have created the VAOs.// Draw triangle\ngl.bindVertexArray(triangleVAO);\ngl.drawArrays(gl.TRIANGLES, 0, 3);\n\n// Draw square\ngl.bindVertexArray(squareVAO);\ngl.drawArrays(gl.TRIANGLES, 0, 6);\n\nRefresh your web browser, and you should see that we still have the colourful triangle and square, good news as it means the VAOs are working.","type":"content","url":"/colours-and-shapes#vertex-array-objects-vao","position":11},{"hierarchy":{"lvl1":"More Colours and Shapes","lvl2":"Element Buffer Objects"},"type":"lvl2","url":"/colours-and-shapes#element-buffer-objects","position":12},{"hierarchy":{"lvl1":"More Colours and Shapes","lvl2":"Element Buffer Objects"},"content":"To add the square to our scene we used 6 vertices, 3 for each of the triangle. Two of these vertices, 0 and 2, are shared by both triangles, so we are using more memory than required. To avoid redundant vertex data being created and using up memory, we can define an array of the indices for each triangle which maps to the vertex data. The buffer that we use to store the indices is called the Element Buffer Object (EBO).\n\nTask\n\nReplace the code used to define the square vertex co-ordinates so that it looks like the following.// Define square vertices\nconst squareVertices = new Float32Array([\n // x    y    z       r    g    b             \n   0.5, 0.2, 0.0,    1.0, 0.0, 0.0, // vertex 0     3 -- 2\n   0.8, 0.2, 0.0,    0.0, 1.0, 0.0, // vertex 1     |  / |    \n   0.8, 0.6, 0.0,    0.0, 0.0, 1.0, // vertex 2     | /  | \n   0.5, 0.6, 0.0,    1.0, 1.0, 1.0, // vertex 3     0 -- 1 \n]);\n\n// Define square indices\nconst squareIndices = new Uint16Array([\n0, 1, 2,  // lower-right triangle\n0, 2, 3,  // upper-left triangle\n]);\n\nHere we have defined the co-ordinates and colours for the 4 vertices of the square, as well as an additional array of integers for the indices. We have converted the indices array from 64-bit to 16-bit unsigned integers (non-negative) for use with WebGL using new Uint16Array(). Since we have another array we need to create a buffer for it and copy the data across to the GPU.\n\nTask\n\nEnter the following code after the vertex buffer is created for the square.// Create square index buffer\nconst squareIndexBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, squareIndices, gl.STATIC_DRAW);\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\nThese commands a similar those used for the vertex buffer. Note that here we need to specify that we have an element array buffer instead of a standard array buffer. The index buffer does not contain any data specific to the vertices, so we don’t need to add it to a VAO, instead we bind it whilst the VAO is bound and WebGL ‘remembers’ it as part of the VAO’s state.\n\nTask\n\nEnter the following before the square VAO is unbound.gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);\n\nFinally, we need to tell WebGL that our data for the square is defined using indices, so we need to change the draw command.\n\nTask\n\nReplace the gl.drawArrays() command for the square with the following.gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n\nRefresh your browser, and you should see that the output has not changed, but we can now draw different objects easily by binding its VAO and using the draw command.","type":"content","url":"/colours-and-shapes#element-buffer-objects","position":13},{"hierarchy":{"lvl1":"Vectors and Matrices"},"type":"lvl1","url":"/vectors-and-matrices","position":0},{"hierarchy":{"lvl1":"Vectors and Matrices"},"content":"Computer graphics relies heavily on mathematics of vectors and matrices. In this lab we will be revising the important concepts needed for computer graphics and using a library to perform calculations.","type":"content","url":"/vectors-and-matrices","position":1},{"hierarchy":{"lvl1":"Vectors and Matrices","lvl2":"Vectors"},"type":"lvl2","url":"/vectors-and-matrices#vectors","position":2},{"hierarchy":{"lvl1":"Vectors and Matrices","lvl2":"Vectors"},"content":"A vector in is an object with magnitude (length) and direction. A vector is denoted by a lower case letter in boldface, e.g., \\mathbf{a} (or underlined when writing by hand), and represented mathematically by a tuple which is an ordered set of numbers. In geometry, each number in the vector represents the length along the co-ordinate axes. For example, consider the 3-element vector\\mathbf{a} = (a_x, a_y, a_z). Here $\\mathbf{a}$ has 3 elements so is a vector in 3D space where $a_x$, $a_y$ and $a_z$ are the lengths of the vector in the $x$, $y$, and $z$ directions.\n\n```{figure} ../_images/04_Vector.svg\n:height: 200\n:name: vector-figure\n\nThe vector $\\mathbf{a} = (a_x, a_y, a_z)$.\n```\n\n```{note}\nThe reason the diagram in {numref}`vector-figure` has the $y$-axis pointing upwards and the $z$-axis pointing along the horizontal is because this is the way OpenGL represents 3D space (see [5. Transformations](transformations-section) for more details). The configuration of the axes does not matter for the calculations we will be performing in this lab, but I wanted to be consistent. \n```\n\nLets create the following 3D vector objects in C++.\n\n$$ \\begin{align*}\n    \\mathbf{a} &= (3, 0, 4), &\n    \\mathbf{b} &= (1, 2, 3).\n\\end{align*} $$\n\nAdd the following code to the `main()` function.\n\n```cpp\n// Vectors\nprintf(\"Vectors and Matrices\\n\");\nprintf(\"--------------------------------------------------\\n\");\n\n// Defining vectors\nglm::vec3 a, b;\na = glm::vec3(3.0f, 0.0f, 4.0f);\nb[0] = 1.0f, b[1] = 2.0f, b[2] = 3.0f;\n\nprintf(\"Defining vectors:\\n\");\nstd::cout <! \"a = \" <! a <! std::endl;\nstd::cout <! \"b = \" <! b <! std::endl;\n```\n\nHere we have declared two vectors `a` and `b` using the `glm::vec3` type (for vectors in 2D we would use `glm::vec2`). The elements of the vectors `a` and `b` have been defined using two different methods: `a` has been defined using the `glm::vec3(x, y, z)` constructor and `b` by accessing the individual elements using [array indexing](arrays-section). The vectors have been printed to the console using `std::cout` commands (glm vectors cannot be printed using the `printf()` function). Compile and run the **Lab04_Vectors_and_matrices** project, and you should see the following outputted to the console.\n\n```text\nVectors and Matrices\n--------------------------------------------------\nDefining vectors:\na = [    3.000,    0.000,    4.000]\nb = [    1.000,    2.000,    3.000]\n```\n\n(vector-magnitude-section)=\n\n### Vector magnitude\n\nThe **magnitude** of a vector $\\mathbf{a} = (a_x, a_y, a_z)$ is denoted by $\\|\\mathbf{a}\\|$ is the length from the tail of the vector to the head.\n\n```{figure} ../_images/04_Vector_magnitude.svg\n:height: 100\n\nThe magnitude of $\\mathbf{a}$ is the length of the vector.\n```\n\nThe magnitude is calculated using an extension of Pythagoras' theorem, for example for 3D vectors the magnitude is\n\n$$ \\|\\mathbf{a}\\| = \\sqrt{a_x^2 + a_y^2 + a_z^2}. $$(eq:vector-magnitude)\n\nFor example, for the vectors $\\mathbf{a}$ and $\\mathbf{b}$ given above the magnitudes are\n\n$$ \\begin{align*}\n    \\| \\mathbf{a} \\| &= \\sqrt{3^2 + 0^2 + 4^2} = \\sqrt{9 + 0 + 16} = \\sqrt{25} = 5, \\\\\n    \\| \\mathbf{b} \\| &= \\sqrt{1^2 + 2^2 + 3^2} = \\sqrt{1 + 4 + 9} = \\sqrt{14} = 3.742\\ldots\n\\end{align*}  $$\n\nThe `glm::length()` function calculates the magnitude of a glm vector object. To demonstrate this,  add the following code to your program.\n\n```cpp\n// Vector length\nprintf(\"\\nVector length:\\n\");\nprintf(\"length(a) = %0.3f\\n\", glm::length(a));\nprintf(\"length(b) = %0.3f\\n\", glm::length(b));\n```\n\nRunning the program you should see the following printed to the console.\n\n```text\nVector length:\nlength(a) = 5.000\nlength(b) = 3.742\n```\n\n(unit-vectors-section)=\n\n### Unit vectors\n\nA **unit vector** is a vector that has a length of 1. We can find a unit vector that points in the same direction as a non-zero vector $\\mathbf{a}$, which is denoted by $\\hat{\\mathbf{a}}$ (pronounced *a-hat*), by dividing by its magnitude, i.e.,\n\n$$ \\hat{\\mathbf{a}} = \\frac{\\mathbf{a}}{\\|\\mathbf{a}\\|}. $$(eq:unit-vector)\n\nThis process is called **normalising a vector**. For example, to determine a unit vector pointing in the same direction as $\\mathbf{a} = (3, 0, 4)$ we normalise it by dividing by its magnitude which we have already calculated is 5.\n\n$$ \\begin{align*}\n    \\hat{\\mathbf{a}} &= \\frac{(3, 0, 4)}{5} = \\left( \\frac{3}{5}, 0, \\frac{4}{5} \\right) = (0.6, 0, 0.8).\n\\end{align*} $$\n\nChecking that $\\hat{\\mathbf{a}}$ has a magnitude of 1\n\n$$ \\|\\hat{\\mathbf{a}}\\| = \\sqrt{0.6^2 + 0^2 + 0.8^2} = \\sqrt{0.36 + 0.64} = \\sqrt{1} = 1.$$\n\nNormalising a vector is an operation that is used a lot in graphics programming so the glm library has the function `glm::normalize()` to do this. Add the following code to your program.\n\n```cpp\n// Normalising vectors\nglm::vec3 aHat, bHat;\naHat = glm::normalize(a);\nbHat = b / glm::length(b);\n\nprintf(\"\\nNormalising vectors:\\n\");\nstd::cout <! \"aHat = \" <! aHat <! std::endl;\nstd::cout <! \"bHat = \" <! bHat <! std::endl;\nprintf(\"length(aHat) = %0.3f\\n\", glm::length(aHat));\nprintf(\"length(bHat) = %0.3f\\n\", glm::length(bHat));\n```\n\nHere we are calculating unit vectors from `a` and `b` using the `glm::normalize()` function and dividing by the vector magnitude. Running your program you should see the following printed to the console.\n\n```text\nNormalising vectors:\naHat = [    0.600,    0.000,    0.800]\nbHat = [    0.267,    0.535,    0.802]\nlength(aHat) = 1.000\nlength(bHat) = 1.000\n```\n\nBoth `aHat` and `bHat` have magnitudes of 1 which shows they are both unit vectors.\n\n## Arithmetic operations on vectors\n\nLike numbers, we can define the arithmetic operations of addition, subtraction for vectors as well as multiplication and division by a scalar.\n\n### Vector addition and subtraction\n\nThe addition and subtraction of two vectors $\\mathbf{a} = (a_x, a_y, a_z)$ and $\\mathbf{b} = (b_x, b_y, b_z)$ is defined by\n\n$$ \\begin{align*}\n    \\mathbf{a} + \\mathbf{b} &= (a_x + b_x, a_y + b_y, a_z + b_z), \\\\\n    \\mathbf{a} - \\mathbf{b} &= (a_x - b_x, a_y - b_y, a_z - b_z).\n\\end{align*} $$(eq:vector-addition)\n\nFor example, given the vectors $\\mathbf{a} = (3,0,4)$ and $\\mathbf{b} = (1, 2, 3)$\n\n$$ \\begin{align*}\n    \\mathbf{a} + \\mathbf{b} &= (3, 0, 4) + (1, 2, 3) = (3 + 1, 0 + 2, 4 + 3) = (4, 2, 7), \\\\\n    \\mathbf{a} - \\mathbf{b} &= (3, 0, 4) - (1, 2, 3) = (3 - 1, 0 - 2, 4 - 3) = (2, -2, 1).\n\\end{align*} $$\n\nWhat is happening in a geometrical sense when we add and subtract vectors? Take a look at {numref}`vector-addition-figure`, here the vector $\\mathbf{b}$ has been added to the vector $\\mathbf{a}$ where the tail of $\\mathbf{b}$ is placed at the head of $\\mathbf{a}$. The resulting vector $\\mathbf{a} + \\mathbf{b}$ points from the tail of $\\mathbf{a}$ to the head of $\\mathbf{b}$.\n\n```{figure} ../_images/04_Vector_addition.svg\n:height: 150\n:name: vector-addition-figure\n\nVector addition.\n```\n\nThe subtraction of the vector $\\mathbf{b}$ does similar, but since $\\mathbf{a} - \\mathbf{b} = \\mathbf{a} + (-1)\\mathbf{b}$ then the direction of $\\mathbf{b}$ is reversed so $\\mathbf{a} - \\mathbf{b}$ is the same as placing the tail of $-\\mathbf{b}$ at the head of $\\mathbf{a}$.\n\n```{figure} ../_images/04_Vector_subtraction.svg\n:height: 180\n:name: vector-subtraction-figure\n\nVector subtraction.\n```\n\nTo calculate the addition and subtraction of our vectors add the following code to your program.\n\n```cpp\n// Arithmetic operations on vectors\nprintf(\"\\nArithmetic operations on vectors:\\n\");\nstd::cout <! \"a + b = \" <! a + b <! std::endl;\nstd::cout <! \"a - b = \" <! a - b <! std::endl;\n```\n\nRunning the program adds the following output to the console.\n\n```text\nArithmetic operations on vectors:\na + b = [    4.000,    2.000,    7.000]\na - b = [    2.000,   -2.000,    1.000]\n```\n\n### Multiplication and division by a scalar\n\nMultiplication and division of a vector $\\mathbf{a} = (a_x, a_y, a_z)$ by a scalar (a number) $k$ are defined by\n\n$$ \\begin{align*}\n    k \\mathbf{a} &= (ka_x, ka_y, ka_z), \\\\\n    \\frac{\\mathbf{a}}{k} &= \\left(\\frac{a_x}{k}, \\frac{a_y}{k}, \\frac{a_z}{k} \\right).\n\\end{align*} $$\n\nMultiplying or dividing a vector by a positive scalar has the effect of scaling the length of the vector. Multiplying or dividing by a negative scalar reverses the direction of the vector.\n\n```{figure} ../_images/04_vector_multiplication.svg\n:height: 180\n```\n\nFor example, multiplying the vector $\\mathbf{a} = (3, 0, 4)$ by the scalar 2 gives\n\n$$ 2\\mathbf{a} = 2(3,0,4) = (6, 0, 8), $$\n\nWhich has the magnitude\n\n$$ \\|2 \\mathbf{a} \\| = \\sqrt{6^2 + 0^2 + 8^2} = \\sqrt{36 + 64} = \\sqrt{100} = 10 = 2 \\|\\mathbf{a}\\|. $$\n\nTo perform scalar multiplication or division on a glm vector we simply use the `*` and `/` operators. To demonstrate this add the following code to your program.\n\n```cpp\nstd::cout <! \"2a    = \" <! 2.0f * a <! std::endl;\nstd::cout <! \"b / 3 = \" <! b / 3.0f <! std::endl;\n```\n\nNote that we need to use float values for scalar multiplication and division, i.e., `2.0f` and `3.0f` instead of `2` and `3`. Running the program will add the following to the console.\n\n```text\n2a    = [    6.000,    0.000,    8.000]\nb / 3 = [    0.333,    0.667,    1.000]\n```\n\n(element-wise-multiplication-section)=\n\n### Element-wise multiplication\n\nMathematically speaking the multiplication of two vectors is not defined (instead we have the dot and cross products - see [below](dot-product-section)). However, in computing it is useful to be able to multiply the individual elements of vectors, known as **element-wise multiplication**, which is done using the `*` operator.\n\nAdd the following code to your program.\n\n```cpp\nstd::cout <! \"a * b = \" <! a * b <! std::endl;\n```\n\nRunning the program gives the following output.\n\n```text\na * b = [    3.000,    0.000,   12.000]\n```\n\nSo each element of `a * b` is the product of the corresponding elements in the vectors `a` and `b`.\n\n(dot-product-section)=\n\n### The dot product\n\nThe <a href=\"https://en.wikipedia.org/wiki/Dot_product\" target=\"_blank\">**dot product**</a> between two vectors $\\mathbf{a} = (a_x, a_y, a_z)$ and $\\mathbf{b} = (b_x, b_y, b_z)$ is denoted by $\\mathbf{a} \\cdot \\mathbf{b}$ and returns a scalar. The dot product is calculated using\n\n$$ \\mathbf{a} \\cdot \\mathbf{b} = a_xb_x + a_yb_y + a_zb_z. $$(eq:dot-product)\n\nThe dot product is related to the angle $\\theta$ between the two vectors ({numref}`angle-between-vectors-figure`) by\n\n$$ \\mathbf{a} \\cdot \\mathbf{b} = \\|\\mathbf{a}\\| \\|\\mathbf{b}\\| \\cos(\\theta). $$(eq:dot-product-geometric)\n\n```{figure} ../_images/04_Dot_product.svg\n:height: 125\n:name: angle-between-vectors-figure\n\nThe angle $\\theta$ between the vectors $\\mathbf{a}$ and $\\mathbf{b}$.\n```\n\nA useful result for computer graphics is that if $\\theta=90^\\circ$ then $\\cos(\\theta) = 0$ and equation {eq}`eq:dot-product-geometric` becomes\n\n$$ \\mathbf{a} \\cdot \\mathbf{b} = 0. $$\n\nIn order words, if the dot product of two vectors is zero then the two vectors are perpendicular. For example, given the vectors $\\mathbf{a} = (3, 0, 4)$ and $\\mathbf{b} = (1, 2, 3)$ the dot product between these are\n\n$$ \\begin{align*}\n    \\mathbf{a} \\cdot \\mathbf{b} &= (3, 0, 4) \\cdot (1, 2, 3)\n    = 3 + 0 + 12\n    = 15.\n\\end{align*} $$\n\nThe glm function `glm::dot()` calculates the dot product of two vectors. To demonstrate its use, add the following code to your program.\n\n```cpp\n// Dot and Cross products\nprintf(\"\\nDot and cross products:\\n\");\nprintf(\"a . b = %0.3f\\n\", glm::dot(a, b));\n```\n\nRunning the program results in the following output.\n\n```text\nDot and cross products:\na . b = 15.000\n```\n\n(cross-product-section)=\n\n### The cross product\n\nThe <a href=\"https://en.wikipedia.org/wiki/Cross_product\" target=\"_blank\">**cross product**</a> between two vectors $\\mathbf{a} = (a_x, a_y, a_z)$ and $\\mathbf{b} = (b_x, b_y, b_z)$ is denoted by $\\mathbf{a} \\times \\mathbf{b}$ and returns a vector. The cross product is calculated using\n\n$$ \\mathbf{a} \\times \\mathbf{b} = (a_yb_z - a_zb_y, a_zb_x - a_xb_z, a_xb_y - a_yb_x). $$(eq:cross-product)\n\nThe cross product between two vectors produces another vector that is perpendicular to both of the vectors ({numref}`cross-product-figure`). This is another incredibly useful result as it allows us to calculate a [**normal vector**](normal-vector-section) to a polygon which are used in calculating how light is reflected off surfaces (see [8. Lighting](lighting-section)).\n\n```{figure} ../_images/04_cross_product.svg\n:height: 200\n:name: cross-product-figure\n\nThe cross product between two vectors gives a vector that is perpendicular to both vectors.\n```\n\nFor example, given the vectors $\\mathbf{a} = (3,0,4)$ and $\\mathbf{b} = (1, 2, 3)$ the cross product $\\mathbf{a} \\times \\mathbf{b}$ is\n\n$$ \\begin{align*}\n    \\mathbf{a} \\times \\mathbf{b} &= (3, 0, 4) \\times (1, 2, 3) \\\\\n    &= (0 \\times 3 - 4 \\times 2, 4 \\times 1 - 3 \\times 3, 3 \\times 2 - 0 \\times 3) \\\\\n    &= (-8, -5, 6).\n\\end{align*} $$\n\nWe can show that $\\mathbf{a} \\times \\mathbf{b}$ is perpendicular to both $\\mathbf{a}$ and $\\mathbf{b}$ using the dot product\n\n$$ \\begin{align*}\n    \\mathbf{a} \\cdot (\\mathbf{a} \\times \\mathbf{b}) &= (3, 0, 4) \\cdot (-8, -5, 6) = -24 + 0 + 24 = 0, \\\\\n    \\mathbf{b} \\cdot (\\mathbf{a} \\times \\mathbf{b}) &= (1, 2, 3) \\cdot (-8, -5, 6) = - 8 - 10 + 18 = 0.\n\\end{align*} $$\n\nThe glm function `glm::cross()` calculates the cross product of two vectors. To demonstrate its use, add the following code to your program.\n\n```cpp\nstd::cout <! \"a x b = \" <! glm::cross(a, b) <! std::endl;\nprintf(\"a . (a x b) = %0.3f\\n\", glm::dot(a, glm::cross(a, b)));\nprintf(\"b . (a x b) = %0.3f\\n\", glm::dot(b, glm::cross(a, b)));\n```\n\nRunning the program results in the following output.\n\n```text\na x b = [   -8.000,   -5.000,    6.000]\na . (a x b) = 0.000\nb . (a x b) = 0.000\n```\n\nHere we have also shown that the cross product of `a` and `b` is perpendicular to both vectors.\n\n---\n\n## Matrices\n\nAnother type of mathematic object that is fundamental to computer graphics is the matrix. A matrix is a rectangular array of numbers.\n\n$$ \\begin{align*}\n    A =\n    \\begin{pmatrix}\n        a_{11} & a_{12} & \\cdots & a_{1n} \\\\\n        a_{21} & a_{22} & \\cdots & a_{2n} \\\\\n        \\vdots & \\vdots & \\ddots & \\vdots \\\\\n        a_{m1} & a_{m2} & \\cdots & a_{mn}\n    \\end{pmatrix}\n\\end{align*} $$\n\nIt is common to use uppercase characters for the name of a matrix and lowercase characters for the individual elements. The elements of a matrix are referenced by an **index** which is a pair of numbers, the first of which is the horizontal row number and the second is the vertical column number so $a_{ij}$ is the element in row $i$ and column $j$ of the matrix $A$.  \n\nWe refer to the size of a matrix by the number of rows by the number of columns. Here the matrix $A$ has $m$ rows and $n$ columns, so we call this matrix a $m \\times n$ matrix.\n\nTo declare a $2 \\times 2$ glm matrix object we use the `glm::mat2()` function (a $4 \\times 4$ matrix object is declared using `glm::mat4()`)\nLets create some glm matrix objects for the following matrices\n\n$$ \\begin{align*}\n    A &= \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}, &\n    B &= \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix}.\n\\end{align*} $$\n\nEnter the following code into your program.\n\n```cpp\n// Defining matrices\nglm::mat2 A, B;\n\nA[0][0] = 1.0f, A[0][1] = 2.0f;\nA[1][0] = 3.0f, A[1][1] = 4.0f;\n\nB = glm::mat2(5.0f, 6.0f, 7.0f, 8.0f);\n\nprintf(\"\\nDefining matrices:\\n\");\nstd::cout <! \"A = \" <! A <! \"\\n\" <! std::endl;\nstd::cout <! \"B = \" <! B <! std::endl;\n```\n\nHere we have declared two $2 \\times 2$ matrices `A` and `B`. The elements of `A` are defined using matrix indexing and the elements of `B` are defined using the `glm::mat2()` function. Note how the elements of the 2D matrix are indexed using `[row][col]`\n\nRun your program and the following should be printed to the console.\n\n```text\nDefining matrices:\nA =\n[[    1.000,    3.000]\n [    2.000,    4.000]]\n\nB =\n[[    5.000,    7.000]\n [    6.000,    8.000]]\n```\n\nHang on something isn’t right here. Looking at the matrix `A` that was outputted we have 1 and 3 on the top row when we were expecting 1 and 2 (and similar for `B`), so what has gone wrong? To explain we need to look at how arrays are stored in the memory.\n\n(column-major-order-section)=\n\n### Column-major order\n\nLinear memory is a contiguous block of addresses that can be sequentially accessed. So a 1D array is stored in adjacent memory locations. Since matrices are 2D we have a choice whether to store the elements in the rows or columns in adjacent locations. These are known as **column-major order** and **row-major order**. Consider the $4 \\times 4$ matrix\n\n$$ \\begin{align*}\n    \\begin{pmatrix}\n        a & b & c & d \\\\\n        e & f & g & h \\\\\n        i & j & k & l \\\\\n        m & n & o & p\n    \\end{pmatrix}.\n\\end{align*} $$\n\nUsing column-major order this will be stored in the memory as\n\n```{figure} ../_images/04_Column_major.svg\n:width: 600\n```\n\ni.e., we move down and across the matrix. Alternatively, using row-major order the matrix will be stored as\n\n```{figure} ../_images/04_Row_major.svg\n:width: 600\n```\n\ni.e., we move across and down the matrix. The choice of whether to use column-major or row-major order is arbitrary but OpenGL uses column-major order so glm does as well (incidentally Microsoft's graphics library directX uses row-major order which means when porting code between the graphics libraries developers have to change all of their matrix calculations).\n\nSo since OpenGL uses column-major order them so does glm. This is way our matrices `A` and `B` were outputted column-by-column. If we want to view the matrix how it should be we need to calculate its transpose.\n\n(transpose-section)=\n\n### Matrix transpose\n\nThe **transpose** of a matrix $A$ is denoted by $A^\\mathsf{T}$ and is defined by swapping the rows and columns of $A$. For example, the matrix $A$ defined above\n\n$$ \\begin{align*}\n    A = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix},\n\\end{align*} $$\n\nthen $A^\\mathsf{T}$ is\n\n$$ \\begin{align*}\n    A^\\mathsf{T} = \\begin{pmatrix} 1 & 3 \\\\ 2 & 4 \\end{pmatrix}.\n\\end{align*} $$\n\nEdit the code in your program so that the transpose of `A` and `B` are outputted to the console instead.\n\n```cpp\nstd::cout <! \"A = \" <! glm::transpose(A) <! \"\\n\" <! std::endl;\nstd::cout <! \"B = \" <! glm::transpose(B) <! std::endl;\n```\n\nRunning the program should change the output to\n\n```text\nDefining matrices:\nA =\n[[    1.000,    2.000]\n [    3.000,    4.000]]\n\nB =\n[[    5.000,    6.000]\n [    7.000,    8.000]]\n```\n\nThat's better.\n\n## Arithmetic operations on matrices\n\nThe arithmetic operations on matrices for addition and subtraction of two matrices and multiplying and dividing by a scalar are the same as for vectors using the `+`, `-`, `*` and `/` operators. To show these add the following code to your program.\n\n```cpp\n// Arithmetic operations on matrices\nprintf(\"\\nArithmetic operations on matrices:\\n\");\nstd::cout <! \"A + B = \" <! glm::transpose(A + B) <! \"\\n\" <! std::endl;\nstd::cout <! \"A - B = \" <! glm::transpose(A - B) <! \"\\n\" <! std::endl;\nstd::cout <! \"2A    = \" <! glm::transpose(2.0f * A) <! \"\\n\" <! std::endl;\nstd::cout <! \"A / 3 = \" <! glm::transpose(A / 3.0f) <! \"\\n\" <! std::endl;\n```\n\nRunning the program should output the following to the console.\n\n```text\nArithmetic operations on matrices:\nA + B =\n[[    6.000,    8.000]\n [   10.000,   12.000]]\n\nA - B =\n[[   -4.000,   -4.000]\n [   -4.000,   -4.000]]\n\n2A    =\n[[    2.000,    4.000]\n [    6.000,    8.000]]\n\nA / 3 =\n[[    0.333,    0.667]\n [    1.000,    1.333]]\n```\n\n(matrix-multiplication-section)=\n\n### Matrix multiplication\n\nSo multiplication of a matrix by a scalar is the same for matrices as it is for vectors. However, the multiplication of two matrices $A$ and $B$ is defined in a very specific way. If $A$ and $B$ are two matrices then the element in row $i$ and column $j$ of the matrix $AB$ is calculated using\n\n$$ [AB]_{ij} = \\mathbf{a}_i \\cdot \\mathbf{b}_j, $$(eq:matrix-multiplication)\n\nWhere $\\mathbf{a}_i$ is the vector formed from row $i$ of $A$ and $\\mathbf{b}_j$ is the vector formed from column $j$ of $B$. For example, given the $2\\times 2$ matrices $A$ and $B$ defined earlier\n\n$$ \\begin{align*}\n    A &= \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}, &\n    B &= \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix},\n\\end{align*} $$\n\nthen the multiplication $AB$ is\n\n$$ \\begin{align*}\n    AB &=\n    \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}\n    \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} =\n    \\begin{pmatrix}\n        (1, 2) \\cdot (5, 7) & (1,2) \\cdot (6, 8) \\\\\n        (3, 4) \\cdot (5, 7) & (3, 4) \\cdot (6, 8)\n    \\end{pmatrix} \\\\\n    &=\n    \\begin{pmatrix} 5 + 14 & 6 + 16 \\\\ 15 + 28 & 18 + 32 \\end{pmatrix} =\n    \\begin{pmatrix} 19 & 22 \\\\ 43 & 50 \\end{pmatrix}.\n\\end{align*} $$\n\nNote that unlike numbers where is doesn't matter which way round they are when we multiplied (i.e., $1 \\times 2 = 2 \\times 1 = 2$) this is **not** the case with matrices. For example, lets calculate $BA$\n\n$$ \\begin{align*}\n    BA &=\n    \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix}\n    \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} =\n    \\begin{pmatrix}\n        (5, 6) \\cdot (1, 3) & (5, 6) \\cdot (2, 4) \\\\\n        (7, 8) \\cdot (1, 3) & (7, 8) \\cdot (2, 4)\n    \\end{pmatrix} \\\\\n    &=\n    \\begin{pmatrix} 5 + 18 & 10 + 24 \\\\ 7 + 24 & 14 + 32 \\end{pmatrix} =\n    \\begin{pmatrix} 23 & 34 \\\\ 31 & 46 \\end{pmatrix}.\n\\end{align*} $$\n\nSo based on these two examples we can see that $AB \\neq BA$ which is very important when it comes to calculating [transformations](transformations-section).\n\n```{important}\nThe glm operator `*` is used to multiply two or more matrices together. However, since glm uses column-major order to store matrices the order of the matrices is reversed so to calculate $AB$ we would use `B * A`.\n```\n\nAdd the following code to your program\n\n```cpp\nstd::cout <! \"A * B = \" <! glm::transpose(B * A) <! \"\\n\" <! std::endl;\nstd::cout <! \"B * A = \" <! glm::transpose(A * B) <! \"\\n\" <! std::endl;\n```\n\nRun the program and the following should be outputted to the console.\n\n```text\nA * B =\n[[   19.000,   22.000]\n [   43.000,   50.000]]\n\nB * A =\n[[   23.000,   34.000]\n [   31.000,   46.000]]\n```\n\n(identity-matrix-section)=\n\n### The identity matrix\n\nThe **identity matrix** is a special square matrix (a matrix with the same number of rows and columns) where all the elements are zero apart from the elements on the diagonal line from the top-left element down to the bottom-right element (known as the **main diagonal**). For example the $4\\times 4$ identity matrix is\n\n$$ I = \\begin{pmatrix}\n    1 & 0 & 0 & 0 \\\\\n    0 & 1 & 0 & 0 \\\\\n    0 & 0 & 1 & 0 \\\\\n    0 & 0 & 0 & 1\n\\end{pmatrix}.$$\n\nThe identity element is similar to the number 1 in that if we multiply any matrix by an identity matrix the result is unchanged. For example\n\n$$ \\begin{align*}\n    I_2A = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}\n    \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} =\n    \\begin{pmatrix}\n        (1,0) \\cdot (1, 3) & (1,0) \\cdot (2, 4) \\\\\n        (0,1) \\cdot (1,3) & (0,1) \\cdot (2,4)\n    \\end{pmatrix} =\n    \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}.\n\\end{align*} $$\n\nThe default constructor for a glm matrix object declares the matrix as an identity matrix. Add the following code to your program.\n\n```cpp\n// The identity matrix\nprintf(\"\\nThe identity matrix:\\n\");\nglm::mat4 I;\nstd::cout <! \"I = \" <! glm::transpose(I) <! \"\\n\" <! std::endl;\n```\n\nRun your program and you should see the following outputted to the console.\n\n```text\nThe identity matrix:\nI =\n[[    1.000,    0.000,    0.000,    0.000]\n [    0.000,    1.000,    0.000,    0.000]\n [    0.000,    0.000,    1.000,    0.000]\n [    0.000,    0.000,    0.000,    1.000]]\n```\n\n(inverse-matrix-section)=\n\n### Inverse matrices\n\nWhilst matrix multiplication is defined for certain matrices there is no way of dividing one matrix by another. However, for certain square matrices we can calculate an **inverse matrix** that performs a similar function to divide. Consider the division of two numbers, 4 and 2 say. If we wanted to divide 4 by two we could write\n\n$$ \\frac{8}{2} = 4. $$\n\nWe could also write this division as the multiplication of $\\dfrac{1}{2}$ and 8\n\n$$ \\frac{1}{2} \\times 8 = 4.$$\n\nHere we have shown that $\\frac{1}{2}$ is the **multiplicative inverse** of 2. A multiplicative inverse of a number $x$ is denoted as $x^{-1}$ and satisfies $x \\times x^{-1} = 1$. The inverse of a matrix $A$ is denoted by $A^{-1}$ and satisfies $A^{-1} A = AA^{-1} = I$ where $I$ is the identity matrix. For example, the inverse of the matrix $A$ defined above\n\n$$ A = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}, $$\n\nis\n\n$$ A^{-1} = \\begin{pmatrix} -2 & 1 \\\\ 3/2 & -1/2 \\end{pmatrix}. $$\n\nWe can check whether this is the inverse of $A$ by calculating $A^{-1}A$ (or $A A^{-1}$)\n\n$$ \\begin{align*}\n    A^{-1} A &=\n    \\begin{pmatrix} -2 & 1 \\\\ \\frac{3}{2} & -\\frac{1}{2} \\end{pmatrix}\n    \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} \\\\\n    &=\n    \\begin{pmatrix}\n        -2 \\times 1 + 1 \\times 3 & -2 \\times 2 + 1 \\times 4 \\\\ \n        \\frac{3}{2} \\times 1 + (-\\frac{1}{2}) \\times 3 & \\frac{3}{2} \\times 2 + (-\\frac{1}{2}) \\times 4\n    \\end{pmatrix} \\\\\n    &=\n    \\begin{pmatrix}\n        -2 + 3 & -4 + 4 \\\\\n        \\frac{3}{2} - \\frac{3}{2} & 3 - 2\n    \\end{pmatrix} \\\\\n    &= \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}.\n\\end{align*} $$\n\nThe glm function `glm::inverse()` calculates the inverse of a matrix. To demonstrate this, add the following code to your program.\n\n```cpp\n// Inverse matrices\nprintf(\"\\nInverse matrices:\\n\");\nglm::mat2 invA = glm::inverse(A);\nglm::mat2 invB = glm::inverse(B);\nstd::cout <! \"invA = \" <! glm::transpose(invA) <! \"\\n\" <! std::endl;\nstd::cout <! \"invB = \" <! glm::transpose(invB) <! \"\\n\" <! std::endl;\nstd::cout <! \"invA * A = \" <! glm::transpose(A * invA) <! \"\\n\" <! std::endl;\nstd::cout <! \"invB * B = \" <! glm::transpose(B * invB) <! \"\\n\" <! std::endl;\n```\n\nRun your program and the following should be outputted to the console.\n\n```text\nInverse matrices:\ninvA =\n[[   -2.000,    1.000]\n [    1.500,   -0.500]]\n\ninvB =\n[[   -4.000,    3.000]\n [    3.500,   -2.500]]\n\ninvA * A =\n[[    1.000,    0.000]\n [    0.000,    1.000]]\n\ninvB * B =\n[[    1.000,    0.000]\n [    0.000,    1.000]]\n```\n\n---\n\n(vectors-exercises)=\n\n## Exercises\n\n1. Three points have the coordinates $A = (5, 1, 3)$, $B = (10, 7, 4)$ and $C = (0, 5, -3)$. Use pen and paper to calculate the following:\n\n    (a) The vector $\\mathbf{p}$ that points from $A$ to $B$;<br>\n    (b) The vector $\\mathbf{q}$ that points from $B$ to $C$;<br>\n    (c) The vector $\\mathbf{r}$ that points from $C$ to $A$;<br>\n    (d) The length of the vector $\\mathbf{p}$;<br>\n    (e) A unit vector that points in the direction of the vector $\\mathbf{q}$;<br>\n    (f) The dot product $\\mathbf{p} \\cdot \\mathbf{q}$;<br>\n    (g) The cross product $\\mathbf{q} \\times \\mathbf{r}$.\n\n2. Repeat exercise 1 using C++ and the glm library.\n\n3. The three matrices $A$, $B$ and $C$ are defined as\n\n$$ \\begin{align*}\n    A &= \\begin{pmatrix} -1 & 3 \\\\ 2 & -5 \\end{pmatrix}, &\n    B &= \\begin{pmatrix} 0 & 2 \\\\ 7 & 1 \\end{pmatrix}, &\n    C &= \\begin{pmatrix} 3 & 2 \\\\ -3 & -4 \\end{pmatrix}.\n\\end{align*} $$\n\n&emsp;&emsp; Use C++ code to output the following:\n\n&emsp;&emsp; (a) $AB$;<br>\n&emsp;&emsp; (b) $ABC$;<br>\n&emsp;&emsp; (c) $CBA$;<br>\n&emsp;&emsp; (d) $A^\\mathsf{T}B$;<br>\n&emsp;&emsp; (e) $A^{-1}$.\n\n\n````{dropdown} Solutions\n1 (a) &emsp; $\\mathbf{p} = (5, 6, 1)$\n\n1 (b) &emsp; $\\mathbf{q} = (-10, -2, -7)$\n\n1 (c) &emsp; $\\mathbf{r} = (5, -4, 6)$\n\n1 (d) &emsp; $\\|\\mathbf{p}\\| = \\sqrt{62} \\approx = 7.87$\n\n1 (e) &emsp; $\\hat{\\mathbf{q}} = \\left(\\dfrac{-10}{\\sqrt{153}}, \\dfrac{-2}{\\sqrt{153}}, \\dfrac{-7}{\\sqrt{153}} \\right) \\approx (-0.81, -0.16, -0.57)$\n\n1 (f) &emsp; $\\mathbf{p} \\cdot \\mathbf{q} = -69$\n\n1 (g) &emsp; $\\mathbf{q} \\times \\mathbf{r} = (-40, 25, 50)$\n\n3 (a) &emsp; $AB = \\begin{pmatrix}21 & 1 \\\\ -35 & -1 \\end{pmatrix}$\n\n3 (b) &emsp; $ABC = \\begin{pmatrix}    60  &  38 \\\\\n  -102 &  -66 \\end{pmatrix}$\n\n3 (c) &emsp; $CBA = \\begin{pmatrix} 2 & 2 \\\\ 8 & -34 \\end{pmatrix}$\n\n3 (d) &emsp; $A^\\mathsf{T}B = \\begin{pmatrix} 14 & 0 \\\\ -35 & 1 \\end{pmatrix}$\n\n3 (e) &emsp; $A^{-1} = \\begin{pmatrix} 5 & 3 \\\\ 2 & 1 \\end{pmatrix}$\n\n```` ","type":"content","url":"/vectors-and-matrices#vectors","position":3},{"hierarchy":{"lvl1":"Computer Graphics"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Computer Graphics"},"content":"This site contains the notes used for the lab sessions for the Computer Graphics module. They are designed for students to work through in the labs with the help of the tutors. The content of each of the labs have been organised such that each one uses code from the preceding labs, so you will need to make sure you have completed each lab before moving onto the next one.\n\nWeek\n\nDate (w/c)\n\nContent\n\n1\n\n26/01/2026\n\nCore Computer Graphics Concepts: WebGL, the graphics pipeline, glossary of terms. Hello Triangle: vertex buffers, vertex and fragment shaders\n\n2\n\n02/02/2026\n\nVertex Colours, More Shapes & VAOs\n\n3\n\n09/02/2026\n\nTextures\n\n4\n\n16/02/2026\n\nVectors and Matrices\n\n5\n\n23/02/2026\n\nTransformations\n\n6\n\n02/03/2026\n\n3D Worlds\n\n7\n\n09/03/2026\n\nMoving the Camera\n\n8\n\n16/03/2026\n\nLighting Models\n\n9\n\n23/03/2026\n\nNormal Maps\n\n10\n\n20/04/2026\n\nQuaternions","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Computer Graphics","lvl2":"Core Computer Graphics Concepts"},"type":"lvl2","url":"/#core-computer-graphics-concepts","position":2},{"hierarchy":{"lvl1":"Computer Graphics","lvl2":"Core Computer Graphics Concepts"},"content":"","type":"content","url":"/#core-computer-graphics-concepts","position":3},{"hierarchy":{"lvl1":"Computer Graphics","lvl3":"The Graphics Pipeline","lvl2":"Core Computer Graphics Concepts"},"type":"lvl3","url":"/#the-graphics-pipeline","position":4},{"hierarchy":{"lvl1":"Computer Graphics","lvl3":"The Graphics Pipeline","lvl2":"Core Computer Graphics Concepts"},"content":"The graphics pipeline (or rendering pipeline) is a sequence of steps the GPU takes to convert 3D scene data (e.g., vertices, textures, lighting information, etc.) into a 2D image displayed on the screen. Like many graphics APIs, WebGL uses vertex shaders and fragment shaders, small programs that are written in GLSL (OpenGL Shading Language) which are run directly on the GPU to perform these steps.\n\nThe stages of the graphics pipeline are:\n\nVertex specification -- the geometry of objects that construct a 3D scene are defined using arrays of vertices. Each vertex is a collection of data, typically the co-ordinates of the vertex position but can also include texture co-ordinates, surface normal vectors and other attributes (more on these later). In WebGL we create Vertex Buffer Objects (VBO) to store this data and tell WebGL how to interpret them.\n\nVertex shader -- each vertex is processed by a vertex shader whose job it is to transform the 3D co-ordinates from the model space (the local object co-ordinates) into clip space (the co-ordinate system the GPU uses to determine what is visible on screen). The vertex shader is called once per vertex.\n\nClipping -- the vertex outputs from the vertex shader are grouped into primitives (usually triangles) and clipped to the clip space such that any primitive that lie outside the clip space are ignored. Primitives that lie partially outside the clip space are cut so that the part that is within the clip space is retained.\n\nRasterisation -- the primitives are converted into grids of pixels known as fragments. The interior fragments of a primitive are “filled in” by interpolating the vertex data across the surface.\n\nFragment shader -- each fragment is processed by the fragment shader which computes the final colour. This can be based on vertex data, texture mapping, lighting models and other visual effects.\n\nPer-fragment operations -- before a fragment is displayed (i.e., becomes a pixel on the screen), depth testing (is it hidden by something else), alpha testing (for transparency) and stencil testing (for masking). Fragments can be discarded at this stage.\n\nFrame buffer -- after processing the fragment is written to the frame buffer which is then is sent to the display.","type":"content","url":"/#the-graphics-pipeline","position":5}]}