{"version":2,"kind":"Article","sha256":"a0f9adbaff06cf8d28b5e3b5c82877124c89026e9ceeb474be265728aaefb625","slug":"vectors-and-matrices","location":"/_pages/04_Vectors_and_matrices.md","dependencies":[],"frontmatter":{"title":"Vectors and Matrices","content_includes_title":false,"github":"https://github.com/jonshiach/graphics-notes","keywords":["jupyter-book","something-else"],"numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"04_Vectors_and_matrices.md","url":"/04_Vectors_and_matri-7f6c90524096c957851196da58e69e3e.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Computer graphics relies heavily on mathematics of vectors and matrices. In this lab we will be revising the important concepts needed for computer graphics and using a library to perform calculations.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"S9qbh8Hqbb"}],"key":"Q1j9VSzt1g"},{"type":"thematicBreak","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"xDnHjD7I5f"},{"type":"heading","depth":2,"position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"Vectors","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"FeT3fA0ntm"}],"identifier":"vectors","label":"Vectors","html_id":"vectors","implicit":true,"key":"RRgVmxs452"},{"type":"paragraph","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"A vector in is an object with magnitude (length) and direction. A vector is denoted by a lower case letter in boldface, e.g., ","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"QjrtgLUBVj"},{"type":"inlineMath","value":"\\mathbf{a}","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">a</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{a}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4444em;\"></span><span class=\"mord mathbf\">a</span></span></span></span>","key":"LxotVPlJwg"},{"type":"text","value":" (or underlined when writing by hand), and represented mathematically by a tuple which is an ordered set of numbers. In geometry, each number in the vector represents the length along the co-ordinate axes. For example, consider the 3-element vector","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"niOJrIZnJO"}],"key":"CxL6Q018Jr"},{"type":"math","value":"\\mathbf{a} = (a_x, a_y, a_z).","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"html":"<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"bold\">a</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi>a</mi><mi>x</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>y</mi></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>z</mi></msub><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{a} = (a_x, a_y, a_z).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4444em;\"></span><span class=\"mord mathbf\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.04398em;\">z</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span></span>","enumerator":"1","key":"kBMFVzh729"},{"type":"comment","value":" Here $\\mathbf{a}$ has 3 elements so is a vector in 3D space where $a_x$, $a_y$ and $a_z$ are the lengths of the vector in the $x$, $y$, and $z$ directions.\n\n```{figure} ../_images/04_Vector.svg\n:height: 200\n:name: vector-figure\n\nThe vector $\\mathbf{a} = (a_x, a_y, a_z)$.\n```\n\n```{note}\nThe reason the diagram in {numref}`vector-figure` has the $y$-axis pointing upwards and the $z$-axis pointing along the horizontal is because this is the way OpenGL represents 3D space (see [5. Transformations](transformations-section) for more details). The configuration of the axes does not matter for the calculations we will be performing in this lab, but I wanted to be consistent. \n```\n\nLets create the following 3D vector objects in C++.\n\n$$ \\begin{align*}\n    \\mathbf{a} &= (3, 0, 4), &\n    \\mathbf{b} &= (1, 2, 3).\n\\end{align*} $$\n\nAdd the following code to the `main()` function.\n\n```cpp\n// Vectors\nprintf(\"Vectors and Matrices\\n\");\nprintf(\"--------------------------------------------------\\n\");\n\n// Defining vectors\nglm::vec3 a, b;\na = glm::vec3(3.0f, 0.0f, 4.0f);\nb[0] = 1.0f, b[1] = 2.0f, b[2] = 3.0f;\n\nprintf(\"Defining vectors:\\n\");\nstd::cout <! \"a = \" <! a <! std::endl;\nstd::cout <! \"b = \" <! b <! std::endl;\n```\n\nHere we have declared two vectors `a` and `b` using the `glm::vec3` type (for vectors in 2D we would use `glm::vec2`). The elements of the vectors `a` and `b` have been defined using two different methods: `a` has been defined using the `glm::vec3(x, y, z)` constructor and `b` by accessing the individual elements using [array indexing](arrays-section). The vectors have been printed to the console using `std::cout` commands (glm vectors cannot be printed using the `printf()` function). Compile and run the **Lab04_Vectors_and_matrices** project, and you should see the following outputted to the console.\n\n```text\nVectors and Matrices\n--------------------------------------------------\nDefining vectors:\na = [    3.000,    0.000,    4.000]\nb = [    1.000,    2.000,    3.000]\n```\n\n(vector-magnitude-section)=\n\n### Vector magnitude\n\nThe **magnitude** of a vector $\\mathbf{a} = (a_x, a_y, a_z)$ is denoted by $\\|\\mathbf{a}\\|$ is the length from the tail of the vector to the head.\n\n```{figure} ../_images/04_Vector_magnitude.svg\n:height: 100\n\nThe magnitude of $\\mathbf{a}$ is the length of the vector.\n```\n\nThe magnitude is calculated using an extension of Pythagoras' theorem, for example for 3D vectors the magnitude is\n\n$$ \\|\\mathbf{a}\\| = \\sqrt{a_x^2 + a_y^2 + a_z^2}. $$(eq:vector-magnitude)\n\nFor example, for the vectors $\\mathbf{a}$ and $\\mathbf{b}$ given above the magnitudes are\n\n$$ \\begin{align*}\n    \\| \\mathbf{a} \\| &= \\sqrt{3^2 + 0^2 + 4^2} = \\sqrt{9 + 0 + 16} = \\sqrt{25} = 5, \\\\\n    \\| \\mathbf{b} \\| &= \\sqrt{1^2 + 2^2 + 3^2} = \\sqrt{1 + 4 + 9} = \\sqrt{14} = 3.742\\ldots\n\\end{align*}  $$\n\nThe `glm::length()` function calculates the magnitude of a glm vector object. To demonstrate this,  add the following code to your program.\n\n```cpp\n// Vector length\nprintf(\"\\nVector length:\\n\");\nprintf(\"length(a) = %0.3f\\n\", glm::length(a));\nprintf(\"length(b) = %0.3f\\n\", glm::length(b));\n```\n\nRunning the program you should see the following printed to the console.\n\n```text\nVector length:\nlength(a) = 5.000\nlength(b) = 3.742\n```\n\n(unit-vectors-section)=\n\n### Unit vectors\n\nA **unit vector** is a vector that has a length of 1. We can find a unit vector that points in the same direction as a non-zero vector $\\mathbf{a}$, which is denoted by $\\hat{\\mathbf{a}}$ (pronounced *a-hat*), by dividing by its magnitude, i.e.,\n\n$$ \\hat{\\mathbf{a}} = \\frac{\\mathbf{a}}{\\|\\mathbf{a}\\|}. $$(eq:unit-vector)\n\nThis process is called **normalising a vector**. For example, to determine a unit vector pointing in the same direction as $\\mathbf{a} = (3, 0, 4)$ we normalise it by dividing by its magnitude which we have already calculated is 5.\n\n$$ \\begin{align*}\n    \\hat{\\mathbf{a}} &= \\frac{(3, 0, 4)}{5} = \\left( \\frac{3}{5}, 0, \\frac{4}{5} \\right) = (0.6, 0, 0.8).\n\\end{align*} $$\n\nChecking that $\\hat{\\mathbf{a}}$ has a magnitude of 1\n\n$$ \\|\\hat{\\mathbf{a}}\\| = \\sqrt{0.6^2 + 0^2 + 0.8^2} = \\sqrt{0.36 + 0.64} = \\sqrt{1} = 1.$$\n\nNormalising a vector is an operation that is used a lot in graphics programming so the glm library has the function `glm::normalize()` to do this. Add the following code to your program.\n\n```cpp\n// Normalising vectors\nglm::vec3 aHat, bHat;\naHat = glm::normalize(a);\nbHat = b / glm::length(b);\n\nprintf(\"\\nNormalising vectors:\\n\");\nstd::cout <! \"aHat = \" <! aHat <! std::endl;\nstd::cout <! \"bHat = \" <! bHat <! std::endl;\nprintf(\"length(aHat) = %0.3f\\n\", glm::length(aHat));\nprintf(\"length(bHat) = %0.3f\\n\", glm::length(bHat));\n```\n\nHere we are calculating unit vectors from `a` and `b` using the `glm::normalize()` function and dividing by the vector magnitude. Running your program you should see the following printed to the console.\n\n```text\nNormalising vectors:\naHat = [    0.600,    0.000,    0.800]\nbHat = [    0.267,    0.535,    0.802]\nlength(aHat) = 1.000\nlength(bHat) = 1.000\n```\n\nBoth `aHat` and `bHat` have magnitudes of 1 which shows they are both unit vectors.\n\n## Arithmetic operations on vectors\n\nLike numbers, we can define the arithmetic operations of addition, subtraction for vectors as well as multiplication and division by a scalar.\n\n### Vector addition and subtraction\n\nThe addition and subtraction of two vectors $\\mathbf{a} = (a_x, a_y, a_z)$ and $\\mathbf{b} = (b_x, b_y, b_z)$ is defined by\n\n$$ \\begin{align*}\n    \\mathbf{a} + \\mathbf{b} &= (a_x + b_x, a_y + b_y, a_z + b_z), \\\\\n    \\mathbf{a} - \\mathbf{b} &= (a_x - b_x, a_y - b_y, a_z - b_z).\n\\end{align*} $$(eq:vector-addition)\n\nFor example, given the vectors $\\mathbf{a} = (3,0,4)$ and $\\mathbf{b} = (1, 2, 3)$\n\n$$ \\begin{align*}\n    \\mathbf{a} + \\mathbf{b} &= (3, 0, 4) + (1, 2, 3) = (3 + 1, 0 + 2, 4 + 3) = (4, 2, 7), \\\\\n    \\mathbf{a} - \\mathbf{b} &= (3, 0, 4) - (1, 2, 3) = (3 - 1, 0 - 2, 4 - 3) = (2, -2, 1).\n\\end{align*} $$\n\nWhat is happening in a geometrical sense when we add and subtract vectors? Take a look at {numref}`vector-addition-figure`, here the vector $\\mathbf{b}$ has been added to the vector $\\mathbf{a}$ where the tail of $\\mathbf{b}$ is placed at the head of $\\mathbf{a}$. The resulting vector $\\mathbf{a} + \\mathbf{b}$ points from the tail of $\\mathbf{a}$ to the head of $\\mathbf{b}$.\n\n```{figure} ../_images/04_Vector_addition.svg\n:height: 150\n:name: vector-addition-figure\n\nVector addition.\n```\n\nThe subtraction of the vector $\\mathbf{b}$ does similar, but since $\\mathbf{a} - \\mathbf{b} = \\mathbf{a} + (-1)\\mathbf{b}$ then the direction of $\\mathbf{b}$ is reversed so $\\mathbf{a} - \\mathbf{b}$ is the same as placing the tail of $-\\mathbf{b}$ at the head of $\\mathbf{a}$.\n\n```{figure} ../_images/04_Vector_subtraction.svg\n:height: 180\n:name: vector-subtraction-figure\n\nVector subtraction.\n```\n\nTo calculate the addition and subtraction of our vectors add the following code to your program.\n\n```cpp\n// Arithmetic operations on vectors\nprintf(\"\\nArithmetic operations on vectors:\\n\");\nstd::cout <! \"a + b = \" <! a + b <! std::endl;\nstd::cout <! \"a - b = \" <! a - b <! std::endl;\n```\n\nRunning the program adds the following output to the console.\n\n```text\nArithmetic operations on vectors:\na + b = [    4.000,    2.000,    7.000]\na - b = [    2.000,   -2.000,    1.000]\n```\n\n### Multiplication and division by a scalar\n\nMultiplication and division of a vector $\\mathbf{a} = (a_x, a_y, a_z)$ by a scalar (a number) $k$ are defined by\n\n$$ \\begin{align*}\n    k \\mathbf{a} &= (ka_x, ka_y, ka_z), \\\\\n    \\frac{\\mathbf{a}}{k} &= \\left(\\frac{a_x}{k}, \\frac{a_y}{k}, \\frac{a_z}{k} \\right).\n\\end{align*} $$\n\nMultiplying or dividing a vector by a positive scalar has the effect of scaling the length of the vector. Multiplying or dividing by a negative scalar reverses the direction of the vector.\n\n```{figure} ../_images/04_vector_multiplication.svg\n:height: 180\n```\n\nFor example, multiplying the vector $\\mathbf{a} = (3, 0, 4)$ by the scalar 2 gives\n\n$$ 2\\mathbf{a} = 2(3,0,4) = (6, 0, 8), $$\n\nWhich has the magnitude\n\n$$ \\|2 \\mathbf{a} \\| = \\sqrt{6^2 + 0^2 + 8^2} = \\sqrt{36 + 64} = \\sqrt{100} = 10 = 2 \\|\\mathbf{a}\\|. $$\n\nTo perform scalar multiplication or division on a glm vector we simply use the `*` and `/` operators. To demonstrate this add the following code to your program.\n\n```cpp\nstd::cout <! \"2a    = \" <! 2.0f * a <! std::endl;\nstd::cout <! \"b / 3 = \" <! b / 3.0f <! std::endl;\n```\n\nNote that we need to use float values for scalar multiplication and division, i.e., `2.0f` and `3.0f` instead of `2` and `3`. Running the program will add the following to the console.\n\n```text\n2a    = [    6.000,    0.000,    8.000]\nb / 3 = [    0.333,    0.667,    1.000]\n```\n\n(element-wise-multiplication-section)=\n\n### Element-wise multiplication\n\nMathematically speaking the multiplication of two vectors is not defined (instead we have the dot and cross products - see [below](dot-product-section)). However, in computing it is useful to be able to multiply the individual elements of vectors, known as **element-wise multiplication**, which is done using the `*` operator.\n\nAdd the following code to your program.\n\n```cpp\nstd::cout <! \"a * b = \" <! a * b <! std::endl;\n```\n\nRunning the program gives the following output.\n\n```text\na * b = [    3.000,    0.000,   12.000]\n```\n\nSo each element of `a * b` is the product of the corresponding elements in the vectors `a` and `b`.\n\n(dot-product-section)=\n\n### The dot product\n\nThe <a href=\"https://en.wikipedia.org/wiki/Dot_product\" target=\"_blank\">**dot product**</a> between two vectors $\\mathbf{a} = (a_x, a_y, a_z)$ and $\\mathbf{b} = (b_x, b_y, b_z)$ is denoted by $\\mathbf{a} \\cdot \\mathbf{b}$ and returns a scalar. The dot product is calculated using\n\n$$ \\mathbf{a} \\cdot \\mathbf{b} = a_xb_x + a_yb_y + a_zb_z. $$(eq:dot-product)\n\nThe dot product is related to the angle $\\theta$ between the two vectors ({numref}`angle-between-vectors-figure`) by\n\n$$ \\mathbf{a} \\cdot \\mathbf{b} = \\|\\mathbf{a}\\| \\|\\mathbf{b}\\| \\cos(\\theta). $$(eq:dot-product-geometric)\n\n```{figure} ../_images/04_Dot_product.svg\n:height: 125\n:name: angle-between-vectors-figure\n\nThe angle $\\theta$ between the vectors $\\mathbf{a}$ and $\\mathbf{b}$.\n```\n\nA useful result for computer graphics is that if $\\theta=90^\\circ$ then $\\cos(\\theta) = 0$ and equation {eq}`eq:dot-product-geometric` becomes\n\n$$ \\mathbf{a} \\cdot \\mathbf{b} = 0. $$\n\nIn order words, if the dot product of two vectors is zero then the two vectors are perpendicular. For example, given the vectors $\\mathbf{a} = (3, 0, 4)$ and $\\mathbf{b} = (1, 2, 3)$ the dot product between these are\n\n$$ \\begin{align*}\n    \\mathbf{a} \\cdot \\mathbf{b} &= (3, 0, 4) \\cdot (1, 2, 3)\n    = 3 + 0 + 12\n    = 15.\n\\end{align*} $$\n\nThe glm function `glm::dot()` calculates the dot product of two vectors. To demonstrate its use, add the following code to your program.\n\n```cpp\n// Dot and Cross products\nprintf(\"\\nDot and cross products:\\n\");\nprintf(\"a . b = %0.3f\\n\", glm::dot(a, b));\n```\n\nRunning the program results in the following output.\n\n```text\nDot and cross products:\na . b = 15.000\n```\n\n(cross-product-section)=\n\n### The cross product\n\nThe <a href=\"https://en.wikipedia.org/wiki/Cross_product\" target=\"_blank\">**cross product**</a> between two vectors $\\mathbf{a} = (a_x, a_y, a_z)$ and $\\mathbf{b} = (b_x, b_y, b_z)$ is denoted by $\\mathbf{a} \\times \\mathbf{b}$ and returns a vector. The cross product is calculated using\n\n$$ \\mathbf{a} \\times \\mathbf{b} = (a_yb_z - a_zb_y, a_zb_x - a_xb_z, a_xb_y - a_yb_x). $$(eq:cross-product)\n\nThe cross product between two vectors produces another vector that is perpendicular to both of the vectors ({numref}`cross-product-figure`). This is another incredibly useful result as it allows us to calculate a [**normal vector**](normal-vector-section) to a polygon which are used in calculating how light is reflected off surfaces (see [8. Lighting](lighting-section)).\n\n```{figure} ../_images/04_cross_product.svg\n:height: 200\n:name: cross-product-figure\n\nThe cross product between two vectors gives a vector that is perpendicular to both vectors.\n```\n\nFor example, given the vectors $\\mathbf{a} = (3,0,4)$ and $\\mathbf{b} = (1, 2, 3)$ the cross product $\\mathbf{a} \\times \\mathbf{b}$ is\n\n$$ \\begin{align*}\n    \\mathbf{a} \\times \\mathbf{b} &= (3, 0, 4) \\times (1, 2, 3) \\\\\n    &= (0 \\times 3 - 4 \\times 2, 4 \\times 1 - 3 \\times 3, 3 \\times 2 - 0 \\times 3) \\\\\n    &= (-8, -5, 6).\n\\end{align*} $$\n\nWe can show that $\\mathbf{a} \\times \\mathbf{b}$ is perpendicular to both $\\mathbf{a}$ and $\\mathbf{b}$ using the dot product\n\n$$ \\begin{align*}\n    \\mathbf{a} \\cdot (\\mathbf{a} \\times \\mathbf{b}) &= (3, 0, 4) \\cdot (-8, -5, 6) = -24 + 0 + 24 = 0, \\\\\n    \\mathbf{b} \\cdot (\\mathbf{a} \\times \\mathbf{b}) &= (1, 2, 3) \\cdot (-8, -5, 6) = - 8 - 10 + 18 = 0.\n\\end{align*} $$\n\nThe glm function `glm::cross()` calculates the cross product of two vectors. To demonstrate its use, add the following code to your program.\n\n```cpp\nstd::cout <! \"a x b = \" <! glm::cross(a, b) <! std::endl;\nprintf(\"a . (a x b) = %0.3f\\n\", glm::dot(a, glm::cross(a, b)));\nprintf(\"b . (a x b) = %0.3f\\n\", glm::dot(b, glm::cross(a, b)));\n```\n\nRunning the program results in the following output.\n\n```text\na x b = [   -8.000,   -5.000,    6.000]\na . (a x b) = 0.000\nb . (a x b) = 0.000\n```\n\nHere we have also shown that the cross product of `a` and `b` is perpendicular to both vectors.\n\n---\n\n## Matrices\n\nAnother type of mathematic object that is fundamental to computer graphics is the matrix. A matrix is a rectangular array of numbers.\n\n$$ \\begin{align*}\n    A =\n    \\begin{pmatrix}\n        a_{11} & a_{12} & \\cdots & a_{1n} \\\\\n        a_{21} & a_{22} & \\cdots & a_{2n} \\\\\n        \\vdots & \\vdots & \\ddots & \\vdots \\\\\n        a_{m1} & a_{m2} & \\cdots & a_{mn}\n    \\end{pmatrix}\n\\end{align*} $$\n\nIt is common to use uppercase characters for the name of a matrix and lowercase characters for the individual elements. The elements of a matrix are referenced by an **index** which is a pair of numbers, the first of which is the horizontal row number and the second is the vertical column number so $a_{ij}$ is the element in row $i$ and column $j$ of the matrix $A$.  \n\nWe refer to the size of a matrix by the number of rows by the number of columns. Here the matrix $A$ has $m$ rows and $n$ columns, so we call this matrix a $m \\times n$ matrix.\n\nTo declare a $2 \\times 2$ glm matrix object we use the `glm::mat2()` function (a $4 \\times 4$ matrix object is declared using `glm::mat4()`)\nLets create some glm matrix objects for the following matrices\n\n$$ \\begin{align*}\n    A &= \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}, &\n    B &= \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix}.\n\\end{align*} $$\n\nEnter the following code into your program.\n\n```cpp\n// Defining matrices\nglm::mat2 A, B;\n\nA[0][0] = 1.0f, A[0][1] = 2.0f;\nA[1][0] = 3.0f, A[1][1] = 4.0f;\n\nB = glm::mat2(5.0f, 6.0f, 7.0f, 8.0f);\n\nprintf(\"\\nDefining matrices:\\n\");\nstd::cout <! \"A = \" <! A <! \"\\n\" <! std::endl;\nstd::cout <! \"B = \" <! B <! std::endl;\n```\n\nHere we have declared two $2 \\times 2$ matrices `A` and `B`. The elements of `A` are defined using matrix indexing and the elements of `B` are defined using the `glm::mat2()` function. Note how the elements of the 2D matrix are indexed using `[row][col]`\n\nRun your program and the following should be printed to the console.\n\n```text\nDefining matrices:\nA =\n[[    1.000,    3.000]\n [    2.000,    4.000]]\n\nB =\n[[    5.000,    7.000]\n [    6.000,    8.000]]\n```\n\nHang on something isn’t right here. Looking at the matrix `A` that was outputted we have 1 and 3 on the top row when we were expecting 1 and 2 (and similar for `B`), so what has gone wrong? To explain we need to look at how arrays are stored in the memory.\n\n(column-major-order-section)=\n\n### Column-major order\n\nLinear memory is a contiguous block of addresses that can be sequentially accessed. So a 1D array is stored in adjacent memory locations. Since matrices are 2D we have a choice whether to store the elements in the rows or columns in adjacent locations. These are known as **column-major order** and **row-major order**. Consider the $4 \\times 4$ matrix\n\n$$ \\begin{align*}\n    \\begin{pmatrix}\n        a & b & c & d \\\\\n        e & f & g & h \\\\\n        i & j & k & l \\\\\n        m & n & o & p\n    \\end{pmatrix}.\n\\end{align*} $$\n\nUsing column-major order this will be stored in the memory as\n\n```{figure} ../_images/04_Column_major.svg\n:width: 600\n```\n\ni.e., we move down and across the matrix. Alternatively, using row-major order the matrix will be stored as\n\n```{figure} ../_images/04_Row_major.svg\n:width: 600\n```\n\ni.e., we move across and down the matrix. The choice of whether to use column-major or row-major order is arbitrary but OpenGL uses column-major order so glm does as well (incidentally Microsoft's graphics library directX uses row-major order which means when porting code between the graphics libraries developers have to change all of their matrix calculations).\n\nSo since OpenGL uses column-major order them so does glm. This is way our matrices `A` and `B` were outputted column-by-column. If we want to view the matrix how it should be we need to calculate its transpose.\n\n(transpose-section)=\n\n### Matrix transpose\n\nThe **transpose** of a matrix $A$ is denoted by $A^\\mathsf{T}$ and is defined by swapping the rows and columns of $A$. For example, the matrix $A$ defined above\n\n$$ \\begin{align*}\n    A = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix},\n\\end{align*} $$\n\nthen $A^\\mathsf{T}$ is\n\n$$ \\begin{align*}\n    A^\\mathsf{T} = \\begin{pmatrix} 1 & 3 \\\\ 2 & 4 \\end{pmatrix}.\n\\end{align*} $$\n\nEdit the code in your program so that the transpose of `A` and `B` are outputted to the console instead.\n\n```cpp\nstd::cout <! \"A = \" <! glm::transpose(A) <! \"\\n\" <! std::endl;\nstd::cout <! \"B = \" <! glm::transpose(B) <! std::endl;\n```\n\nRunning the program should change the output to\n\n```text\nDefining matrices:\nA =\n[[    1.000,    2.000]\n [    3.000,    4.000]]\n\nB =\n[[    5.000,    6.000]\n [    7.000,    8.000]]\n```\n\nThat's better.\n\n## Arithmetic operations on matrices\n\nThe arithmetic operations on matrices for addition and subtraction of two matrices and multiplying and dividing by a scalar are the same as for vectors using the `+`, `-`, `*` and `/` operators. To show these add the following code to your program.\n\n```cpp\n// Arithmetic operations on matrices\nprintf(\"\\nArithmetic operations on matrices:\\n\");\nstd::cout <! \"A + B = \" <! glm::transpose(A + B) <! \"\\n\" <! std::endl;\nstd::cout <! \"A - B = \" <! glm::transpose(A - B) <! \"\\n\" <! std::endl;\nstd::cout <! \"2A    = \" <! glm::transpose(2.0f * A) <! \"\\n\" <! std::endl;\nstd::cout <! \"A / 3 = \" <! glm::transpose(A / 3.0f) <! \"\\n\" <! std::endl;\n```\n\nRunning the program should output the following to the console.\n\n```text\nArithmetic operations on matrices:\nA + B =\n[[    6.000,    8.000]\n [   10.000,   12.000]]\n\nA - B =\n[[   -4.000,   -4.000]\n [   -4.000,   -4.000]]\n\n2A    =\n[[    2.000,    4.000]\n [    6.000,    8.000]]\n\nA / 3 =\n[[    0.333,    0.667]\n [    1.000,    1.333]]\n```\n\n(matrix-multiplication-section)=\n\n### Matrix multiplication\n\nSo multiplication of a matrix by a scalar is the same for matrices as it is for vectors. However, the multiplication of two matrices $A$ and $B$ is defined in a very specific way. If $A$ and $B$ are two matrices then the element in row $i$ and column $j$ of the matrix $AB$ is calculated using\n\n$$ [AB]_{ij} = \\mathbf{a}_i \\cdot \\mathbf{b}_j, $$(eq:matrix-multiplication)\n\nWhere $\\mathbf{a}_i$ is the vector formed from row $i$ of $A$ and $\\mathbf{b}_j$ is the vector formed from column $j$ of $B$. For example, given the $2\\times 2$ matrices $A$ and $B$ defined earlier\n\n$$ \\begin{align*}\n    A &= \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}, &\n    B &= \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix},\n\\end{align*} $$\n\nthen the multiplication $AB$ is\n\n$$ \\begin{align*}\n    AB &=\n    \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}\n    \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} =\n    \\begin{pmatrix}\n        (1, 2) \\cdot (5, 7) & (1,2) \\cdot (6, 8) \\\\\n        (3, 4) \\cdot (5, 7) & (3, 4) \\cdot (6, 8)\n    \\end{pmatrix} \\\\\n    &=\n    \\begin{pmatrix} 5 + 14 & 6 + 16 \\\\ 15 + 28 & 18 + 32 \\end{pmatrix} =\n    \\begin{pmatrix} 19 & 22 \\\\ 43 & 50 \\end{pmatrix}.\n\\end{align*} $$\n\nNote that unlike numbers where is doesn't matter which way round they are when we multiplied (i.e., $1 \\times 2 = 2 \\times 1 = 2$) this is **not** the case with matrices. For example, lets calculate $BA$\n\n$$ \\begin{align*}\n    BA &=\n    \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix}\n    \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} =\n    \\begin{pmatrix}\n        (5, 6) \\cdot (1, 3) & (5, 6) \\cdot (2, 4) \\\\\n        (7, 8) \\cdot (1, 3) & (7, 8) \\cdot (2, 4)\n    \\end{pmatrix} \\\\\n    &=\n    \\begin{pmatrix} 5 + 18 & 10 + 24 \\\\ 7 + 24 & 14 + 32 \\end{pmatrix} =\n    \\begin{pmatrix} 23 & 34 \\\\ 31 & 46 \\end{pmatrix}.\n\\end{align*} $$\n\nSo based on these two examples we can see that $AB \\neq BA$ which is very important when it comes to calculating [transformations](transformations-section).\n\n```{important}\nThe glm operator `*` is used to multiply two or more matrices together. However, since glm uses column-major order to store matrices the order of the matrices is reversed so to calculate $AB$ we would use `B * A`.\n```\n\nAdd the following code to your program\n\n```cpp\nstd::cout <! \"A * B = \" <! glm::transpose(B * A) <! \"\\n\" <! std::endl;\nstd::cout <! \"B * A = \" <! glm::transpose(A * B) <! \"\\n\" <! std::endl;\n```\n\nRun the program and the following should be outputted to the console.\n\n```text\nA * B =\n[[   19.000,   22.000]\n [   43.000,   50.000]]\n\nB * A =\n[[   23.000,   34.000]\n [   31.000,   46.000]]\n```\n\n(identity-matrix-section)=\n\n### The identity matrix\n\nThe **identity matrix** is a special square matrix (a matrix with the same number of rows and columns) where all the elements are zero apart from the elements on the diagonal line from the top-left element down to the bottom-right element (known as the **main diagonal**). For example the $4\\times 4$ identity matrix is\n\n$$ I = \\begin{pmatrix}\n    1 & 0 & 0 & 0 \\\\\n    0 & 1 & 0 & 0 \\\\\n    0 & 0 & 1 & 0 \\\\\n    0 & 0 & 0 & 1\n\\end{pmatrix}.$$\n\nThe identity element is similar to the number 1 in that if we multiply any matrix by an identity matrix the result is unchanged. For example\n\n$$ \\begin{align*}\n    I_2A = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}\n    \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} =\n    \\begin{pmatrix}\n        (1,0) \\cdot (1, 3) & (1,0) \\cdot (2, 4) \\\\\n        (0,1) \\cdot (1,3) & (0,1) \\cdot (2,4)\n    \\end{pmatrix} =\n    \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}.\n\\end{align*} $$\n\nThe default constructor for a glm matrix object declares the matrix as an identity matrix. Add the following code to your program.\n\n```cpp\n// The identity matrix\nprintf(\"\\nThe identity matrix:\\n\");\nglm::mat4 I;\nstd::cout <! \"I = \" <! glm::transpose(I) <! \"\\n\" <! std::endl;\n```\n\nRun your program and you should see the following outputted to the console.\n\n```text\nThe identity matrix:\nI =\n[[    1.000,    0.000,    0.000,    0.000]\n [    0.000,    1.000,    0.000,    0.000]\n [    0.000,    0.000,    1.000,    0.000]\n [    0.000,    0.000,    0.000,    1.000]]\n```\n\n(inverse-matrix-section)=\n\n### Inverse matrices\n\nWhilst matrix multiplication is defined for certain matrices there is no way of dividing one matrix by another. However, for certain square matrices we can calculate an **inverse matrix** that performs a similar function to divide. Consider the division of two numbers, 4 and 2 say. If we wanted to divide 4 by two we could write\n\n$$ \\frac{8}{2} = 4. $$\n\nWe could also write this division as the multiplication of $\\dfrac{1}{2}$ and 8\n\n$$ \\frac{1}{2} \\times 8 = 4.$$\n\nHere we have shown that $\\frac{1}{2}$ is the **multiplicative inverse** of 2. A multiplicative inverse of a number $x$ is denoted as $x^{-1}$ and satisfies $x \\times x^{-1} = 1$. The inverse of a matrix $A$ is denoted by $A^{-1}$ and satisfies $A^{-1} A = AA^{-1} = I$ where $I$ is the identity matrix. For example, the inverse of the matrix $A$ defined above\n\n$$ A = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}, $$\n\nis\n\n$$ A^{-1} = \\begin{pmatrix} -2 & 1 \\\\ 3/2 & -1/2 \\end{pmatrix}. $$\n\nWe can check whether this is the inverse of $A$ by calculating $A^{-1}A$ (or $A A^{-1}$)\n\n$$ \\begin{align*}\n    A^{-1} A &=\n    \\begin{pmatrix} -2 & 1 \\\\ \\frac{3}{2} & -\\frac{1}{2} \\end{pmatrix}\n    \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} \\\\\n    &=\n    \\begin{pmatrix}\n        -2 \\times 1 + 1 \\times 3 & -2 \\times 2 + 1 \\times 4 \\\\ \n        \\frac{3}{2} \\times 1 + (-\\frac{1}{2}) \\times 3 & \\frac{3}{2} \\times 2 + (-\\frac{1}{2}) \\times 4\n    \\end{pmatrix} \\\\\n    &=\n    \\begin{pmatrix}\n        -2 + 3 & -4 + 4 \\\\\n        \\frac{3}{2} - \\frac{3}{2} & 3 - 2\n    \\end{pmatrix} \\\\\n    &= \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}.\n\\end{align*} $$\n\nThe glm function `glm::inverse()` calculates the inverse of a matrix. To demonstrate this, add the following code to your program.\n\n```cpp\n// Inverse matrices\nprintf(\"\\nInverse matrices:\\n\");\nglm::mat2 invA = glm::inverse(A);\nglm::mat2 invB = glm::inverse(B);\nstd::cout <! \"invA = \" <! glm::transpose(invA) <! \"\\n\" <! std::endl;\nstd::cout <! \"invB = \" <! glm::transpose(invB) <! \"\\n\" <! std::endl;\nstd::cout <! \"invA * A = \" <! glm::transpose(A * invA) <! \"\\n\" <! std::endl;\nstd::cout <! \"invB * B = \" <! glm::transpose(B * invB) <! \"\\n\" <! std::endl;\n```\n\nRun your program and the following should be outputted to the console.\n\n```text\nInverse matrices:\ninvA =\n[[   -2.000,    1.000]\n [    1.500,   -0.500]]\n\ninvB =\n[[   -4.000,    3.000]\n [    3.500,   -2.500]]\n\ninvA * A =\n[[    1.000,    0.000]\n [    0.000,    1.000]]\n\ninvB * B =\n[[    1.000,    0.000]\n [    0.000,    1.000]]\n```\n\n---\n\n(vectors-exercises)=\n\n## Exercises\n\n1. Three points have the coordinates $A = (5, 1, 3)$, $B = (10, 7, 4)$ and $C = (0, 5, -3)$. Use pen and paper to calculate the following:\n\n    (a) The vector $\\mathbf{p}$ that points from $A$ to $B$;<br>\n    (b) The vector $\\mathbf{q}$ that points from $B$ to $C$;<br>\n    (c) The vector $\\mathbf{r}$ that points from $C$ to $A$;<br>\n    (d) The length of the vector $\\mathbf{p}$;<br>\n    (e) A unit vector that points in the direction of the vector $\\mathbf{q}$;<br>\n    (f) The dot product $\\mathbf{p} \\cdot \\mathbf{q}$;<br>\n    (g) The cross product $\\mathbf{q} \\times \\mathbf{r}$.\n\n2. Repeat exercise 1 using C++ and the glm library.\n\n3. The three matrices $A$, $B$ and $C$ are defined as\n\n$$ \\begin{align*}\n    A &= \\begin{pmatrix} -1 & 3 \\\\ 2 & -5 \\end{pmatrix}, &\n    B &= \\begin{pmatrix} 0 & 2 \\\\ 7 & 1 \\end{pmatrix}, &\n    C &= \\begin{pmatrix} 3 & 2 \\\\ -3 & -4 \\end{pmatrix}.\n\\end{align*} $$\n\n&emsp;&emsp; Use C++ code to output the following:\n\n&emsp;&emsp; (a) $AB$;<br>\n&emsp;&emsp; (b) $ABC$;<br>\n&emsp;&emsp; (c) $CBA$;<br>\n&emsp;&emsp; (d) $A^\\mathsf{T}B$;<br>\n&emsp;&emsp; (e) $A^{-1}$.\n\n\n````{dropdown} Solutions\n1 (a) &emsp; $\\mathbf{p} = (5, 6, 1)$\n\n1 (b) &emsp; $\\mathbf{q} = (-10, -2, -7)$\n\n1 (c) &emsp; $\\mathbf{r} = (5, -4, 6)$\n\n1 (d) &emsp; $\\|\\mathbf{p}\\| = \\sqrt{62} \\approx = 7.87$\n\n1 (e) &emsp; $\\hat{\\mathbf{q}} = \\left(\\dfrac{-10}{\\sqrt{153}}, \\dfrac{-2}{\\sqrt{153}}, \\dfrac{-7}{\\sqrt{153}} \\right) \\approx (-0.81, -0.16, -0.57)$\n\n1 (f) &emsp; $\\mathbf{p} \\cdot \\mathbf{q} = -69$\n\n1 (g) &emsp; $\\mathbf{q} \\times \\mathbf{r} = (-40, 25, 50)$\n\n3 (a) &emsp; $AB = \\begin{pmatrix}21 & 1 \\\\ -35 & -1 \\end{pmatrix}$\n\n3 (b) &emsp; $ABC = \\begin{pmatrix}    60  &  38 \\\\\n  -102 &  -66 \\end{pmatrix}$\n\n3 (c) &emsp; $CBA = \\begin{pmatrix} 2 & 2 \\\\ 8 & -34 \\end{pmatrix}$\n\n3 (d) &emsp; $A^\\mathsf{T}B = \\begin{pmatrix} 14 & 0 \\\\ -35 & 1 \\end{pmatrix}$\n\n3 (e) &emsp; $A^{-1} = \\begin{pmatrix} 5 & 3 \\\\ 2 & 1 \\end{pmatrix}$\n\n```` ","key":"R4wEx05jCe"}],"key":"IBaQyTBmnI"}],"key":"xGzi7TmrlY"},"references":{"cite":{"order":[],"data":{}}}}