<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Dr Jon Shiach">
  <title>Vectors and Matrices</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      overflow: visible;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #cccccc; background-color: #303030; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ffcfaf; } /* Alert */
    code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #dca3a3; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #f0dfaf; } /* ControlFlow */
    code span.ch { color: #dca3a3; } /* Char */
    code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
    code span.co { color: #7f9f7f; } /* Comment */
    code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
    code span.do { color: #7f9f7f; } /* Documentation */
    code span.dt { color: #dfdfbf; } /* DataType */
    code span.dv { color: #dcdccc; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #efef8f; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
    code span.kw { color: #f0dfaf; } /* Keyword */
    code span.op { color: #f0efd0; } /* Operator */
    code span.ot { color: #efef8f; } /* Other */
    code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #dca3a3; } /* SpecialChar */
    code span.ss { color: #cc9393; } /* SpecialString */
    code span.st { color: #cc9393; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #cc9393; } /* VerbatimString */
    code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/simple.css" id="theme">
  <style>
  .reveal .slides {
      font-size: 0.6em;
      margin: 0;
  }

  .reveal p { text-align: left; }
      .reveal h6 {
          text-transform: none;
          font-weight: 400;
  }

  .reveal h1 {
      text-transform: none;
      font-size: 50px;
  }

  .reveal h2 {
      text-transform: none;
      font-size: 40px;
  }

  .reveal ul {
      display: block;
  }

  .reveal ol {
      display: block;
  }

  </style>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Vectors and Matrices</h1>
  <p class="subtitle">6G5Z0025 Computer Graphics</p>
  <p class="author">Dr Jon Shiach</p>
  <p class="institute">Department of Computing and Mathematics</p>
  <p class="date">Week 4</p>
</section>

<section id="vectors" class="slide level2">
<h2>Vectors</h2>
<p>A vector in is an object with length and direction</p>
<p>Vectors are written using boldface characters, e.g., <span
class="math inline">\(\mathbf{a}\)</span>, or underlined when
handwritten, e.g., <span
class="math inline">\(\underline{a}\)</span></p>
<p>In 3D space a vector is defined as a 3-tuple</p>
<p><span class="math display">\[\begin{align*} \mathbf{a} = (a_x, a_y,
a_z) \end{align*} \]</span></p>
<p>where <span class="math inline">\(a_x,a_y,a_z\)</span> are the signed
distances along the <span class="math inline">\(x,y,z\)</span> axes</p>
<center>
<!-- <img src="https://raw.githubusercontent.com/jonshiach/graphics-book/refs/heads/gh-pages/_images/04_Vector.svg" width="600"/> -->
<img src="https://raw.githubusercontent.com/jonshiach/graphics-book/refs/heads/gh-pages/_images/04_Vector.svg" width="600"/>
</center>
</section>
<section id="the-glm-library" class="slide level2">
<h2>The GLM Library</h2>
<p>The <a href="https://github.com/g-truc/glm" target="_blank">glm</a>
library is a popular C++ mathematics library that is designed for use
with OpenGL</p>
<p>3-element vectors are declared using the <code>glm::vec3</code>
declaration</p>
<p>For example, to declare the vectors <span
class="math inline">\(\mathbf{a} = (3, 0, 4)\)</span> and <span
class="math inline">\(\mathbf{b} = (1, 2, 3)\)</span></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Defining vectors</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>vec3 a <span class="op">=</span> glm<span class="op">::</span>vec3<span class="op">(</span><span class="fl">3.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">4.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>vec3 b<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>b<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">,</span> b<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">2.0</span><span class="bu">f</span><span class="op">,</span> b<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="fl">3.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Defining vectors:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;a = &quot;</span> <span class="op">&lt;&lt;</span> a <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;b = &quot;</span> <span class="op">&lt;&lt;</span> b <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>Output</p>
<pre class="text"><code>Defining vectors:
a = [    3.000,    0.000,    4.000]
b = [    1.000,    2.000,    3.000]</code></pre>
</section>
<section id="arithmetic-operations-on-vectors" class="slide level2">
<h2>Arithmetic Operations on Vectors</h2>
<p>Given two matrices <span class="math inline">\(\mathbf{a}\)</span>
and <span class="math inline">\(\mathbf{b}\)</span> and the scalar <span
class="math inline">\(k\)</span> (a single number) the following
arithmetic operations are defined</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operation</th>
<th style="text-align: center;">Notation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">addition</td>
<td style="text-align: center;"><span class="math inline">\(\mathbf{a} +
\mathbf{b}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">subtraction</td>
<td style="text-align: center;"><span class="math inline">\(\mathbf{a} -
\mathbf{b}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">scalar multiplication</td>
<td style="text-align: center;"><span class="math inline">\(k
\mathbf{a}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">scalar division</td>
<td style="text-align: center;"><span
class="math inline">\(\dfrac{\mathbf{a}}{k}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">dot product</td>
<td style="text-align: center;"><span class="math inline">\(\mathbf{a}
\cdot \mathbf{b}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">cross product</td>
<td style="text-align: center;"><span class="math inline">\(\mathbf{a}
\times \mathbf{b}\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="vector-addition-and-subtraction" class="slide level2">
<h2>Vector addition and subtraction</h2>
<p>Vector addition and subtraction of two vectors <span
class="math inline">\(\mathbf{a} = (a_x, a_y, a_z)\)</span> and <span
class="math inline">\(\mathbf{b} = (b_x, b_y, b_z)\)</span> is defined
by</p>
<p><span class="math display">\[ \begin{align*}
    \mathbf{a} + \mathbf{b} &amp;= (a_x + b_x, a_y + b_y, a_z + b_z), \\
    \mathbf{a} - \mathbf{b} &amp;= (a_x - b_x, a_y - b_y, a_z - b_z), \\
\end{align*} \]</span></p>
<div class="columns">
<div class="column" style="width:40%;">
Addition
<center>
<img src="https://raw.githubusercontent.com/jonshiach/graphics-book/refs/heads/gh-pages/_images/04_Vector_addition.svg" width="300"/>
</center>
</div><div class="column" style="width:60%;">
Subtraction
<center>
<img src="https://raw.githubusercontent.com/jonshiach/graphics-book/refs/heads/gh-pages/_images/04_Vector_subtraction.svg" width="400"/>
</center>
</div>
</div>
</section>
<section id="example" class="slide level2">
<h2>Example</h2>
<p>Given the vectors <span class="math inline">\(\mathbf{a} =
(3,0,4)\)</span> and <span class="math inline">\(\mathbf{b} = (1, 2,
3)\)</span> calculate:</p>
<ol type="1">
<li><p>  <span class="math inline">\(\mathbf{a} +
\mathbf{b}\)</span></p></li>
<li><p>  <span class="math inline">\(\mathbf{a} -
\mathbf{b}\)</span></p></li>
</ol>
<div class="fragment">
<p><strong>Solution</strong></p>
<ol type="1">
<li></li>
</ol>
<p><span class="math display">\[\mathbf{a} + \mathbf{b} = (3 + 1, 0 + 2,
4 + 3) = (4, 2, 7)\]</span></p>
</div>
<div class="fragment">
<ol start="2" type="1">
<li></li>
</ol>
<p><span class="math display">\[\mathbf{a} - \mathbf{b} = (3 - 1, 0 - 2,
4 - 3) = (2, -2, 1)\]</span></p>
</div>
</section>
<section id="c-vector-addition-and-subtraction" class="slide level2">
<h2>C++: vector addition and subtraction</h2>
<p>The addition and subtraction of glm vectors is done using the
standard <code>+</code> and <code>-</code> operators</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Arithmetic operations on vectors</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">Arithmetic operations on vectors:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;a + b = &quot;</span> <span class="op">&lt;&lt;</span> a <span class="op">+</span> b <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;a - b = &quot;</span> <span class="op">&lt;&lt;</span> a <span class="op">-</span> b <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>Output</p>
<pre class="text"><code>Arithmetic operations on vectors:
a + b = [    4.000,    2.000,    7.000]
a - b = [    2.000,   -2.000,    1.000]</code></pre>
</section>
<section id="scalar-multiplication" class="slide level2">
<h2>Scalar multiplication</h2>
<p>The multiplication of a vector <span class="math inline">\(\mathbf{a}
= (a_x, a_y, a_z)\)</span> by a scalar <span
class="math inline">\(k\)</span> is defined by</p>
<p><span class="math display">\[ \begin{align*}
    k \mathbf{a} &amp;= (ka_x, ka_y, ka_z)
\end{align*} \]</span></p>
<p>Multiplying or dividing a vector by a positive scalar has the effect
of scaling the length of the vector</p>
<center>
<img src="https://raw.githubusercontent.com/jonshiach/graphics-book/refs/heads/main/_images/04_Vector_multiplication.svg" width="500"/>
</center>
</section>
<section id="example-1" class="slide level2">
<h2>Example</h2>
<p>Given the vectors <span class="math inline">\(\mathbf{a} =
(3,0,4)\)</span> and <span class="math inline">\(\mathbf{b} = (1, 2,
3)\)</span> calculate:</p>
<ol type="1">
<li><p>  <span class="math inline">\(2\mathbf{a}\)</span></p></li>
<li><p>  <span
class="math inline">\(\dfrac{\mathbf{b}}{3}\)</span></p></li>
</ol>
<div class="fragment">
<p><strong>Solution</strong></p>
<ol type="1">
<li></li>
</ol>
<p><span class="math display">\[2\mathbf{a} = 2(3, 0, 4) = (6, 0, 8)
\]</span></p>
</div>
<div class="fragment">
<ol start="2" type="1">
<li></li>
</ol>
<p><span class="math display">\[\dfrac{\mathbf{b}}{3} = \frac{1}{3}(1,
2, 3) = \left( \frac{1}{3}, \frac{2}{3}, \frac{3}{3} \right) \approx
(0.333, 0.667, 1)\]</span></p>
</div>
</section>
<section id="c-scalar-multiplication" class="slide level2">
<h2>C++: scalar multiplication</h2>
<p>Scalar multiplication and division is done using the standard
<code>*</code> and <code>/</code> operators</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;2a    = &quot;</span> <span class="op">&lt;&lt;</span> <span class="fl">2.0</span><span class="bu">f</span> <span class="op">*</span> a <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;b / 3 = &quot;</span> <span class="op">&lt;&lt;</span> b <span class="op">/</span> <span class="fl">3.0</span><span class="bu">f</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>Output</p>
<pre class="text"><code>2a    = [    6.000,    0.000,    8.000]
b / 3 = [    0.333,    0.667,    1.000]</code></pre>
</section>
<section id="vector-magnitude" class="slide level2">
<h2>Vector Magnitude</h2>
<p>The <strong>magnitude</strong> of a vector <span
class="math inline">\(\mathbf{a} = (a_x, a_y, a_z)\)</span> is denoted
by <span class="math inline">\(\|\mathbf{a}\|\)</span> is the length
from the tail of the vector to the head</p>
<center>
<img src="https://raw.githubusercontent.com/jonshiach/graphics-book/refs/heads/gh-pages/_images/04_Vector_magnitude.svg" width="300" text-align="center"/>
</center>
<p>The magnitude of a vector in 3D is calculated using an extension of
Pythagoras’ theorem</p>
<p><span class="math display">\[ \|\mathbf{a}\| = \sqrt{a_x^2 + a_y^2 +
a_z^2}. \]</span></p>
</section>
<section id="example-2" class="slide level2">
<h2>Example</h2>
<p>Calculate the magnitude of the vectors</p>
<ol type="1">
<li><p>  <span class="math inline">\(\mathbf{a} =
(3,0,4)\)</span></p></li>
<li><p><span class="math inline">\(\mathbf{b} = (1, 2,
3)\)</span></p></li>
</ol>
<div class="fragment">
<p><strong>Solution</strong></p>
<ol type="1">
<li></li>
</ol>
<p><span class="math display">\[\| \mathbf{a} \| = \sqrt{3^2 + 0^2 +
4^2} = \sqrt{9 + 0 + 16} = \sqrt{25} = 5\]</span></p>
</div>
<div class="fragment">
<ol start="2" type="1">
<li></li>
</ol>
<p><span class="math display">\[\| \mathbf{b} \| = \sqrt{1^2 + 2^2 +
3^2} = \sqrt{1 + 4 + 9} = \sqrt{14} \approx 3.742\]</span></p>
</div>
</section>
<section id="c-vector-magnitude" class="slide level2">
<h2>C++: vector magnitude</h2>
<p>The glm function <code>glm::length()</code> returns the magnitude (or
length) of a glm vector</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Vector length</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">Vector length:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;length(a) = </span><span class="sc">%0.3f\n</span><span class="st">&quot;</span><span class="op">,</span> glm<span class="op">::</span>length<span class="op">(</span>a<span class="op">));</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;length(b) = </span><span class="sc">%0.3f\n</span><span class="st">&quot;</span><span class="op">,</span> glm<span class="op">::</span>length<span class="op">(</span>b<span class="op">));</span></span></code></pre></div>
<p>Output</p>
<pre><code>Vector length:
length(a) = 5.000
length(b) = 3.742</code></pre>
</section>
<section id="unit-vectors" class="slide level2">
<h2>Unit Vectors</h2>
<p>A <strong>unit vector</strong> is a vector that has a length of 1</p>
<p>We can <strong>normalise</strong> a vector by dividing by its
magnitude to give a unit vector</p>
<p><span class="math display">\[ \hat{\mathbf{a}} =
\frac{\mathbf{a}}{\|\mathbf{a}\|} \]</span></p>
<p>Note that a unit vector is denoted by <span
class="math inline">\(\hat{\mathbf{a}}\)</span> and is said as
<em>“a-hat”</em></p>
</section>
<section id="example-3" class="slide level2">
<h2>Example</h2>
<p>Calculate a unit vector that points in the same direction as <span
class="math inline">\(\mathbf{a} = (3, 0, 4)\)</span></p>
<div class="fragment">
<p><strong>Solution</strong></p>
<p>We know that <span class="math inline">\(\| \mathbf{a} \| =
5\)</span> so</p>
<p><span class="math display">\[ \hat{\mathbf{a}} = \dfrac{(3, 0, 4)}{5}
= \left( \frac{3}{5}, 0, \frac{4}{5} \right) = (0.6, 0,
0.8)\]</span></p>
</div>
<div class="fragment">
<p>Checking that <span class="math inline">\(\hat{\mathbf{a}}\)</span>
is a unit vector</p>
<p><span class="math display">\[\| \hat{\mathbf{a}} \| =
\sqrt{\frac{9}{25} + \frac{16}{25}} = \sqrt{\frac{25}{25}} =
1\]</span></p>
</div>
</section>
<section id="c-normalising-a-vector" class="slide level2">
<h2>C++: normalising a vector</h2>
<p>The glm function <code>glm::normalize()</code> normalises a
vector</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Normalising vectors</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>vec3 aHat <span class="op">=</span> glm<span class="op">::</span>normalize<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;aHat = &quot;</span> <span class="op">&lt;&lt;</span> aHat <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;length(aHat) = </span><span class="sc">%0.3f\n</span><span class="st">&quot;</span><span class="op">,</span> glm<span class="op">::</span>length<span class="op">(</span>aHat<span class="op">));</span></span></code></pre></div>
<p>Output</p>
<pre><code>aHat = [    0.600,    0.000,    0.800]
length(aHat) = 1.000</code></pre>
</section>
<section id="multiplying-vectors" class="slide level2">
<h2>Multiplying vectors</h2>
<p>Mathematically speaking the multiplication of two vectors is not
defined</p>
<p>In computing it is useful to be able to multiply the individual
elements of vectors which is done using the <code>*</code> operator</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;a * b = &quot;</span> <span class="op">&lt;&lt;</span> a <span class="op">*</span> b <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>Output</p>
<pre class="text"><code>a * b = [    3.000,    0.000,   12.000]</code></pre>
<p>Which is equivalent to</p>
<p><span class="math display">\[(3, 0, 4) * (1, 2, 3) = (3 \times 1, 0
\times 2, 4 \times 3) = (3, 0, 12)\]</span></p>
</section>
<section id="the-dot-product" class="slide level2">
<h2>The dot product</h2>
<p>The dot product between two vectors <span
class="math inline">\(\mathbf{a} = (a_x, a_y, a_z)\)</span> and <span
class="math inline">\(\mathbf{b} = (b_x, b_y, b_z)\)</span> is denoted
by <span class="math inline">\(\mathbf{a} \cdot \mathbf{b}\)</span> and
returns a <strong>scalar</strong></p>
<p>The dot product is calculated using</p>
<p><span class="math display">\[ \mathbf{a} \cdot \mathbf{b} = a_xb_x +
a_yb_y + a_zb_z. \]</span></p>
</section>
<section id="dot-product-geometric-interpretation" class="slide level2">
<h2>Dot product: geometric interpretation</h2>
<p>The dot product is related to the angle <span
class="math inline">\(\theta\)</span> between the two vectors by</p>
<p><span class="math display">\[ \mathbf{a} \cdot \mathbf{b} =
\|\mathbf{a}\| \|\mathbf{b}\| \cos(\theta). \]</span></p>
<center>
<img src="https://raw.githubusercontent.com/jonshiach/graphics-book/refs/heads/gh-pages/_images/04_Dot_product.svg" width="200">
</center>
<p>A useful result for graphics is that if <span
class="math inline">\(\theta=90^\circ\)</span> then <span
class="math inline">\(\cos(\theta) = 0\)</span> and</p>
<p><span class="math display">\[ \mathbf{a} \cdot \mathbf{b} =
0\]</span></p>
</section>
<section id="example-4" class="slide level2">
<h2>Example</h2>
<p>Given the two matrices <span class="math inline">\(\mathbf{a} =
(3,0,4)\)</span> and <span class="math inline">\(\mathbf{b} = (1, 2,
3)\)</span>, calculate <span class="math inline">\(\mathbf{a} \cdot
\mathbf{b}\)</span></p>
<div class="fragment">
<p><strong>Solution</strong></p>
<p><span class="math display">\[\begin{align*}
    \mathbf{a} \cdot \mathbf{b} &amp;= (3, 0, 4) \cdot (1, 2, 3) \\
    &amp;= 3 \times 1 + 2 \times 0 + 3 \times 4 \\
    &amp;= 3 + 0 + 12\\
    &amp; = 15
\end{align*} \]</span></p>
</div>
</section>
<section id="c-the-dot-product" class="slide level2">
<h2>C++: the dot product</h2>
<p>The glm function <code>glm::dot()</code> returns the dot product of
two vectors</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Dot and Cross products</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">Dot and cross products:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;a . b = </span><span class="sc">%0.3f\n</span><span class="st">&quot;</span><span class="op">,</span> glm<span class="op">::</span>dot<span class="op">(</span>a<span class="op">,</span> b<span class="op">));</span></span></code></pre></div>
<p>Output</p>
<pre class="text"><code>Dot and cross products:
a . b = 15.000</code></pre>
</section>
<section id="the-cross-product" class="slide level2">
<h2>The Cross Product</h2>
<p>The cross product between two vectors <span
class="math inline">\(\mathbf{a} = (a_x, a_y, a_z)\)</span> and <span
class="math inline">\(\mathbf{b} = (b_x, b_y, b_z)\)</span> is denoted
by <span class="math inline">\(\mathbf{a} \times \mathbf{b}\)</span> and
returns a <strong>vector</strong></p>
<p>The cross product is calculated using</p>
<p><span class="math display">\[ \mathbf{a} \times \mathbf{b} = (a_yb_z
- a_zb_y, a_zb_x - a_xb_z, a_xb_y - a_yb_x). \]</span></p>
<p>The <span class="math inline">\(\mathbf{a} \times \mathbf{b}\)</span>
is perpendicular to both <span class="math inline">\(\mathbf{a}\)</span>
and <span class="math inline">\(\mathbf{b}\)</span></p>
<center>
<img src="https://raw.githubusercontent.com/jonshiach/graphics-book/refs/heads/gh-pages/_images/04_cross_product.svg" width=300>
</center>
</section>
<section id="example-5" class="slide level2">
<h2>Example</h2>
<p>Given the vectors <span class="math inline">\(\mathbf{a} =
(3,0,4)\)</span> and <span class="math inline">\(\mathbf{b} = (1, 2,
3)\)</span>, calculate <span class="math inline">\(\mathbf{a} \times
\mathbf{b}\)</span></p>
<div class="fragment">
<p><strong>Solution</strong></p>
<p>Using <span class="math inline">\(\mathbf{a} \times \mathbf{b} =
(a_yb_z - a_zb_y, a_zb_x - a_xb_z, a_xb_y - a_yb_x).\)</span></p>
<p><span class="math display">\[ \begin{align*}
    \mathbf{a} \times \mathbf{b} &amp;= (3, 0, 4) \times (1, 2, 3) \\
    &amp;= (0 \times 3 - 4 \times 2, 4 \times 1 - 3 \times 3, 3 \times 2
- 0 \times 3) \\
    &amp;= (-8, -5, 6).
\end{align*} \]</span></p>
</div>
<div class="fragment">
<p>We can show that <span class="math inline">\(\mathbf{a} \times
\mathbf{b}\)</span> is perpendicular to both <span
class="math inline">\(\mathbf{a}\)</span> and <span
class="math inline">\(\mathbf{b}\)</span></p>
<p><span class="math display">\[ \begin{align*}
    \mathbf{a} \cdot (\mathbf{a} \times \mathbf{b}) &amp;= (3, 0, 4)
\cdot (-8, -5, 6) = -24 + 0 + 24 = 0, \\
    \mathbf{b} \cdot (\mathbf{a} \times \mathbf{b}) &amp;= (1, 2, 3)
\cdot (-8, -5, 6) = - 8 - 10 + 18 = 0.
\end{align*} \]</span></p>
</div>
</section>
<section id="c-the-cross-product" class="slide level2">
<h2>C++: the cross product</h2>
<p>The glm function <code>glm::cross()</code> calculates the cross
product of two vectors</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;a x b = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>cross<span class="op">(</span>a<span class="op">,</span> b<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;a . (a x b) = </span><span class="sc">%0.3f\n</span><span class="st">&quot;</span><span class="op">,</span> glm<span class="op">::</span>dot<span class="op">(</span>a<span class="op">,</span> glm<span class="op">::</span>cross<span class="op">(</span>a<span class="op">,</span> b<span class="op">)));</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;b . (a x b) = </span><span class="sc">%0.3f\n</span><span class="st">&quot;</span><span class="op">,</span> glm<span class="op">::</span>dot<span class="op">(</span>b<span class="op">,</span> glm<span class="op">::</span>cross<span class="op">(</span>a<span class="op">,</span> b<span class="op">)));</span></span></code></pre></div>
<p>Output</p>
<pre class="text"><code>a x b = [   -8.000,   -5.000,    6.000]
a . (a x b) = 0.000
b . (a x b) = 0.000</code></pre>
</section>
<section id="matrices" class="slide level2">
<h2>Matrices</h2>
<p>A matrix is a rectangular array of numbers.</p>
<p><span class="math display">\[ \begin{align*}
    A =
    \begin{pmatrix}
        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
        a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
    \end{pmatrix}
\end{align*} \]</span></p>
<p>The elements of a matrix are indexed such that <span
class="math inline">\(a_{ij}\)</span> is the element in row <span
class="math inline">\(i\)</span> and column <span
class="math inline">\(j\)</span> of the matrix <span
class="math inline">\(A\)</span></p>
<p>We refer to the size of a matrix by <span
class="math inline">\(number\, of\, rows \times number\, of\,
columns\)</span>, here <span class="math inline">\(A\)</span> is an
<span class="math inline">\(m \times n\)</span> matrix</p>
</section>
<section id="c-matrices" class="slide level2">
<h2>C++: matrices</h2>
<p><span class="math inline">\(2\times 2\)</span> glm matrices are
declared using <code>glm::mat2()</code>, so to declare the matrices</p>
<p><span class="math display">\[ \begin{align*}
    A &amp;= \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix}, &amp;
    B &amp;= \begin{pmatrix} 5 &amp; 6 \\ 7 &amp; 8 \end{pmatrix}.
\end{align*} \]</span></p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Defining matrices</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>mat2 A<span class="op">,</span> B<span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>A<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">,</span> A<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">2.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>A<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">3.0</span><span class="bu">f</span><span class="op">,</span> A<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">4.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> glm<span class="op">::</span>mat2<span class="op">(</span><span class="fl">5.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">6.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">7.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">8.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">Defining matrices:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;A = &quot;</span> <span class="op">&lt;&lt;</span> A <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;B = &quot;</span> <span class="op">&lt;&lt;</span> B <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>Output</p>
<pre class="text"><code>Defining matrices:
A = 
[[    1.000,    3.000]
 [    2.000,    4.000]]

B = 
[[    5.000,    7.000]
 [    6.000,    8.000]]</code></pre>
<div class="fragment">
<p>But these aren’t right</p>
</div>
</section>
<section id="column-major" class="slide level2">
<h2>Column-major</h2>
<p>Linear memory is a contiguous block of addresses that can be
sequentially accessed</p>
<p>Since matrices are 2D we have a choice whether to store the elements
in the rows or columns in adjacent locations</p>
<p>Consider the <span class="math inline">\(4 \times 4\)</span>
matrix</p>
<p><span class="math display">\[ \begin{align*}
    \begin{pmatrix}
        a &amp; b &amp; c &amp; d \\
        e &amp; f &amp; g &amp; h \\
        i &amp; j &amp; k &amp; l \\
        m &amp; n &amp; o &amp; p
    \end{pmatrix}
\end{align*} \]</span></p>
<p><strong>Column-major</strong> order is where we store the elements
column-by-column, i.e.,</p>
<center>
<img src="https://raw.githubusercontent.com/jonshiach/graphics-book/refs/heads/gh-pages/_images/04_Column_major.svg" width="800">
</center>
</section>
<section id="row-major-order" class="slide level2">
<h2>Row-major order</h2>
<p>Alternatively, using <strong>row-major</strong> order we store the
elements row-by-row, so the matrix</p>
<p><span class="math display">\[ \begin{align*}
    \begin{pmatrix}
        a &amp; b &amp; c &amp; d \\
        e &amp; f &amp; g &amp; h \\
        i &amp; j &amp; k &amp; l \\
        m &amp; n &amp; o &amp; p
    \end{pmatrix}
\end{align*} \]</span></p>
<p>will be stored as</p>
<center>
<img src="https://raw.githubusercontent.com/jonshiach/graphics-book/refs/heads/gh-pages/_images/04_Row_major.svg" width="800">
</center>
<p>OpenGL uses column-major order so does glm. When we output a glm
matrix it is outputed column-by-column, hence why our matrices didn’t
look right</p>
</section>
<section id="matrix-transpose" class="slide level2">
<h2>Matrix Transpose</h2>
<p>The transpose of a matrix <span class="math inline">\(A\)</span> is
denoted by <span class="math inline">\(A^\mathsf{T}\)</span> and is
defined by swapping the rows and columns of <span
class="math inline">\(A\)</span>.</p>
<p>For example, given the matrix <span
class="math inline">\(A\)</span></p>
<p><span class="math display">\[ \begin{align*}
    A = \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix},
\end{align*} \]</span></p>
<p>then <span class="math inline">\(A^\mathsf{T}\)</span> is</p>
<p><span class="math display">\[ \begin{align*}
    A^\mathsf{T} = \begin{pmatrix} 1 &amp; 3 \\ 2 &amp; 4 \end{pmatrix}
\end{align*} \]</span></p>
</section>
<section id="c-matrix-transpose" class="slide level2">
<h2>C++: matrix transpose</h2>
<p>The glm function <code>glm::transpose()</code> returns that transpose
of a matrix</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;A = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span>A<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;B = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span>B<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>Output</p>
<pre class="text"><code>Defining matrices:
A = 
[[    1.000,    2.000]
 [    3.000,    4.000]]

B = 
[[    5.000,    6.000]
 [    7.000,    8.000]]</code></pre>
</section>
<section id="arithmetic-operations-on-matrices" class="slide level2">
<h2>Arithmetic operations on matrices</h2>
<p>The arithmetic operations on matrices for addition and subtraction of
two matrices and multiplying by a scalar are the same as for vectors</p>
<p>E.g., given the matrices</p>
<p><span class="math display">\[ \begin{align*}
    A &amp;= \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix}, &amp;
    B &amp;= \begin{pmatrix} 5 &amp; 6 \\ 7 &amp; 8 \end{pmatrix}.
\end{align*} \]</span></p>
<p>then</p>
<p><span class="math display">\[ \begin{align*}
    A + B &amp;=
    \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix} +  
    \begin{pmatrix} 5 &amp; 6 \\ 7 &amp; 8 \end{pmatrix} =
    \begin{pmatrix} 1 + 5 &amp; 2 + 6 \\ 3 + 7 &amp; 4 + 8 \end{pmatrix}
    =
    \begin{pmatrix} 6 &amp; 8 \\ 10 &amp; 12 \end{pmatrix}\\
    A - B &amp;=
    \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix} -  
    \begin{pmatrix} 5 &amp; 6 \\ 7 &amp; 8 \end{pmatrix}
    =
    \begin{pmatrix} 1 - 5 &amp; 2 - 6 \\ 3 - 7 &amp; 4 - 8 \end{pmatrix}
=
    \begin{pmatrix} -4 &amp; -4 \\ -4 &amp; -4 \end{pmatrix} \\
    2A &amp;= 2 \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix}
    =
    \begin{pmatrix} 2 &amp; 4 \\ 6 &amp; 8 \end{pmatrix} \\
    \frac{A}{3} &amp;= \frac{1}{3}
    \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix}
    =
    \begin{pmatrix} \frac{1}{3} &amp; \frac{2}{3} \\ 1 &amp; \frac{4}{3}
\end{pmatrix}
    \approx
    \begin{pmatrix} 0.333 &amp; 0.667 \\ 1 &amp; 1.333 \end{pmatrix}
\end{align*} \]</span></p>
</section>
<section id="c-arithmetic-operations-on-matrices" class="slide level2">
<h2>C++: arithmetic operations on matrices</h2>
<p>The addition, subtraction and multiplication and division of a matrix
by a scalar is done using the standard <code>+</code>, <code>-</code>,
<code>*</code> and <code>/</code> operators</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Aritmetic operations on matrices</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">Arithmetic operations on matrices:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;A + B = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span>A <span class="op">+</span> B<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;A - B = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span>A <span class="op">-</span> B<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;2A    = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span><span class="fl">2.0</span><span class="bu">f</span> <span class="op">*</span> A<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;A / 3 = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span>A <span class="op">/</span> <span class="fl">3.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>Output</p>
<pre class="text"><code>Arithmetic operations on matrices:
A + B = 
[[    6.000,    8.000]
 [   10.000,   12.000]]

A - B = 
[[   -4.000,   -4.000]
 [   -4.000,   -4.000]]

2A    = 
[[    2.000,    4.000]
 [    6.000,    8.000]]

A / 3 = 
[[    0.333,    0.667]
 [    1.000,    1.333]]</code></pre>
</section>
<section id="matrix-multiplication" class="slide level2">
<h2>Matrix multiplication</h2>
<p>If <span class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span> are two matrices then the element in
row <span class="math inline">\(i\)</span> and column <span
class="math inline">\(j\)</span> of the matrix <span
class="math inline">\(AB\)</span> is calculated using</p>
<p><span class="math display">\[ [AB]_{ij} = \mathbf{a}_i \cdot
\mathbf{b}_j, \]</span></p>
<p>where <span class="math inline">\(\mathbf{a}_i\)</span> is the vector
formed from row <span class="math inline">\(i\)</span> of <span
class="math inline">\(A\)</span> and <span
class="math inline">\(\mathbf{b}_j\)</span> is the vector formed from
column <span class="math inline">\(j\)</span> of <span
class="math inline">\(B\)</span></p>
<p>For example, given the matrices <span class="math inline">\(A =
\begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix}\)</span> and <span
class="math inline">\(B = \begin{pmatrix} 5 &amp; 6 \\ 7 &amp; 8
\end{pmatrix}\)</span></p>
<p><span class="math display">\[ \begin{align*}
    AB &amp;=
    \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix}
    \begin{pmatrix} 5 &amp; 6 \\ 7 &amp; 8 \end{pmatrix} =
    \begin{pmatrix}
        (1, 2) \cdot (5, 7) &amp; (1,2) \cdot (6, 8) \\
        (3, 4) \cdot (5, 7) &amp; (3, 4) \cdot (6, 8)
    \end{pmatrix} \\
    &amp;=
    \begin{pmatrix} 5 + 14 &amp; 6 + 16 \\ 15 + 28 &amp; 18 + 32
\end{pmatrix} =
    \begin{pmatrix} 19 &amp; 22 \\ 43 &amp; 50 \end{pmatrix}
\end{align*} \]</span></p>
</section>
<section id="non-commutativity-of-matrix-multiplication"
class="slide level2">
<h2>Non-commutativity of matrix multiplication</h2>
<p>Unlike numbers where is doesn’t matter which way round they are when
we multiplied (i.e., <span class="math inline">\(1 \times 2 = 2 \times 1
= 2\)</span>) this is <strong>not</strong> the case with matrices</p>
<p>For example, lets calculate <span
class="math inline">\(BA\)</span></p>
<p><span class="math display">\[ \begin{align*}
    BA &amp;=
    \begin{pmatrix} 5 &amp; 6 \\ 7 &amp; 8 \end{pmatrix}
    \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix} =
    \begin{pmatrix}
        (5, 6) \cdot (1, 3) &amp; (5, 6) \cdot (2, 4) \\
        (7, 8) \cdot (1, 3) &amp; (7, 8) \cdot (2, 4)
    \end{pmatrix} \\
    &amp;=
    \begin{pmatrix} 5 + 18 &amp; 10 + 24 \\ 7 + 24 &amp; 14 + 32
\end{pmatrix} =
    \begin{pmatrix} 23 &amp; 34 \\ 31 &amp; 46 \end{pmatrix}
\end{align*} \]</span></p>
<p>So <span class="math inline">\(AB \neq BA\)</span></p>
</section>
<section id="c-matrix-multiplication" class="slide level2">
<h2>C++: matrix multiplication</h2>
<p>The glm operator <code>*</code> is used to multiply two or more
matrices together.</p>
<p>Since glm uses column-major order to store matrices the order of the
matrices is reversed so to calculate <span
class="math inline">\(AB\)</span> we would use <code>B * A</code></p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;A * B = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span>B <span class="op">*</span> A<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;B * A = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span>A <span class="op">*</span> B<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>Output</p>
<pre class="text"><code>A * B = 
[[   19.000,   22.000]
 [   43.000,   50.000]]

B * A = 
[[   23.000,   34.000]
 [   31.000,   46.000]]</code></pre>
</section>
<section id="the-identity-matrix" class="slide level2">
<h2>The Identity Matrix</h2>
<p>The identity matrix is a special square matrix where all the elements
are zero apart from the elements on the diagonal line from the top-left
element down to the bottom-right element</p>
<p>For example the <span class="math inline">\(4\times 4\)</span>
identity matrix is</p>
<p><span class="math display">\[ I = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]</span></p>
<p>The identity element is similar to the number 1 in that if we
multiply any matrix by an identity matrix the result is unchanged</p>
<p><span class="math display">\[ \begin{align*}
    I_2A = \begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{pmatrix}
    \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix} =
    \begin{pmatrix}
        (1,0) \cdot (1, 3) &amp; (1,0) \cdot (2, 4) \\
        (0,1) \cdot (1,3) &amp; (0,1) \cdot (2,4)
    \end{pmatrix} =
    \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix}
\end{align*} \]</span></p>
</section>
<section id="c-the-identity-matrix" class="slide level2">
<h2>C++: the identity matrix</h2>
<p>The default constructor for a glm matrix object declares the matrix
as an identity matrix</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The identity matrix</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">The identity matrix:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>mat2 I<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;I = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span>I<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>Output</p>
<pre class="text"><code>The identity matrix:
I = 
[[    1.000,    0.000,    0.000,    0.000]
 [    0.000,    1.000,    0.000,    0.000]
 [    0.000,    0.000,    1.000,    0.000]
 [    0.000,    0.000,    0.000,    1.000]]</code></pre>
</section>
<section id="inverse-matrix" class="slide level2">
<h2>Inverse matrix</h2>
<p>The inverse of a matrix <span class="math inline">\(A\)</span> is
denoted by <span class="math inline">\(A^{-1}\)</span> and satisfies
<span class="math inline">\(A^{-1} A = AA^{-1} = I\)</span> where <span
class="math inline">\(I\)</span> is the identity matrix</p>
<p>The inverse of the matrix <span class="math inline">\(A =
\begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix}\)</span> is</p>
<p><span class="math display">\[ A^{-1} = \begin{pmatrix} -2 &amp; 1 \\
\frac{3}{2} &amp; -\frac{1}{2} \end{pmatrix}. \]</span></p>
<p>We can check whether this is the inverse of <span
class="math inline">\(A\)</span> by calculating <span
class="math inline">\(A^{-1}A\)</span> (or <span class="math inline">\(A
A^{-1}\)</span>)</p>
<p><span class="math display">\[ \begin{align*}
    A^{-1} A &amp;=
    \begin{pmatrix} -2 &amp; 1 \\ \frac{3}{2} &amp; -\frac{1}{2}
\end{pmatrix}
    \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix}
    =
    \begin{pmatrix} (-2, 1) \cdot (1, 3) &amp; (-2, 1) \cdot (2, 4) \\
(\frac{3}{2}, -\frac{1}{2}) \cdot (1, 3) &amp; (\frac{3}{2},
-\frac{1}{2}) \cdot (2, 4) \end{pmatrix}
    \\
    &amp;=
    \begin{pmatrix}
        -2 + 3 &amp; -4 + 4 \\
        \frac{3}{2} - \frac{3}{2} &amp; 3 - 2
    \end{pmatrix}
    = \begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{pmatrix} = I
\end{align*} \]</span></p>
</section>
<section id="c-inverse-matrix" class="slide level2">
<h2>C++: inverse matrix</h2>
<p>The glm function <code>glm::inverse()</code> returns the inverse of a
matrix</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Inverse matrices</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">Inverse matrices:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>mat2 invA <span class="op">=</span> glm<span class="op">::</span>inverse<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>mat2 invB <span class="op">=</span> glm<span class="op">::</span>inverse<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;invA = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span>invA<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;invB = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span>invB<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;invA * A = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span>A <span class="op">*</span> invA<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;invB * B = &quot;</span> <span class="op">&lt;&lt;</span> glm<span class="op">::</span>transpose<span class="op">(</span>B <span class="op">*</span> invB<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>Output</p>
<pre class="text"><code>Inverse matrices:
invA = 
[[   -2.000,    1.000]
 [    1.500,   -0.500]]

invB = 
[[   -4.000,    3.000]
 [    3.500,   -2.500]]

invA * A = 
[[    1.000,    0.000]
 [    0.000,    1.000]]

invB * B = 
[[    1.000,    0.000]
 [    0.000,    1.000]]</code></pre>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/math/math.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: false,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: false,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [
          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>
