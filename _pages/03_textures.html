

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>3. Textures &#8212; Computer Graphics</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"model": ["M\\!odel"], "view": ["V\\!iew"], "mvp": ["MV\\!P"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/03_textures';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4. Vectors and Matrices" href="04_vectors_and_matrices.html" />
    <link rel="prev" title="2. Basic Shapes in OpenGL" href="02_basic_shapes_in_OpenGL.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Computer Graphics
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_intro_to_cpp.html">1. Introduction to C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_basic_shapes_in_OpenGL.html">2. Basic Shapes in OpenGL</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">3. Textures</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_vectors_and_matrices.html">4. Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_transformations.html">5. Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_3D_worlds.html">6. 3D Worlds</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_Moving_the_camera.html">7. Moving the camera</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_Lighting.html">8. Lighting</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_Normal_mapping.html">9. Normal Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_Quaternions.html">10. Quaternions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="A_Complex_numbers_and_quaternions.html">A. Complex Numbers and Quaternions</a></li>
<li class="toctree-l1"><a class="reference internal" href="B_Code.html">B. Code and Assets</a></li>
<li class="toctree-l1"><a class="reference internal" href="C_Glossary.html">C Glossary</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs/issues/new?title=Issue%20on%20page%20%2F_pages/03_textures.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/_pages/03_textures.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Textures</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-triangle">3.1. Texture triangle</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-texture">3.1.1. Creating a texture</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-co-ordinates">3.1.2. Texture co-ordinates</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shaders">3.1.3. Shaders</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#vertex-shader">3.1.3.1. Vertex shader</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#fragment-shader">3.1.3.2. Fragment shader</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-rectangle">3.2. Texture rectangle</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#element-buffer-objects-ebo">3.2.1. Element Buffer Objects (EBO)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-wrapping-and-filtering">3.3. Texture wrapping and filtering</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-wrapping">3.3.1. Texture wrapping</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-filtering">3.3.2. Texture filtering</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#nearest-neighbour-interpolation">3.3.2.1. Nearest neighbour interpolation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#bilinear-interpolation">3.3.2.2. Bilinear interpolation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mipmaps">3.4. Mipmaps</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multiple-textures">3.5. Multiple textures</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#uniforms">3.5.1. Uniforms</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-units">3.5.2. Texture units</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">3.5.3. Fragment shader</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">3.6. Exercises</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="textures">
<span id="textures-section"></span><h1><span class="section-number">3. </span>Textures<a class="headerlink" href="#textures" title="Permalink to this heading">#</a></h1>
<p>Texture mapping is a technique for applying a 2D image known as a <strong>texture</strong> onto a 3D surface. Applying a texture adds detail and complexity to the appearance of 3D objects without the need for modelling intricate geometry.</p>
<figure class="align-default" id="id2">
<a class="reference internal image-reference" href="../_images/03_texture_mapping.svg"><img alt="../_images/03_texture_mapping.svg" src="../_images/03_texture_mapping.svg" width="600" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.1 </span><span class="caption-text">Mapping a texture to a polygon.</span><a class="headerlink" href="#id2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The texture is a 2D image where each pixel within the texture, known as a <strong>textel</strong>, is referenced using the <strong>texture coordinates</strong> given as <span class="math notranslate nohighlight">\((u,v)\)</span> where <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> are in the range 0 to 1, i.e., <span class="math notranslate nohighlight">\((0,0)\)</span> corresponds to the textel in the bottom-left corner and <span class="math notranslate nohighlight">\((1,1)\)</span> corresponds to the textel in the top-right corner. When a fragment is created by the shader the corresponding texture co-ordinates are calculated and the sample colour of the textel is used for the fragment. Fortunately we do not need to write a texture mapper functions since these are in OpenGL.</p>
<hr class="docutils" />
<section id="texture-triangle">
<h2><span class="section-number">3.1. </span>Texture triangle<a class="headerlink" href="#texture-triangle" title="Permalink to this heading">#</a></h2>
<p>Compile and run the <strong>Lab03_Textures</strong> project and you should be presented with the image of the red triangle from <a class="reference internal" href="02_basic_shapes_in_OpenGL.html#basic-shapes-section"><span class="std std-ref">2. Basic Shapes in OpenGL</span></a> shown in <a class="reference internal" href="#red-triangle-figure2"><span class="std std-numref">Fig. 3.2</span></a></p>
<figure class="align-default" id="red-triangle-figure2">
<a class="reference internal image-reference" href="../_images/03_red_triangle.png"><img alt="../_images/03_red_triangle.png" src="../_images/03_red_triangle.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.2 </span><span class="caption-text">The red triangle from <a class="reference internal" href="02_basic_shapes_in_OpenGL.html#basic-shapes-section"><span class="std std-ref">2. Basic Shapes in OpenGL</span></a>.</span><a class="headerlink" href="#red-triangle-figure2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>We will apply a texture to this triangle.</p>
<section id="creating-a-texture">
<h3><span class="section-number">3.1.1. </span>Creating a texture<a class="headerlink" href="#creating-a-texture" title="Permalink to this heading">#</a></h3>
<p>The first thing we need to do is create a texture object and bind it to a target so we can call upon it later. Enter the following code to the <strong>Lab03_Textures.cpp</strong> file after we tell OpenGL to compile the shader program</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create and bind texture</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">texture</span><span class="p">;</span>
<span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
<span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">texture</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we have defined a target called <code class="docutils literal notranslate"><span class="pre">texture</span></code> which is an integer used to refer to the texture. The texture is then generated and bound to this target using the <code class="docutils literal notranslate"><span class="pre">glGenTextures()</span></code> and <code class="docutils literal notranslate"><span class="pre">glBindTexture()</span></code> functions.</p>
<p>We now need to load a image into our texture. To do this we are going to make use of the <a href="https://github.com/nothings/stb/tree/master" target="_blank"><code class="docutils literal notranslate"><span class="pre">stb_image</span></code></a> library, the header file for which can be found in the <strong>common/</strong> folder. Enter the following code into your program.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Load texture image from file</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;../assets/crate.jpeg&quot;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">nChannels</span><span class="p">;</span>
<span class="n">stbi_set_flip_vertically_on_load</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stbi_load</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nChannels</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>The functions used here are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stbi_set_flip_vertically_on_load()</span></code> flips the image vertically since the <span class="math notranslate nohighlight">\((0,0)\)</span> co-ordinate on an images is the top-left corner and OpenGL expects it to be the bottom-right corner</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stbi_load()</span></code> loads the image specified in the <code class="docutils literal notranslate"><span class="pre">path</span></code> string into the <code class="docutils literal notranslate"><span class="pre">data</span></code> variable and the stores the width, height and number of colour channels into the appropriate variables</p></li>
</ul>
<p>The texture we are using here is <strong>crate.jpeg</strong> which is stored in the <strong>assets/</strong> folder and represents a side of a wooden crate.</p>
<figure class="align-default" id="id3">
<a class="reference internal image-reference" href="../_images/03_crate.jpeg"><img alt="../_images/03_crate.jpeg" src="../_images/03_crate.jpeg" style="width: 300px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.3 </span><span class="caption-text">The crate texture.</span><a class="headerlink" href="#id3" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>After getting the texture data from the image file we tell OpenGL we that have a texture. Enter the following code into your program.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Specify 2D texture</span>
<span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">,</span>
<span class="w">                </span><span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="n">glGenerateMipmap</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">glTexImage2D()</span></code> function tells OpenGL we have a 2D texture which is contained in <code class="docutils literal notranslate"><span class="pre">data</span></code>. <code class="docutils literal notranslate"><span class="pre">GL_RGB</span></code> is the format that specifies the number of colours in the texture. Here we are using a JPEG file so the colour each textel is represented by the RGB model. The <code class="docutils literal notranslate"><span class="pre">glGenerateMipmap</span></code> generates mipmaps for the texture (mipmaps are explained <a class="reference internal" href="#mipmaps-section"><span class="std std-ref">below</span></a>).</p>
<p>Now that the texture data has been copied to the GPU we can free up memory by adding the following to the program.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Free the image from the memory</span>
<span class="n">stbi_image_free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="texture-co-ordinates">
<h3><span class="section-number">3.1.2. </span>Texture co-ordinates<a class="headerlink" href="#texture-co-ordinates" title="Permalink to this heading">#</a></h3>
<p>So we have created a texture and told OpenGL all about it. Now we need specify how we want to use the texture. To do this for each of the vertices of the triangle we need to define the corresponding <span class="math notranslate nohighlight">\((u, v)\)</span> texture co-ordinates. This is done in a the same way as the triangle vertices, i.e., define an array containing the co-ordinates, create a buffer and copy the co-ordinates to this buffer.</p>
<p>Enter the following code after we defined the <code class="docutils literal notranslate"><span class="pre">vertices</span></code> array (you may need to scroll up a bit).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define texture coordinates</span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">uv</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// u   v</span>
<span class="w">    </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span>
<span class="w">    </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here we have defined an array of float values called <code class="docutils literal notranslate"><span class="pre">uv</span></code> and specified the texture co-ordinates so that the bottom-left triangle vertex is mapped to the texture co-ordinate <span class="math notranslate nohighlight">\((0, 0)\)</span> at the bottom-left corner of the texture, the bottom-right vertex is mapped to <span class="math notranslate nohighlight">\((1,0)\)</span> at the bottom-right corner of the texture and the top vertex is mapped to <span class="math notranslate nohighlight">\((0.5, 1)\)</span> in the middle of the top edge of the texture.</p>
<p>The buffer for the texture co-ordinates is created in the same was as for the triangle vertices. Enter the following code after the VBO was created.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create texture buffer</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">uvBuffer</span><span class="p">;</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">uvBuffer</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">uvBuffer</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv</span><span class="p">),</span><span class="w"> </span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</pre></div>
</div>
<p>Sending the texture co-ordinates to the GPU is done in the same way as for the VBO. Enter the following code after we send the VBO to the GPU (this is in the render loop so scroll down a bit).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send the UV buffer to the shaders</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">uvBuffer</span><span class="p">);</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that since each texture co-ordinates requires just 2 floats for <span class="math notranslate nohighlight">\((u,v)\)</span> instead of 3 for the vertex co-ordinates <span class="math notranslate nohighlight">\((x,y,z)\)</span> the second argument in the <code class="docutils literal notranslate"><span class="pre">glVertexAttribPointer()</span></code> function is <code class="docutils literal notranslate"><span class="pre">2</span></code> instead of <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
</section>
<section id="shaders">
<h3><span class="section-number">3.1.3. </span>Shaders<a class="headerlink" href="#shaders" title="Permalink to this heading">#</a></h3>
<section id="vertex-shader">
<h4><span class="section-number">3.1.3.1. </span>Vertex shader<a class="headerlink" href="#vertex-shader" title="Permalink to this heading">#</a></h4>
<p>Recall that the <a class="reference internal" href="02_basic_shapes_in_OpenGL.html#vertex-shader-section"><span class="std std-ref">vertex shader</span></a> deals with the vertex co-ordinates and is used by OpenGL to calculate the co-ordinates of the fragment. So in addition to passing the <span class="math notranslate nohighlight">\((x, y, z)\)</span> co-ordinates of the vertices we must also pass the <span class="math notranslate nohighlight">\((u, v)\)</span> co-ordinates of the textels that correspond to the triangle vertices.</p>
<p>Edit the <strong>vertexShader.glsl</strong> file in the <strong>Lab03_Textures</strong> project so that it looks like the following.</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="c1">// Inputs</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>

<span class="c1">// Outputs</span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">UV</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Output vertex position</span>
<span class="w">    </span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Output texture co-ordinates</span>
<span class="w">    </span><span class="n">UV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may notice some changes from our vertex shader from <a class="reference internal" href="02_basic_shapes_in_OpenGL.html#vertex-shader-section"><span class="std std-ref">Lab02 Basic Shapes in OpenGL</span></a>. We now have a second input <code class="docutils literal notranslate"><span class="pre">uv</span></code> which is a 2-element vector which are the <span class="math notranslate nohighlight">\((u,v)\)</span> texture coordinates which are outputted as the 2-element vector <code class="docutils literal notranslate"><span class="pre">UV</span></code> (remember that the <code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> vector is passed to the fragment shader by default).</p>
</section>
<section id="fragment-shader">
<h4><span class="section-number">3.1.3.2. </span>Fragment shader<a class="headerlink" href="#fragment-shader" title="Permalink to this heading">#</a></h4>
<p>The fragment shader is where we need to retrieve the sample colour from the texture. Edit the <strong>fragmentShader.glsl</strong> file so that it looks like the following.</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="c1">// Input</span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">UV</span><span class="p">;</span>

<span class="c1">// Output</span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">colour</span><span class="p">;</span>

<span class="c1">// Uniforms</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">sampler2D</span><span class="w"> </span><span class="n">texture</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">texture</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we now have an input of the 2-element vector <code class="docutils literal notranslate"><span class="pre">uv</span></code> which has been outputted from the vertex shader. Since our texture is a 2D image then we use the <a href="https://www.khronos.org/opengl/wiki/Sampler_(GLSL)" target="_blank"><code class="docutils literal notranslate"><span class="pre">sampler2D</span></code></a> GLSL type to declare the uniform <code class="docutils literal notranslate"><span class="pre">textureMap</span></code> (uniforms are explained <a class="reference internal" href="#uniforms-section"><span class="std std-ref">below</span></a>). The colour of the fragment is taken from the texture using the <code class="docutils literal notranslate"><span class="pre">texture()</span></code> function where the first argument is the name of the texture uniform and the second argument is the <span class="math notranslate nohighlight">\((u,v)\)</span> texture co-ordinates of the fragment.</p>
<p>Compile and run program and, after sending a prayer to the programming gods, you should be presented with your triangle which has now been textured using the crate texture.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/03_texture_triangle.png"><img alt="../_images/03_texture_triangle.png" src="../_images/03_texture_triangle.png" style="width: 500px;" /></a>
</figure>
</section>
</section>
</section>
<hr class="docutils" />
<section id="texture-rectangle">
<h2><span class="section-number">3.2. </span>Texture rectangle<a class="headerlink" href="#texture-rectangle" title="Permalink to this heading">#</a></h2>
<p>Our texture triangle is great and all but doesn’t really look like a realistic object. Since the original texture is rectangular, lets create a rectangle out of two triangles with the appropriate texture mapping.</p>
<figure class="align-default" id="id4">
<a class="reference internal image-reference" href="../_images/03_rectangle.svg"><img alt="../_images/03_rectangle.svg" src="../_images/03_rectangle.svg" width="450" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.4 </span><span class="caption-text">A rectangle constructed using two triangles.</span><a class="headerlink" href="#id4" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>So the lower-right (blue) triangle has vertex co-ordinates <span class="math notranslate nohighlight">\((-0.5, -0.5, 0)\)</span>, <span class="math notranslate nohighlight">\((0.5, -0.5, 0)\)</span> and <span class="math notranslate nohighlight">\((0.5, 0.5, 0)\)</span> and the upper-left (red) triangle has vertex co-ordinates <span class="math notranslate nohighlight">\((-0.5, -0.5, 0)\)</span>, <span class="math notranslate nohighlight">\((0.5, 0.5, 0)\)</span> and <span class="math notranslate nohighlight">\((-0.5, 0.5, 0)\)</span>. Change the <code class="docutils literal notranslate"><span class="pre">vertices</span></code> and <code class="docutils literal notranslate"><span class="pre">uv</span></code> arrays to the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define vertex positions</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">vertices</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">    </span><span class="c1">// triangle 1</span>
<span class="w">     </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span>
<span class="w">     </span><span class="mf">0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span>
<span class="w">    </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">    </span><span class="c1">// triangle 2</span>
<span class="w">     </span><span class="mf">0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span>
<span class="w">    </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span>
<span class="p">};</span>

<span class="c1">// Define texture co-ordinates</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">uv</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// u    v</span>
<span class="w">    </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">    </span><span class="c1">// triangle 1</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">,</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span>
<span class="w">    </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">    </span><span class="c1">// triangle 2</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span>
<span class="w">    </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Compile and run the program and you should be presented with the more realistic image in <a class="reference internal" href="#texture-rectangle-figure"><span class="std std-numref">Fig. 3.5</span></a>.</p>
<figure class="align-default" id="texture-rectangle-figure">
<a class="reference internal image-reference" href="../_images/03_texture_rectangle.png"><img alt="../_images/03_texture_rectangle.png" src="../_images/03_texture_rectangle.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.5 </span><span class="caption-text">Texture mapped onto two triangles that form a rectangle.</span><a class="headerlink" href="#texture-rectangle-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="element-buffer-objects-ebo">
<h3><span class="section-number">3.2.1. </span>Element Buffer Objects (EBO)<a class="headerlink" href="#element-buffer-objects-ebo" title="Permalink to this heading">#</a></h3>
<p>Our rectangle is defined using 6 sets of <span class="math notranslate nohighlight">\((x,y,z)\)</span> co-ordinates for the 2 triangles but a rectangle only has 4 vertices. This means we are using 2 extra co-ordinates than we really need to as both of the triangles share the vertices at <span class="math notranslate nohighlight">\((-0.5, -0.5, 0)\)</span> and <span class="math notranslate nohighlight">\((0.5, 0.5, 0)\)</span>. This isn’t too bad for our simple rectangle example but for more sophisticated scenes that use thousands of triangles it can be inefficient.</p>
<p>To improve on this we can use an <strong>Element Buffer Object (EBO)</strong> that contains <strong>indices</strong> that map a vertex of the rectangle to the <code class="docutils literal notranslate"><span class="pre">vertices</span></code> array. Consider <a class="reference internal" href="#rectangle-indices-figure"><span class="std std-numref">Fig. 3.6</span></a> that shows a rectangle drawn using two triangles. The lower-right triangle is formed using the vertices with indices 0, 1 and 2 and the upper-left triangle is formed using vertices with indices 0, 2 and 3.</p>
<figure class="align-default" id="rectangle-indices-figure">
<a class="reference internal image-reference" href="../_images/03_indices.svg"><img alt="../_images/03_indices.svg" src="../_images/03_indices.svg" width="200" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.6 </span><span class="caption-text">The mapping of indices to the rectangle vertices.</span><a class="headerlink" href="#rectangle-indices-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Comment out the code used to define the <code class="docutils literal notranslate"><span class="pre">vertices</span></code> and <code class="docutils literal notranslate"><span class="pre">uv</span></code> arrays and enter the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define vertex positions</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">vertices</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// x     y     z      index</span>
<span class="w">    </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="c1">// 0       3 -- 2</span>
<span class="w">     </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="c1">// 1       |  / |  </span>
<span class="w">     </span><span class="mf">0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="c1">// 2       | /  |</span>
<span class="w">    </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w">   </span><span class="c1">// 3       0 -- 1</span>
<span class="p">};</span>

<span class="c1">// Define texture co-ordinates</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">uv</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// u    v      index</span>
<span class="w">    </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="c1">// 0</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="c1">// 1</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="c1">// 2</span>
<span class="w">    </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="c1">// 3</span>
<span class="p">};</span>

<span class="c1">// Define indices</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">indices</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="c1">// lower-right triangle</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w">   </span><span class="c1">// upper-left triangle</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As with the other buffer objects we need to create a buffer for the indices, bind it and copy the data across. Enter the following code after we’ve created the texture buffer.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create Element Buffer Object (EBO)</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">EBO</span><span class="p">;</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">EBO</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">EBO</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"> </span>
<span class="w">                </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</pre></div>
</div>
<p>This is similar to the code used to create the other buffer objects with the exception we are creating an <code class="docutils literal notranslate"><span class="pre">GL_ELEMENT_ARRAY_BUFFER</span></code> instead of an <code class="docutils literal notranslate"><span class="pre">GL_ARRAY_BUFFER</span></code>. The last change we need to make in order to use our EBO is to change the function used to draw the triangles from <code class="docutils literal notranslate"><span class="pre">glDrawArrays()</span></code> to <code class="docutils literal notranslate"><span class="pre">glDrawElements()</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Draw the triangle</span>
<span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">),</span><span class="w"> </span>
<span class="w">                </span><span class="n">GL_UNSIGNED_INT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Make this change, compile and run the program and you should see the window from <a class="reference internal" href="#texture-rectangle-figure"><span class="std std-numref">Fig. 3.5</span></a>. You may be thinking you’ve gone to all of that trouble only for the rectangle to look exactly the same. Well, now we are using fewer floats in the <code class="docutils literal notranslate"><span class="pre">vertices</span></code> array and we can now use EBOs to draw more sophisticated shapes and 3D models.</p>
</section>
</section>
<hr class="docutils" />
<section id="texture-wrapping-and-filtering">
<h2><span class="section-number">3.3. </span>Texture wrapping and filtering<a class="headerlink" href="#texture-wrapping-and-filtering" title="Permalink to this heading">#</a></h2>
<section id="texture-wrapping">
<h3><span class="section-number">3.3.1. </span>Texture wrapping<a class="headerlink" href="#texture-wrapping" title="Permalink to this heading">#</a></h3>
<p>In our examples above, all of the texture co-ordinates have been in the range from 0 to 1. What happens if we use textures co-ordinates outside of this range? To test this we are going to change our texture to something less symmetrical (you will see why in a minute). Change the <code class="docutils literal notranslate"><span class="pre">path</span></code> variable to the following</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Load texture image from file</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;../assets/mario.png&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>PNG (Portable Network Graphics) files use the RGBA colour model which is the standard RGB model with an addition Alpha value that determines the opacity of the colours. We need to let OpenGL know that our texture is defined using RGBA so change instances <code class="docutils literal notranslate"><span class="pre">GL_RGB</span></code> in the <code class="docutils literal notranslate"><span class="pre">glTexImage2D()</span></code> function to <code class="docutils literal notranslate"><span class="pre">GL_RGBA</span></code>, i.e.,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Specify 2D texture</span>
<span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGBA</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGBA</span><span class="p">,</span>
<span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
<p>Compile and run the program and you should be presented with a (hopefully) familiar face.</p>
<figure class="align-default" id="mario-rectangle-figure">
<a class="reference internal image-reference" href="../_images/03_mario_rectangle.png"><img alt="../_images/03_mario_rectangle.png" src="../_images/03_mario_rectangle.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.7 </span><span class="caption-text">Its a me, Mario!</span><a class="headerlink" href="#mario-rectangle-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Now we can experiment with specifying texture co-ordinates outside of the range 0 to 1. Edit the <code class="docutils literal notranslate"><span class="pre">uv</span></code> array to change all of the <code class="docutils literal notranslate"><span class="pre">1.0f</span></code> values to <code class="docutils literal notranslate"><span class="pre">2.0f</span></code>. Compile and run the program and you should see the image shown in <a class="reference internal" href="#gl-repeat-figure"><span class="std std-numref">Fig. 3.8</span></a></p>
<figure class="align-default" id="gl-repeat-figure">
<a class="reference internal image-reference" href="../_images/03_GL_REPEAT.png"><img alt="../_images/03_GL_REPEAT.png" src="../_images/03_GL_REPEAT.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.8 </span><span class="caption-text">Texture wrapping using <code class="docutils literal notranslate"><span class="pre">GL_REPEAT</span></code>.</span><a class="headerlink" href="#gl-repeat-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>What has happened here as that OpenGL has used <strong>texture wrapping</strong> to repeated the texture over the rectangle (or more accurately the two triangles). This can be useful if we want to use a small texture containing a pattern over a larger polygon, e.g., think of brick wall where the pattern repeats itself.</p>
<p>OpenGL offers other options for texture wrapping;</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GL_REPEAT</span></code> - the texture repeats over the fragment (default);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GL_MIRRORED_REPEAT</span></code> - same as <code class="docutils literal notranslate"><span class="pre">GL_REPEAT</span></code> but the texture is mirrored with each repeat;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GL_CLAMP_TO_EDGE</span></code> - clamps the texture co-ordinates to between 0 and 1, co-ordinates outside of this range are clamped to the edge so that the textels on the edge are stretched to the edge of the fragment;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GL_CLAMP_TO_BORDER</span></code> - co-ordinates outside of the range <span class="math notranslate nohighlight">\((0,0)\)</span> to <span class="math notranslate nohighlight">\((1,1)\)</span> are given a used defined border colour.</p></li>
</ul>
<p>We can specify the texture wrapping using the <code class="docutils literal notranslate"><span class="pre">glTexParameteri()</span></code> function. To apply <code class="docutils literal notranslate"><span class="pre">GL_MIRRORED_REPEAT</span></code> add the following code after the texture as been specified.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Set texture wrapping options</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span><span class="w"> </span><span class="n">GL_MIRRORED_REPEAT</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span><span class="w"> </span><span class="n">GL_MIRRORED_REPEAT</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we have specified the wrapping in the horizontal (<code class="docutils literal notranslate"><span class="pre">S</span></code>) and vertical (<code class="docutils literal notranslate"><span class="pre">T</span></code>) directions (some people, including as it seems the contributors to OpenGL, use <span class="math notranslate nohighlight">\((s,t)\)</span> for the vertex co-ordinates instead of the standard <span class="math notranslate nohighlight">\((u,v)\)</span>) to <code class="docutils literal notranslate"><span class="pre">GL_MIRRORED_REPEAT</span></code>. Compile and run the program and you should see the image shown in <a class="reference internal" href="#gl-mirrored-repeat-figure"><span class="std std-numref">Fig. 3.9</span></a>.</p>
<figure class="align-default" id="gl-mirrored-repeat-figure">
<a class="reference internal image-reference" href="../_images/03_GL_MIRRORED_REPEAT.png"><img alt="../_images/03_GL_MIRRORED_REPEAT.png" src="../_images/03_GL_MIRRORED_REPEAT.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.9 </span><span class="caption-text">Texture wrapping using <code class="docutils literal notranslate"><span class="pre">GL_MIRRORED_REPEAT</span></code>.</span><a class="headerlink" href="#gl-mirrored-repeat-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Using <code class="docutils literal notranslate"><span class="pre">GL_CLAMP_TO_EDGE</span></code> and <code class="docutils literal notranslate"><span class="pre">GL_CLAMP_TO_BORDER</span></code> instead results in the images shown in <a class="reference internal" href="#gl-clamp-to-edge-figure"><span class="std std-numref">Fig. 3.10</span></a> and <a class="reference internal" href="#gl-clamp-to-edge-figure"><span class="std std-numref">Fig. 3.10</span></a>.</p>
<div class="sd-container-fluid sd-sphinx-override sd-mb-4 docutils">
<div class="sd-row docutils">
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="gl-clamp-to-edge-figure">
<img alt="../_images/03_GL_CLAMP_TO_EDGE.png" src="../_images/03_GL_CLAMP_TO_EDGE.png" />
<figcaption>
<p><span class="caption-number">Fig. 3.10 </span><span class="caption-text">Texture wrapping using <code class="docutils literal notranslate"><span class="pre">GL_CLAMP_TO_EDGE</span></code>.</span><a class="headerlink" href="#gl-clamp-to-edge-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="gl-clamp-to-border-figure">
<img alt="../_images/03_GL_CLAMP_TO_BORDER.png" src="../_images/03_GL_CLAMP_TO_BORDER.png" />
<figcaption>
<p><span class="caption-number">Fig. 3.11 </span><span class="caption-text">Texture wrapping using <code class="docutils literal notranslate"><span class="pre">GL_CLAMP_TO_BORDER</span></code>.</span><a class="headerlink" href="#gl-clamp-to-border-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="texture-filtering">
<h3><span class="section-number">3.3.2. </span>Texture filtering<a class="headerlink" href="#texture-filtering" title="Permalink to this heading">#</a></h3>
<p><strong>Texture filtering</strong> is method of determining the colour of the fragment, known as the <strong>colour sample</strong>, from the texture. OpenGL maps the co-ordinates of the fragment to the texture co-ordinates and in most cases this will not align exactly to a textel centre, so what does OpenGL do? OpenGL provides two main options : nearest-neighbour interpolation and bilinear interpolation.</p>
<section id="nearest-neighbour-interpolation">
<h4><span class="section-number">3.3.2.1. </span>Nearest neighbour interpolation<a class="headerlink" href="#nearest-neighbour-interpolation" title="Permalink to this heading">#</a></h4>
<p><strong>Nearest neighbour interpolation</strong> is the default in OpenGL uses the colour of the nearest textel to the texture co-ordinates as the colour sample. This is illustrated in the diagram shown in <a class="reference internal" href="#nearest-neighbour-interpolation-figure"><span class="std std-numref">Fig. 3.12</span></a> where the texture co-ordinates represented by the black circle is mapped in a region on the texture with four neighbouring textels with the textel centres represented by the crosses. The texture co-ordinates are closest to the centre of the textel in the top-left so the colour of that textel is used for the colour sample.</p>
<figure class="align-default" id="nearest-neighbour-interpolation-figure">
<a class="reference internal image-reference" href="../_images/03_nearest_neighbour.svg"><img alt="../_images/03_nearest_neighbour.svg" src="../_images/03_nearest_neighbour.svg" width="500" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.12 </span><span class="caption-text">Nearest neighbour interpolation.</span><a class="headerlink" href="#nearest-neighbour-interpolation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To apply texture filtering we specify the type of interpolation we want in using <code class="docutils literal notranslate"><span class="pre">glTexParameteri()</span></code> functions. To apply nearest neighbour interpolation add the following code to your program.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL_NEAREST</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL_NEAREST</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">GL_TEXTURE_MIN_FILTER</span></code> and <code class="docutils literal notranslate"><span class="pre">GL_TEXTURE_MAG_FILTER</span></code> arguments refer to <strong>minification</strong> and <strong>magnification</strong>. Minification is where the texture is larger than the polygon it is being mapped to so a fragment covers multiple textels. Magnification is the opposite where the texture is smaller than the polygon so that a single textel takes up multiple fragments. We can set different interpolation for magnification and minification.</p>
<p>To demonstrate the affects of minification lets use a low resolution texture. Change the <code class="docutils literal notranslate"><span class="pre">path</span></code> variable to the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Load texture image from file</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;../assets/mario_small.png&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Compile and run the program and you should see the image shown in <a class="reference internal" href="#gl-nearest-figure"><span class="std std-numref">Fig. 3.13</span></a>.</p>
<figure class="align-default" id="gl-nearest-figure">
<a class="reference internal image-reference" href="../_images/03_GL_NEAREST.png"><img alt="../_images/03_GL_NEAREST.png" src="../_images/03_GL_NEAREST.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.13 </span><span class="caption-text">Nearest neighbour interpolation</span><a class="headerlink" href="#gl-nearest-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>As you can see the texture mapped rectangle has a block <strong>aliased</strong> look since multiple fragments share the same textel.</p>
</section>
<section id="bilinear-interpolation">
<h4><span class="section-number">3.3.2.2. </span>Bilinear interpolation<a class="headerlink" href="#bilinear-interpolation" title="Permalink to this heading">#</a></h4>
<p>Another method is to calculate the sample colour using <a href="https://en.wikipedia.org/wiki/Bilinear_interpolation" target="_blank"><strong>bilinear interpolation</strong></a> where the distance between <span class="math notranslate nohighlight">\((u,v)\)</span> co-ordinate and the centre of a textel determines how much that textel contributes to the sample colour, i.e., the closer the textel the more of the textel colour is contained in the colour sample.</p>
<figure class="align-default" id="bilinear-interpolation-figure">
<a class="reference internal image-reference" href="../_images/03_bilinear.svg"><img alt="../_images/03_bilinear.svg" src="../_images/03_bilinear.svg" width="500" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.14 </span><span class="caption-text">Bilinear interpolation.</span><a class="headerlink" href="#bilinear-interpolation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To see the affects of bilinear interpolation, change <code class="docutils literal notranslate"><span class="pre">GL_NEAREST</span></code> to <code class="docutils literal notranslate"><span class="pre">GL_LINEAR</span></code> in the <code class="docutils literal notranslate"><span class="pre">glTexParameteri()</span></code> functions. Compile and run the program and you should see the image shown in <a class="reference internal" href="#gl-linear-figure"><span class="std std-numref">Fig. 3.15</span></a>.</p>
<figure class="align-default" id="gl-linear-figure">
<a class="reference internal image-reference" href="../_images/03_GL_LINEAR.png"><img alt="../_images/03_GL_LINEAR.png" src="../_images/03_GL_LINEAR.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.15 </span><span class="caption-text">Nearest neighbour interpolation</span><a class="headerlink" href="#gl-linear-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Here we have an improved texture mapping where the aliasing is less noticeable.</p>
<hr class="docutils" />
</section>
</section>
</section>
<section id="mipmaps">
<span id="mipmaps-section"></span><h2><span class="section-number">3.4. </span>Mipmaps<a class="headerlink" href="#mipmaps" title="Permalink to this heading">#</a></h2>
<p>Another issue that may occur is when the fragment is a lot smaller than the texture which can happen when an object that is far away from the viewer. In these cases OpenGL will struggle to get the colour sample from a high resolution texture since a single fragment covers a large part of the texture.</p>
<p>To solve this issue OpenGL uses <a href="https://www.khronos.org/opengl/wiki/Texture#Mip_maps" target="_blank"><strong>mipmaps</strong></a> (mip is short for the latin phrase <em>“multum in parvo”</em> or “much in little”) which are a series of textures, each one half the size of the previous one. OpenGL will use a mipmap texture most suitable based on the distance of the fragment from the viewer. This way the fragment does not span a large part of the texture and it also cuts down on memory.</p>
<figure class="align-default" id="id5">
<a class="reference internal image-reference" href="../_images/03_mipmaps.svg"><img alt="../_images/03_mipmaps.svg" src="../_images/03_mipmaps.svg" width="500" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.16 </span><span class="caption-text">Mipmaps</span><a class="headerlink" href="#id5" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The good news is that we do not need to create lots of new different size textures because OpenGL has a function <code class="docutils literal notranslate"><span class="pre">glGenerateMipmap()</span></code> to do this for us which we have been using for a while.</p>
<p>One issue we may encounter is that when we switch between two mipmaps, e.g., when the viewer is moving towards or away from an object, there can be a notable change in appearance of the object. This is known as <strong>texture popping</strong> and is caused by switching between two mipmaps. To overcome this OpenGL gives the option to sample the texture from a linear interpolation between the two nearest mipmaps. So we have two main texture filtering options and two mipmap options giving four main mipmap options:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GL_NEAREST_MIPMAP_NEAREST</span></code> - uses nearest texture filtering on the nearest mipmap;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GL_LINEAR_MIPMAP_NEAREST</span></code> - uses linear texture filtering on the nearest mipmap;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GL_NEAREST_MIPMAP_LINEAR</span></code> - uses nearest texture filtering on a linear interpolation between two mipmaps;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GL_LINEAR_MIPMAP_LINEAR</span></code> - uses linear texture filtering on a linear interpolation between two mipmaps.</p></li>
</ul>
<p>Like with the texture filtering methods we can use different options for magnifying and minifying the texture. A popular combination is to use <code class="docutils literal notranslate"><span class="pre">GL_LINEAR</span></code> for the magnification filter and <code class="docutils literal notranslate"><span class="pre">GL_LINEAR_MIPMAP_LINEAR</span></code> for the minification filter to avoid textures popping as we zoom into a polygon.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL_LINEAR</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL_LINEAR_MIPMAP_LINEAR</span><span class="p">);</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="multiple-textures">
<h2><span class="section-number">3.5. </span>Multiple textures<a class="headerlink" href="#multiple-textures" title="Permalink to this heading">#</a></h2>
<p>OpenGL allows us to use multiple textures in a single fragment shader (up to 16 in fact). For each new texture we use we need to create and bind the texture to a target, load the texture data from an image file and set the texture wrapping and filtering options. Rather than copying and pasting all of the code we have done for each new texture it makes sense to write a function that does this for us. Well if you look in the <strong>Lab03_Textures</strong> project, hidden away in the <strong>Header files</strong> folder is the file <strong>texture.hpp</strong> that contains a function <code class="docutils literal notranslate"><span class="pre">loadTexture()</span></code> that does all of the hard work for us (so why did I get you to do all of that coding above - I’m just evil I suppose <em>mwahahahahaaa</em>).</p>
<p>Comment out all of the code from the <strong>Lab03_Textures.cpp</strong> file you’ve written so far in this lab (or delete it if you are feeling a but annoyed) and enter the following code before the render loop.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Load the textures</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">texture1</span><span class="p">,</span><span class="w"> </span><span class="n">texture2</span><span class="p">;</span>
<span class="n">texture1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">loadTexture</span><span class="p">(</span><span class="s">&quot;../assets/crate.jpg&quot;</span><span class="p">);</span>
<span class="n">texture2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">loadTexture</span><span class="p">(</span><span class="s">&quot;../assets/mario.png&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This loads the two textures we have been using which can be accessed using their targets <code class="docutils literal notranslate"><span class="pre">texture1</span></code> and <code class="docutils literal notranslate"><span class="pre">texture2</span></code>. Compile and run the program and you should see the image from <a class="reference internal" href="#texture-rectangle-figure"><span class="std std-numref">Fig. 3.5</span></a>.</p>
<p>We now want to deal with two textures in the fragment shader so we need a way of telling OpenGL which texture is which, we do this using uniforms.</p>
<section id="uniforms">
<span id="uniforms-section"></span><h3><span class="section-number">3.5.1. </span>Uniforms<a class="headerlink" href="#uniforms" title="Permalink to this heading">#</a></h3>
<p>A <a href="https://www.khronos.org/opengl/wiki/Uniform_(GLSL)" target="_blank"><strong>uniform</strong></a> is a shader variable that remains constant during the execution of the rendering pass and has the same value for all vertices and fragments. Uniforms provide a way to passing data to the shaders so we will use one for passing the texture target to the fragment shader.</p>
<p>Add the following code to your program before the render loop (since the textures are the same for every frame).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send the texture uniforms to the fragment shader</span>
<span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderID</span><span class="p">);</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">texture1ID</span><span class="p">,</span><span class="w"> </span><span class="n">texture2ID</span><span class="p">;</span>
<span class="n">texture1ID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;texture1&quot;</span><span class="p">);</span>
<span class="n">texture2ID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;texture2&quot;</span><span class="p">);</span>
<span class="n">glUniform1i</span><span class="p">(</span><span class="n">texture1ID</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">glUniform1i</span><span class="p">(</span><span class="n">texture2ID</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we let OpenGL know we are using our shader program with the <code class="docutils literal notranslate"><span class="pre">glUseProgram()</span></code> function. We then get the location of two uniforms, called <code class="docutils literal notranslate"><span class="pre">texture1</span></code> and <code class="docutils literal notranslate"><span class="pre">texture2</span></code> respectively, and then assign the values of <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">1</span></code> to these uniforms using the <code class="docutils literal notranslate"><span class="pre">glUniform1i()</span></code> function. These values are the texture units that OpenGL uses to distinguish between the different textures in the fragment shader.</p>
</section>
<section id="texture-units">
<h3><span class="section-number">3.5.2. </span>Texture units<a class="headerlink" href="#texture-units" title="Permalink to this heading">#</a></h3>
<p>A <strong>texture unit</strong> is a location value used by fragment shader for the texture sampler we are using. The default texture unit for a texture is <code class="docutils literal notranslate"><span class="pre">GL_TEXTURE0</span></code> which is what we have been using up to now. We can have up to 16 texture units, <code class="docutils literal notranslate"><span class="pre">GL_TEXTURE0</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_TEXTURE1</span></code> up to <code class="docutils literal notranslate"><span class="pre">GL_TEXTURE15</span></code>. Alternatively we could use <code class="docutils literal notranslate"><span class="pre">GL_TEXTURE0</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_TEXTURE0</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">GL_TEXTURE0</span> <span class="pre">+</span> <span class="pre">2</span></code> up to <code class="docutils literal notranslate"><span class="pre">GL_TEXTURE</span> <span class="pre">+</span> <span class="pre">15</span></code>.</p>
<p>Add the following code before the render loop.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Bind the textures</span>
<span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
<span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">texture1</span><span class="p">);</span>
<span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE1</span><span class="p">);</span>
<span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">texture2</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">glActiveTexture()</span></code> function lets OpenGL know what texture unit we are currently dealing with and then we bind the texture to that unit using then <code class="docutils literal notranslate"><span class="pre">glBindTexture()</span></code> function.</p>
</section>
<section id="id1">
<h3><span class="section-number">3.5.3. </span>Fragment shader<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h3>
<p>The last thing we need to do is update the fragment shader so that it uses both textures. Modify <strong>fragmentShader.glsl</strong> so that is looks like the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="c1">// Input</span>
<span class="n">in</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">UV</span><span class="p">;</span>

<span class="c1">// Output</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">colour</span><span class="p">;</span>

<span class="c1">// Uniforms</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">sampler2D</span><span class="w"> </span><span class="n">texture1</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">sampler2D</span><span class="w"> </span><span class="n">texture2</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">mix</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">texture1</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">),</span><span class="w"> </span><span class="n">texture</span><span class="p">(</span><span class="n">texture2</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">),</span><span class="w"> </span><span class="mf">0.7</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we have defined the two <code class="docutils literal notranslate"><span class="pre">sampler2D</span></code> uniforms <code class="docutils literal notranslate"><span class="pre">texture1</span></code> and <code class="docutils literal notranslate"><span class="pre">texture2</span></code>, these need to be the same as what we called them in the <code class="docutils literal notranslate"><span class="pre">glGetUniformLocation()</span></code> functions. We then use the <code class="docutils literal notranslate"><span class="pre">mix()</span></code> function to combine the two textures so that 30% of the fragment colour is from the first texture (the crate) and the remaining 70% is from the second texture (Mario). Compile and run the program and you should see the image shown in <a class="reference internal" href="#two-textures-figure"><span class="std std-numref">Fig. 3.17</span></a>.</p>
<figure class="align-default" id="two-textures-figure">
<a class="reference internal image-reference" href="../_images/03_two_textures.png"><img alt="../_images/03_two_textures.png" src="../_images/03_two_textures.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3.17 </span><span class="caption-text">A rectangle with a mix of two textures applied.</span><a class="headerlink" href="#two-textures-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
</section>
<hr class="docutils" />
<section id="exercises">
<h2><span class="section-number">3.6. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Change the <code class="docutils literal notranslate"><span class="pre">uv</span></code> array to create a texture rectangle consisting of a 6 by 4 grid of Marios.</p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/03_Ex1.png"><img alt="../_images/03_Ex1.png" src="../_images/03_Ex1.png" style="width: 400px;" /></a>
</figure>
<ol class="arabic simple" start="2">
<li><p>Modify the fragment shader so that Mario is facing to the right instead of the left. Hint: the command <code class="docutils literal notranslate"><span class="pre">vec2(vector.x,</span> <span class="pre">vector.y)</span></code> creates a 2-element vector using the elements of <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/03_Ex2.png"><img alt="../_images/03_Ex2.png" src="../_images/03_Ex2.png" style="width: 400px;" /></a>
</figure>
<ol class="arabic simple" start="3">
<li><p>Apply a texture of your choice to the rectangle (e.g., a selfie).</p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/03_Ex3.png"><img alt="../_images/03_Ex3.png" src="../_images/03_Ex3.png" style="width: 400px;" /></a>
</figure>
<ol class="arabic simple" start="4">
<li><p>Change the <span class="math notranslate nohighlight">\((u,v)\)</span> co-ordinates so that the textured rectangle shows a zoomed in image of Mario’s eye.</p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/03_Ex4.png"><img alt="../_images/03_Ex4.png" src="../_images/03_Ex4.png" style="width: 400px;" /></a>
</figure>
<!-- ---

## Video walkthrough

The video below walks you through these lab materials.

<iframe width="560" height="315" src="https://www.youtube.com/embed/ZSHJsjKycyw?si=Z04BrW1IOjAzZuTB" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe> --></section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="02_basic_shapes_in_OpenGL.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">2. </span>Basic Shapes in OpenGL</p>
      </div>
    </a>
    <a class="right-next"
       href="04_vectors_and_matrices.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">4. </span>Vectors and Matrices</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-triangle">3.1. Texture triangle</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-texture">3.1.1. Creating a texture</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-co-ordinates">3.1.2. Texture co-ordinates</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shaders">3.1.3. Shaders</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#vertex-shader">3.1.3.1. Vertex shader</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#fragment-shader">3.1.3.2. Fragment shader</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-rectangle">3.2. Texture rectangle</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#element-buffer-objects-ebo">3.2.1. Element Buffer Objects (EBO)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-wrapping-and-filtering">3.3. Texture wrapping and filtering</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-wrapping">3.3.1. Texture wrapping</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-filtering">3.3.2. Texture filtering</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#nearest-neighbour-interpolation">3.3.2.1. Nearest neighbour interpolation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#bilinear-interpolation">3.3.2.2. Bilinear interpolation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mipmaps">3.4. Mipmaps</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multiple-textures">3.5. Multiple textures</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#uniforms">3.5.1. Uniforms</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#texture-units">3.5.2. Texture units</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">3.5.3. Fragment shader</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">3.6. Exercises</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dr Jon Shiach
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>