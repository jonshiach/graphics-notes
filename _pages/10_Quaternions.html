

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>10. Quaternions &#8212; Computer Graphics</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"model": ["M\\!odel"], "view": ["V\\!iew"], "mvp": ["MV\\!P"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/10_Quaternions';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="A. Complex Numbers and Quaternions" href="A_Complex_numbers_and_quaternions.html" />
    <link rel="prev" title="9. Normal Mapping" href="09_Normal_mapping.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Computer Graphics
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_intro_to_cpp.html">1. Introduction to C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_basic_shapes_in_OpenGL.html">2. Basic Shapes in OpenGL</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_textures.html">3. Textures</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_vectors_and_matrices.html">4. Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_transformations.html">5. Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_3D_worlds.html">6. 3D Worlds</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_Moving_the_camera.html">7. Moving the camera</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_Lighting.html">8. Lighting</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_Normal_mapping.html">9. Normal Mapping</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">10. Quaternions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="A_Complex_numbers_and_quaternions.html">A. Complex Numbers and Quaternions</a></li>
<li class="toctree-l1"><a class="reference internal" href="B_Code.html">B. Code and Assets</a></li>
<li class="toctree-l1"><a class="reference internal" href="C_Glossary.html">C Glossary</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs/issues/new?title=Issue%20on%20page%20%2F_pages/10_Quaternions.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/_pages/10_Quaternions.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Quaternions</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#complex-numbers">10.1. Complex Numbers</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rotation-using-complex-numbers">10.1.1. Rotation using complex numbers</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">10.2. Quaternions</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quaternion-rotations">10.2.1. Quaternion rotations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#euler-angles-to-quaternion">10.2.2. Euler angles to quaternion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#third-person-camera">10.3. Third person camera</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#slerp">10.4. SLERP</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">10.5. Source code</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="quaternions">
<span id="quaternions-section"></span><h1><span class="section-number">10. </span>Quaternions<a class="headerlink" href="#quaternions" title="Permalink to this heading">#</a></h1>
<p>We saw in <a class="reference internal" href="05_transformations.html#axis-angle-rotation-section"><span class="std std-ref">Lab 5 in Transformations</span></a> that we can use calculate a transformation matrix to rotate about a vector. This matrix was derived by compositing three individual rotations about the three co-ordinate <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> axes.</p>
<figure class="align-default" id="euler-angles-figure">
<a class="reference internal image-reference" href="../_images/10_Euler_angles.svg"><img alt="../_images/10_Euler_angles.svg" src="../_images/10_Euler_angles.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.1 </span><span class="caption-text">The pitch, yaw and roll Euler angles.</span><a class="headerlink" href="#euler-angles-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The angles that we use to define the rotation around each of the axes are known as <strong>Euler angles</strong> and we use the names <strong>pitch</strong>, <strong>yaw</strong> and <strong>roll</strong> for the rotation around the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> axes respectively. To problem with using a composite of Euler angles rotations is that for certain alignments we can experience <a href="https://en.wikipedia.org/wiki/Gimbal_lock" target="_blank"><strong>gimbal lock</strong></a> where two of the rotation axes are aligned leading to a loss of a degree of freedom causing the composite rotation to be “locked” into a 2D rotation.</p>
<p>Quaternions are a mathematical object that can be used to perform rotation operations that do not suffer from gimbal lock and require fewer floating point calculations. There is quite a lot of maths used here but in this lab sheet I’ve focussed only on the bits you need to know to apply quaternions. If you are interested in the derviations of the various equations see <a class="reference internal" href="A_Complex_numbers_and_quaternions.html#appendix-quaternions-section"><span class="std std-ref">Appendix A - Complex Numbers and Quaternions</span></a>.</p>
<p>Compile and run the project and you will see that we have the scene consisting of the cubes last seen in <a class="reference internal" href="07_Moving_the_camera.html#moving-the-camera-section"><span class="std std-ref">Lab 7</span></a>.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/10_Quaternions.png"><img alt="../_images/10_Quaternions.png" src="../_images/10_Quaternions.png" style="width: 500px;" /></a>
</figure>
<p>This project includes a Maths class that contains member functions that calculate the translation matrices for translation, scaling and rotation.</p>
<hr class="docutils" />
<section id="complex-numbers">
<h2><span class="section-number">10.1. </span>Complex Numbers<a class="headerlink" href="#complex-numbers" title="Permalink to this heading">#</a></h2>
<p>Before we delve into quaternions we must first look at complex numbers. Consider the equation</p>
<div class="math notranslate nohighlight">
\[ x^2 + 1 = 0. \]</div>
<p>Simple algebra gives the solution <span class="math notranslate nohighlight">\(x = \sqrt{-1}\)</span> but since a square of a number always returns a positive value, there does not exist a real number to satisfy the solution to this equation. Not being satisfied with this mathematicians invented another type of number called the <strong>imaginary number</strong> that is defined by <span class="math notranslate nohighlight">\(i^2 = -1\)</span> so the solution to the equation above is <span class="math notranslate nohighlight">\(x = i\)</span>.</p>
<p>Imaginary numbers can be combined with real numbers to give us a <strong>complex number</strong>. Despite their name, complex numbers aren’t complicated at all, they are simply a real number added to a multiple of the imaginary number</p>
<div class="math notranslate nohighlight">
\[ z = x + yi, \]</div>
<p>where <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are real numbers, <span class="math notranslate nohighlight">\(x\)</span> is known as the <em>real part</em> and <span class="math notranslate nohighlight">\(y\)</span> is known as the <em>imaginary part</em> of a complex number.</p>
<p>Since a complex number consists of two parts we can plot them on a 2D space called the <strong>complex plane</strong> where the horizontal axis is used to represent the real part and the vertical axis is used to represent the imaginary part (<a class="reference internal" href="#complex-plane-figure"><span class="std std-numref">Fig. 10.2</span></a>).</p>
<figure class="align-default" id="complex-plane-figure">
<a class="reference internal image-reference" href="../_images/10_Complex_plane.svg"><img alt="../_images/10_Complex_plane.svg" src="../_images/10_Complex_plane.svg" width="400" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.2 </span><span class="caption-text">The complex number <span class="math notranslate nohighlight">\(x + yi\)</span> plotted on the complex plane.</span><a class="headerlink" href="#complex-plane-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="rotation-using-complex-numbers">
<h3><span class="section-number">10.1.1. </span>Rotation using complex numbers<a class="headerlink" href="#rotation-using-complex-numbers" title="Permalink to this heading">#</a></h3>
<p>A very useful property of complex numbers, and the reason why we are interested in them, is that multiplying a number by <span class="math notranslate nohighlight">\(i\)</span> rotates the number by <span class="math notranslate nohighlight">\(90^\circ\)</span> in the complex plane. For example consider the complex number <span class="math notranslate nohighlight">\(2 + i\)</span>, multiplying repeatedly by <span class="math notranslate nohighlight">\(i\)</span> gives</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    (2 + i)i &amp;= 2i + i^2 = -1 + 2i, \\
    (-1 +2i)i &amp;= -i + 2i^2 = -2 - i, \\
    (-2 - i)i &amp;= -2i - i^2 = 1 - 2i, \\
    (1 - 2i)i &amp;= i - 2i^2 = 2 + i.
\end{align*} \end{split}\]</div>
<p>So after four multiplications we are back to the original complex number. <a class="reference internal" href="#complex-rotation-figure"><span class="std std-numref">Fig. 10.3</span></a> shows these complex numbers plotted on the complex plane. Note how they have been rotated by <span class="math notranslate nohighlight">\(90^\circ\)</span> each time.</p>
<figure class="align-default" id="complex-rotation-figure">
<a class="reference internal image-reference" href="../_images/10_Complex_rotation.svg"><img alt="../_images/10_Complex_rotation.svg" src="../_images/10_Complex_rotation.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.3 </span><span class="caption-text">Rotation of the complex number <span class="math notranslate nohighlight">\(2 + i\)</span> by repeated multiplying by <span class="math notranslate nohighlight">\(i\)</span>.</span><a class="headerlink" href="#complex-rotation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>So we have seen that multiplying a number by <span class="math notranslate nohighlight">\(i\)</span> rotates it by 90<span class="math notranslate nohighlight">\(^\circ\)</span>, so how do we rotate a number by a different angle. <a class="reference internal" href="#complex-rotation-2-figure"><span class="std std-numref">Fig. 10.4</span></a> shows the rotation of the number 1 by <span class="math notranslate nohighlight">\(\theta\)</span> anti-clockwise in the complex plane.</p>
<figure class="align-default" id="complex-rotation-2-figure">
<a class="reference internal image-reference" href="../_images/10_Complex_rotation_2.svg"><img alt="../_images/10_Complex_rotation_2.svg" src="../_images/10_Complex_rotation_2.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.4 </span><span class="caption-text">The complex number <span class="math notranslate nohighlight">\(z\)</span> is the real number 1 rotated <span class="math notranslate nohighlight">\(\theta\)</span> anti-clockwise in the complex plane.</span><a class="headerlink" href="#complex-rotation-2-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Recall that <span class="math notranslate nohighlight">\(\cos(\theta) = \dfrac{\textsf{adjacent}}{\textsf{hypotenuse}}\)</span> and <span class="math notranslate nohighlight">\(\sin(\theta) = \dfrac{\textsf{opposite}}{\textsf{hypotenuse}}\)</span> and since the hypotenuse is 1 then</p>
<div class="math notranslate nohighlight">
\[ z = \cos(\theta) + i \sin(\theta).\]</div>
<p>This means we can rotate by an arbitrary angle <span class="math notranslate nohighlight">\(\theta\)</span> in the complex plane by multiplying by <span class="math notranslate nohighlight">\(z\)</span>.</p>
</section>
</section>
<hr class="docutils" />
<section id="id1">
<h2><span class="section-number">10.2. </span>Quaternions<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h2>
<p>A <strong>quaternion</strong> is an extension of a complex number where two additional imaginary numbers are used to extend from a 2D space to a 4D space. The general form of a quaternion is</p>
<div class="math notranslate nohighlight">
\[ q = w + xi + yj + zk, \]</div>
<p>where <span class="math notranslate nohighlight">\(w\)</span>, <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> are real numbers and <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(j\)</span> and <span class="math notranslate nohighlight">\(k\)</span> are imaginary numbers which are related to -1 and each other by</p>
<div class="math notranslate nohighlight">
\[i^2 = j^2 = k^2 = ijk = -1. \]</div>
<p>Quaternions are more commonly represented in scalar-vector form</p>
<div class="math notranslate nohighlight">
\[q = [w, (x, y, z)].\]</div>
<p>We are going to add a data structure to the Maths class and some member functions to perform quaternion calculations. In the <code class="docutils literal notranslate"><span class="pre">maths.hpp</span></code> file add the following code above where the Math class is declared.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Quaternion</span>
<span class="p">{</span>
    <span class="nb">float</span> <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
    
    <span class="o">//</span> <span class="n">Constructors</span>
    <span class="n">Quaternion</span><span class="p">();</span>
    <span class="n">Quaternion</span><span class="p">(</span><span class="n">const</span> <span class="nb">float</span> <span class="n">w</span><span class="p">,</span> <span class="n">const</span> <span class="nb">float</span> <span class="n">x</span><span class="p">,</span> <span class="n">const</span> <span class="nb">float</span> <span class="n">y</span><span class="p">,</span> <span class="n">const</span> <span class="nb">float</span> <span class="n">z</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This is a data structure called <code class="docutils literal notranslate"><span class="pre">Quaternion</span></code> which contains the attributes <code class="docutils literal notranslate"><span class="pre">w</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> values and two constructor methods (one for creating a quaternion and another for creating a quaternion and initialising the <span class="math notranslate nohighlight">\(w\)</span>, <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> values).</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">maths.cpp</span></code> add the following function definitions for the constructors.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Quaternion constructors</span>
<span class="n">Quaternion</span><span class="o">::</span><span class="n">Quaternion</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>

<span class="n">Quaternion</span><span class="o">::</span><span class="n">Quaternion</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="quaternion-rotations">
<h3><span class="section-number">10.2.1. </span>Quaternion rotations<a class="headerlink" href="#quaternion-rotations" title="Permalink to this heading">#</a></h3>
<p>We saw above that we can rotate a number in the complex plane by multiplying by the complex number</p>
<div class="math notranslate nohighlight">
\[ z = \cos(\theta) + i\sin(\theta). \]</div>
<p>We can do similar in 4D space by multiplying a quaternion by the rotation quaternion</p>
<div class="math notranslate nohighlight" id="equation-rotation-quaternion-equation">
<span class="eqno">(10.1)<a class="headerlink" href="#equation-rotation-quaternion-equation" title="Permalink to this equation">#</a></span>\[ q = [\cos(\tfrac{1}{2}\theta), \sin(\tfrac{1}{2}\theta) \hat{\mathbf{v}}], \]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\mathbf{v}}\)</span> is a unit vector around which we are rotating (see <a class="reference internal" href="A_Complex_numbers_and_quaternions.html#appendix-quaternion-rotation-section"><span class="std std-ref">Appendix: Quaternion rotation</span></a> for the derivation of this).</p>
<figure class="align-default" id="axis-angle-rotation-figure-2">
<a class="reference internal image-reference" href="../_images/10_Axis_angle_rotation.svg"><img alt="../_images/10_Axis_angle_rotation.svg" src="../_images/10_Axis_angle_rotation.svg" width="350" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.5 </span><span class="caption-text">Axis-angle rotation about the vector <span class="math notranslate nohighlight">\(\hat{\mathbf{v}}\)</span>.</span><a class="headerlink" href="#axis-angle-rotation-figure-2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>We have been using <span class="math notranslate nohighlight">\(4 \times 4\)</span> matrices to compute the transformations to convert between model, view and screen spaces so in order to use quaternions for rotations we need to calculate a <span class="math notranslate nohighlight">\(4 \times 4\)</span> rotation matrix that is equivalent to multiplying by the rotation quaternion from equation <a class="reference internal" href="#equation-rotation-quaternion-equation">(10.1)</a>.</p>
<p>If <span class="math notranslate nohighlight">\(q = [w, (x, y, z)]\)</span> is the rotation quaternion then the rotation matrix is</p>
<div class="math notranslate nohighlight" id="equation-quaternion-rotation-matrix-equation">
<span class="eqno">(10.2)<a class="headerlink" href="#equation-quaternion-rotation-matrix-equation" title="Permalink to this equation">#</a></span>\[\begin{split} \begin{align*}
    R &amp;= 
    \begin{pmatrix}
        1 - s(y^2 + z^2) &amp; s(xy + zw) &amp; s(xz - yw) &amp; 0 \\
        s(xy - zw) &amp; 1 - s(x^2 + z^2) &amp; s(yz + xw) &amp; 0 \\
        s(xz + yw) &amp; s(yz - xw) &amp; 1 - s(x^2 + y^2) &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}
\end{align*} \end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(s = \dfrac{2}{w^2 + x^2 + y^2 + z^2}\)</span> (see <a class="reference internal" href="A_Complex_numbers_and_quaternions.html#quaternion-rotation-matrix-derivation-section"><span class="std std-ref">Appendix: Rotation matrix</span></a> for the derivation of this matrix).</p>
<p>In <code class="docutils literal notranslate"><span class="pre">maths.hpp</span></code> add the following method declaration to the <code class="docutils literal notranslate"><span class="pre">Quaternion</span></code> data structure</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="nf">quatToMat</span><span class="p">();</span>
</pre></div>
</div>
<p>Then in <code class="docutils literal notranslate"><span class="pre">maths.cpp</span></code> add the following method definition</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Quaternion to rotation matrix conversion</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="nf">Quaternion::quatToMat</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w">  </span><span class="n">ys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w">  </span><span class="n">zs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">xy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="n">xz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">zs</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">yy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="n">yz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">zs</span><span class="p">,</span><span class="w"> </span><span class="n">zz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">zs</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">xw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">yw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="n">zw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">zs</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">yy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">zz</span><span class="p">);</span><span class="w"> </span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">zw</span><span class="p">;</span><span class="w">          </span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">yw</span><span class="p">;</span>
<span class="w">    </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xy</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">zw</span><span class="p">;</span><span class="w">          </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">zz</span><span class="p">);</span><span class="w"> </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yz</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xw</span><span class="p">;</span>
<span class="w">    </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xz</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">yw</span><span class="p">;</span><span class="w">          </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xw</span><span class="p">;</span><span class="w">          </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">yy</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">R</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can now calculate the rotation matrix for a rotation quaternion <code class="docutils literal notranslate"><span class="pre">q</span></code> using <code class="docutils literal notranslate"><span class="pre">q.quatToMat()</span></code>. Comparing this code to the definition of <code class="docutils literal notranslate"><span class="pre">rotate()</span></code> in the <code class="docutils literal notranslate"><span class="pre">maths.cpp</span></code> file we can see the the the quaternion rotation matrix requires 16 multiplications compared to 24 multiplications to calculate the rotation matrix based on the composite of three separate rotations about the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> axes and a translation. Efficiency is always a bonus but the main advantage is the quaternion rotation matrix does not suffer from gimbal lock.</p>
<p>So it makes sense to use the quaternion rotation matrix for our axis-angle rotations. Edit the <code class="docutils literal notranslate"><span class="pre">rotate()</span></code> function definition so that is looks like the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="nf">Maths::rotate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">mat</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">angle</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">sn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="mf">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">angle</span><span class="p">);</span>
<span class="w">    </span><span class="n">Quaternion</span><span class="w"> </span><span class="n">q</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span><span class="w"> </span><span class="n">sn</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sn</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">sn</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">quatToMat</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mat</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we normalise the vector which we are rotating around before calculating the rotation quaternion <code class="docutils literal notranslate"><span class="pre">q</span></code>. The function then returns quaternion rotation matrix multiplied by the input matrix <code class="docutils literal notranslate"><span class="pre">mat</span></code> (it isn’t really necessary to do this but I wanted our <code class="docutils literal notranslate"><span class="pre">rotate()</span></code> function to have the same functionality as the glm version).</p>
<p>Compile and run your program and you should see that nothing has changed. This is good news as we are now using efficient quaternion rotation to rotate the cubes and don’t have to worry about gimbal lock.</p>
</section>
<section id="euler-angles-to-quaternion">
<h3><span class="section-number">10.2.2. </span>Euler angles to quaternion<a class="headerlink" href="#euler-angles-to-quaternion" title="Permalink to this heading">#</a></h3>
<p>Quaternions can be thought of as a orientation in 4D space. Imagine a camera in the world space that is pointing in a particular direction. The direction in which the camera is pointing can be described with reference to the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> axes in terms of the pitch, yaw and roll Euler angles.</p>
<p>Given the three Euler angles pitch, yaw and roll then using the abbreviations</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    c_p &amp;= \cos(\tfrac{1}{2}\mathsf{pitch}), &amp;
    s_p &amp;= \sin(\tfrac{1}{2}\mathsf{pitch}), \\
    c_y &amp;= \cos(\tfrac{1}{2}\mathsf{yaw}), &amp;
    s_y &amp;= \sin(\tfrac{1}{2}\mathsf{yaw}), \\
    c_r &amp;= \cos(\tfrac{1}{2}\mathsf{roll}), &amp;
    s_r &amp;= \sin(\tfrac{1}{2}\mathsf{roll}),
\end{align*} \end{split}\]</div>
<p>the quaternion that represents the camera orientation is</p>
<div class="math notranslate nohighlight" id="equation-euler-to-quaternion-equation">
<span class="eqno">(10.3)<a class="headerlink" href="#equation-euler-to-quaternion-equation" title="Permalink to this equation">#</a></span>\[ q = [c_pc_yc_r - s_ps_ys_r, (s_pc_yc_r + c_ps_ys_r, c_ps_yc_r - s_pc_ys_r, c_pc_ys_r - s_ps_yc_r)]. \]</div>
<p>See <a class="reference internal" href="A_Complex_numbers_and_quaternions.html#euler-to-quaternion-derivation-section"><span class="std std-ref">Appendix: Euler angles to quaternion</span></a> for the derivation of this equation. We are going to add a member function to convert from Euler angles to the rotation quaternion. Add the following to the <code class="docutils literal notranslate"><span class="pre">Quaternion</span></code> data structure declaration in <code class="docutils literal notranslate"><span class="pre">maths.hpp</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">eulerToQuat</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">yaw</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">roll</span><span class="p">);</span>
</pre></div>
</div>
<p>and in the <code class="docutils literal notranslate"><span class="pre">maths.cpp</span></code> define the <code class="docutils literal notranslate"><span class="pre">eulerToQuat()</span></code> method</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Euler angles to quaternion</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Quaternion::eulerToQuat</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">yaw</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">roll</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cr</span><span class="p">,</span><span class="w"> </span><span class="n">cp</span><span class="p">,</span><span class="w"> </span><span class="n">cy</span><span class="p">,</span><span class="w"> </span><span class="n">sr</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span><span class="p">,</span><span class="w"> </span><span class="n">sy</span><span class="p">;</span>
<span class="w">    </span><span class="n">cr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">roll</span><span class="p">);</span>
<span class="w">    </span><span class="n">cp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pitch</span><span class="p">);</span>
<span class="w">    </span><span class="n">cy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">yaw</span><span class="p">);</span>
<span class="w">    </span><span class="n">sr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="mf">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">roll</span><span class="p">);</span>
<span class="w">    </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="mf">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pitch</span><span class="p">);</span>
<span class="w">    </span><span class="n">sy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="mf">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">yaw</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">Quaternion</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="w">    </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cy</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sy</span><span class="p">;</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sy</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sy</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cy</span><span class="p">;</span>
<span class="w">    </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sy</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can now calculate the quaternion for the orientation given by the pitch, yaw and roll Euler angles using <code class="docutils literal notranslate"><span class="pre">q.eulerToQuat()</span></code>.</p>
<p>We currently using Euler angles rotation to calculate the <code class="docutils literal notranslate"><span class="pre">view</span></code> matrix in the <code class="docutils literal notranslate"><span class="pre">calculateMatrices()</span></code> Camera class function. As such our camera may suffer from gimbal lock and it also does not allow us to move the camera through 90<span class="math notranslate nohighlight">\(^\circ\)</span> or 270<span class="math notranslate nohighlight">\(^\circ\)</span> (try looking at the cubes from directly above or below and you will notice the orientation suddenly flipping around). So it would be advantageous to use quaternion rotations to calculate the <code class="docutils literal notranslate"><span class="pre">view</span></code> matrix.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/09_Camera_without_quaternion.mp4" type="video/mp4">
</video>
</center>
<p>First we need to add an attribute to the Camera class for the quaternion that describes the direction which the camera is looking. In <code class="docutils literal notranslate"><span class="pre">camera.hpp</span></code> add the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Direction quaternion</span>
<span class="n">Quaternion</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
</pre></div>
</div>
<p>Then in the <code class="docutils literal notranslate"><span class="pre">camera.cpp</span></code> file, comment out the lines where we update the camera vectors and the line where we call the <code class="docutils literal notranslate"><span class="pre">glm::lookAt()</span></code> function and add the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate direction quaternion</span>
<span class="n">direction</span><span class="p">.</span><span class="n">eulerToQuat</span><span class="p">(</span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="n">yaw</span><span class="p">,</span><span class="w"> </span><span class="n">roll</span><span class="p">);</span>
<span class="w">    </span>
<span class="c1">// Calculate view matrix</span>
<span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">direction</span><span class="p">.</span><span class="n">quatToMat</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="o">-</span><span class="n">position</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we calculate the translation matrix to move the camera to (0,0,0) and then multiply it by the quaternion rotation matrix. Of course we need the <span class="math notranslate nohighlight">\(\tt right\)</span>, <span class="math notranslate nohighlight">\(\tt up\)</span> and <span class="math notranslate nohighlight">\(\tt front\)</span> camera vectors to move the camera, these can be easily obtained from the first three rows and columns of the <code class="docutils literal notranslate"><span class="pre">view</span></code> matrix. Add the following code after you have calculated the <code class="docutils literal notranslate"><span class="pre">view</span></code> matrix.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Update camera vectors</span>
<span class="n">right</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">view</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">right</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">view</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">right</span><span class="p">.</span><span class="n">z</span><span class="w">  </span><span class="o">=</span><span class="w">  </span><span class="n">view</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="n">up</span><span class="p">.</span><span class="n">x</span><span class="w">    </span><span class="o">=</span><span class="w">  </span><span class="n">view</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">up</span><span class="p">.</span><span class="n">y</span><span class="w">    </span><span class="o">=</span><span class="w">  </span><span class="n">view</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">up</span><span class="p">.</span><span class="n">z</span><span class="w">     </span><span class="o">=</span><span class="w">  </span><span class="n">view</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
<span class="n">front</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">view</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">front</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">view</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">front</span><span class="p">.</span><span class="n">z</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">view</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
<p>Compile and run the code and you will see that you can move the camera in any orientation and we can move the camera through 90<span class="math notranslate nohighlight">\(^\circ\)</span> or 270<span class="math notranslate nohighlight">\(^\circ\)</span> without the orientation flipping around.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/09_Camera_with_quaternion.mp4" type="video/mp4">
</video>
</center>
<p>We are only using pitch and yaw Euler angles for our camera, lets add the ability to roll that camera as well (like a flight simulator). Where we get the keyboard input to move the camera add the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_KEY_Q</span><span class="p">))</span>
<span class="w">  </span><span class="n">roll</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mf">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">deltaTime</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">speed</span><span class="p">;</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_KEY_E</span><span class="p">))</span>
<span class="w">  </span><span class="n">roll</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">deltaTime</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">speed</span><span class="p">;</span>
</pre></div>
</div>
<p>You probably are able to work out that pressing the Q and E keys decreases or increases the roll angle respectively. Run the code and you will now be able to roll the camera!</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/09_Camera_roll.mp4" type="video/mp4">
</video>
</center>
</section>
</section>
<section id="third-person-camera">
<h2><span class="section-number">10.3. </span>Third person camera<a class="headerlink" href="#third-person-camera" title="Permalink to this heading">#</a></h2>
<p>The use of quaternions allows game developers to implement third person camera view in 3D games where the camera follows the character that the player is controlling. This was first done for the Playstation game <em>Tomb Raider</em> released by Core Design in 1996 and has become popular with game developers with game franchises such as <em>God of War</em>, <em>Horizon Zero Dawn</em>, <em>Assassins Creed</em> and <em>Red Dead Redemption</em> to name a few all using third person camera view.</p>
<p>To implement a simple third person camera we are going to calculate the <code class="docutils literal notranslate"><span class="pre">view</span></code> matrix as usual and then move the camera back by an <span class="math notranslate nohighlight">\(\tt offset\)</span> vector which is a vector pointing from the actual camera position to the third person camera position <a class="reference internal" href="#third-person-camera-figure"><span class="std std-numref">Fig. 10.6</span></a>.</p>
<figure class="align-default" id="third-person-camera-figure">
<a class="reference internal image-reference" href="../_images/10_Third_person_camera.svg"><img alt="../_images/10_Third_person_camera.svg" src="../_images/10_Third_person_camera.svg" width="400" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.6 </span><span class="caption-text">A third person camera.</span><a class="headerlink" href="#third-person-camera-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>For our third person camera, the direction that the character is facing will be controlled by keyboard inputs where the W and S keys move the character forward and backwards and the A and D keys rotate it to the left and right. In <code class="docutils literal notranslate"><span class="pre">camera.hpp</span></code> add the following attributes to the Camera class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Third person camera</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;first&quot;</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">charYaw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="n">Quaternion</span><span class="w"> </span><span class="n">charDirection</span><span class="p">;</span>
</pre></div>
</div>
<p>These attributes are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">offset</span></code> - the vector pointing from the character position to the third person camera</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mode</span></code> - a string to record whether the camera is in first or third person mode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">charYaw</span></code> - the yaw angle for the character</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">charDirection</span></code> - a quaternion for the direction which the character is facing</p></li>
</ul>
<p>Also in <code class="docutils literal notranslate"><span class="pre">camera.hpp</span></code> add a declaration for the third person camera method</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">thirdPersonCamera</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="n">const</span> <span class="nb">float</span> <span class="n">deltaTime</span><span class="p">);</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">camera.cpp</span></code> add the following method definition</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Camera::thirdPersonCamera</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="w"> </span><span class="o">*</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">deltaTime</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">thirdPersonCamera()</span></code> method will be quite similar to the <code class="docutils literal notranslate"><span class="pre">calculateMatrices()</span></code> method so copy and paste the code from there into <code class="docutils literal notranslate"><span class="pre">thirdPersonCamera()</span></code>. We want the A and D keys to control the yaw angle for the character so edit your code so it looks like the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_KEY_A</span><span class="p">))</span>
<span class="w">    </span><span class="n">charYaw</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mf">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">deltaTime</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">speed</span><span class="p">;</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_KEY_D</span><span class="p">))</span>
<span class="w">    </span><span class="n">charYaw</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">deltaTime</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">speed</span><span class="p">;</span>
</pre></div>
</div>
<p>The third person camera is moved back from the character position by translating the <code class="docutils literal notranslate"><span class="pre">view</span></code> matrix by the <code class="docutils literal notranslate"><span class="pre">offset</span></code> vector. Change the <code class="docutils literal notranslate"><span class="pre">view</span></code> matrix calculation to the following</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="o">-</span><span class="n">offset</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">direction</span><span class="p">.</span><span class="n">quatToMat</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="o">-</span><span class="n">position</span><span class="p">);</span>
</pre></div>
</div>
<p>The last change we need to make to our third person camera method is to move the character based on the character direction quaternion and not the camera direction quaternion. Replace the code used to update the camera vectors with the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Update character movement vectors</span>
<span class="n">charDirection</span><span class="p">.</span><span class="n">eulerToQuat</span><span class="p">(</span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="n">charYaw</span><span class="p">,</span><span class="w"> </span><span class="n">roll</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">charMat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">charDirection</span><span class="p">.</span><span class="n">quatToMat</span><span class="p">();</span>
<span class="n">right</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">charMat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">right</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">charMat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">right</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">charMat</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="n">up</span><span class="p">.</span><span class="n">x</span><span class="w">    </span><span class="o">=</span><span class="w">  </span><span class="n">charMat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">up</span><span class="p">.</span><span class="n">y</span><span class="w">    </span><span class="o">=</span><span class="w">  </span><span class="n">charMat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">up</span><span class="p">.</span><span class="n">z</span><span class="w">    </span><span class="o">=</span><span class="w">  </span><span class="n">charMat</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
<span class="n">front</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">charMat</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">front</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">charMat</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">front</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">charMat</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
<p>We now need a way to instruct our programme whether to use the first or third person camera. In <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> add the following code before we calculate the <code class="docutils literal notranslate"><span class="pre">view</span></code> and <code class="docutils literal notranslate"><span class="pre">projection</span></code> matrices.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Toggle between first and third person camera</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_KEY_1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;third&quot;</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;first&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">yaw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">charYaw</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_KEY_2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;first&quot;</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;third&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">charYaw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">yaw</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we using the 1 to select first person camera and the 2 key to select the third person camera. When switch from first person to third person camera the character yaw angle is set to the camera yaw angle so the character is facing in the correct direction. This is reversed when switching from the third to first person camera so the first person camera is facing the direction of the character.</p>
<p>We now instruct the program to use the appropriate method for calculating the <code class="docutils literal notranslate"><span class="pre">view</span></code> and <code class="docutils literal notranslate"><span class="pre">projection</span></code> matrices.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate view and projection matrices</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;first&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">calculateMatrices</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">deltaTime</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;third&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">thirdPersonCamera</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">deltaTime</span><span class="p">);</span>

<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">getViewMatrix</span><span class="p">();</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">projection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">getProjectionMatrix</span><span class="p">();</span>
</pre></div>
</div>
<p>Of course when using the third person camera we need to render the character model. Add the following code after you have drawn all of the cubes.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Draw suzanne model in third person camera mode</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;third&quot;</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Calculate model matrix</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2f</span><span class="p">));</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">transpose</span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">charDirection</span><span class="p">.</span><span class="n">quatToMat</span><span class="p">());</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Send the model matrix to the shader</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;model&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Draw the model</span>
<span class="w">    </span><span class="n">suzanne</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">shaderID</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we are using Suzanne the Blender mascot to act as our character model. The <code class="docutils literal notranslate"><span class="pre">model</span></code> matrix is calculated by translating Suzanne to the camera position (this is actually our character position as the camera has been offset) and an inverse of the <code class="docutils literal notranslate"><span class="pre">charDirection</span></code> matrix is used to rotate the model so it is facing in the right direction. Since the <code class="docutils literal notranslate"><span class="pre">charDirection</span></code> matrix is orthogonal (the columns vectors are all at right angles) this can be done using the transpose of the matrix which is much quicker than calculating an inverse of a matrix.</p>
<p>Compile and run the program and you should be able to switch between the camera modes using the 1 and 2 keys.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/09_Third_person_camera_no_SLERP.mp4" type="video/mp4">
</video>
</center>
</section>
<hr class="docutils" />
<section id="slerp">
<h2><span class="section-number">10.4. </span>SLERP<a class="headerlink" href="#slerp" title="Permalink to this heading">#</a></h2>
<p>The another advantage that quaternions have over Euler angles is that we can interpolate between two orientations smoothly and without encountering the problem of gimble lock. Standard Linear intERPolation (LERP) is used to calculate an intermediate position on the straight line between two points.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/10_Linear_interpolation.svg"><img alt="../_images/10_Linear_interpolation.svg" src="../_images/10_Linear_interpolation.svg" width="400" /></a>
</figure>
<p>If <span class="math notranslate nohighlight">\(\mathbf{p}_1\)</span> and <span class="math notranslate nohighlight">\(\mathbf{p}_2\)</span> are two points then an interpolated point <span class="math notranslate nohighlight">\(\mathbf{p}_t\)</span> is calculated using</p>
<div class="math notranslate nohighlight">
\[ \operatorname{LERP}(\mathbf{p}_1, \mathbf{p}_2, t) = \mathbf{p}_1 + t(\mathbf{p}_2 - \mathbf{p}_1), \]</div>
<p>where <span class="math notranslate nohighlight">\(t\)</span> is a value between 0 and 1. <strong>SLERP</strong> stands for Spherical Linear intERPpolation and is a method used to interpolate between two orientations emanating from the centre of a sphere.</p>
<figure class="align-default" id="a-slerp-figure">
<a class="reference internal image-reference" href="../_images/10_SLERP.svg"><img alt="../_images/10_SLERP.svg" src="../_images/10_SLERP.svg" width="400" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.7 </span><span class="caption-text">SLERP interpolation between two points on a sphere.</span><a class="headerlink" href="#a-slerp-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Consider <a class="reference internal" href="#a-slerp-figure"><span class="std std-numref">Fig. 10.7</span></a> where <span class="math notranslate nohighlight">\(q_1\)</span> and <span class="math notranslate nohighlight">\(q_2\)</span> are two quaternions emanating from the centre of a sphere (note that this diagram is a bit misleading as quaternions exist in 4 dimensions but since its very difficult to visualize 4D on a 2D screen this will have to do). The interpolated quaternion <span class="math notranslate nohighlight">\(q_t\)</span> represents another quaternion that is partway between <span class="math notranslate nohighlight">\(q_1\)</span> and <span class="math notranslate nohighlight">\(q_2\)</span> calculated using</p>
<div class="math notranslate nohighlight" id="equation-slerp-equation">
<span class="eqno">(10.4)<a class="headerlink" href="#equation-slerp-equation" title="Permalink to this equation">#</a></span>\[ \begin{align*}
    \operatorname{SLERP}(q_1, q_2, t) = \frac{\sin((1-t) \theta)}{\sin(\theta)}q_1 + \frac{\sin(t\theta)}{\sin(\theta)}q_2
\end{align*}, \]</div>
<p>where <span class="math notranslate nohighlight">\(t\)</span> is a value between 0 and 1 and <span class="math notranslate nohighlight">\(\theta\)</span> is the angle between the two pure quaternions <span class="math notranslate nohighlight">\(q_1\)</span> and <span class="math notranslate nohighlight">\(q_2\)</span> and is calculated using</p>
<div class="math notranslate nohighlight">
\[ \theta = \cos^{-1} \left( \frac{q_1 \cdot q_2}{|q_1||q_2|} \right).\]</div>
<p>Sometimes the to product <span class="math notranslate nohighlight">\(q_1 \cdot q_2\)</span> returns a negative result meaning that <span class="math notranslate nohighlight">\(\theta\)</span> we will be interpolating the long way round the sphere. To overcome this we negate the values of one of the quaternions, this is fine since the quaternion <span class="math notranslate nohighlight">\(-q\)</span> is the same orientation as <span class="math notranslate nohighlight">\(q\)</span>.</p>
<p>Another consideration is when <span class="math notranslate nohighlight">\(\theta\)</span> is very small then <span class="math notranslate nohighlight">\(\sin(\theta)\)</span> in equation <a class="reference internal" href="#equation-slerp-equation">(10.4)</a> can be rounded to zero causing a divide by zero error. To get around this we can use LERP between <span class="math notranslate nohighlight">\(q_1\)</span> and <span class="math notranslate nohighlight">\(q_2\)</span>.</p>
<p>Add a method declaration to the Maths class in the <code class="docutils literal notranslate"><span class="pre">maths.hpp</span></code> file</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">Quaternion</span><span class="w"> </span><span class="nf">slerp</span><span class="p">(</span><span class="n">Quaternion</span><span class="w"> </span><span class="n">q1</span><span class="p">,</span><span class="w"> </span><span class="n">Quaternion</span><span class="w"> </span><span class="n">q2</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="p">);</span>
</pre></div>
</div>
<p>and define the method in the <code class="docutils literal notranslate"><span class="pre">maths.cpp</span></code> file</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// SLERP</span>
<span class="n">Quaternion</span><span class="w"> </span><span class="nf">Maths::slerp</span><span class="p">(</span><span class="n">Quaternion</span><span class="w"> </span><span class="n">q1</span><span class="p">,</span><span class="w"> </span><span class="n">Quaternion</span><span class="w"> </span><span class="n">q2</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Check if we are going the &quot;long&quot; way around the sphere</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">q1DotQ2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q1</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q2</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q2</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q2</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q1</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q2</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">q1DotQ2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Change signs of q2 to ensure we go the short way round</span>
<span class="w">        </span><span class="n">q2</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="o">-</span><span class="n">q2</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
<span class="w">        </span><span class="n">q2</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="o">-</span><span class="n">q2</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="n">q2</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="o">-</span><span class="n">q2</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">        </span><span class="n">q2</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="o">-</span><span class="n">q2</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">        </span><span class="n">q1DotQ2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">q1DotQ2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Calculate angle between quaternions q1 and q2</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">theta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">acos</span><span class="p">(</span><span class="n">q1DotQ2</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Calculate interpolated quaternion qt</span>
<span class="w">    </span><span class="n">Quaternion</span><span class="w"> </span><span class="n">qt</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">denom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">denom</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.001f</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Use SLERP</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">fact1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">((</span><span class="mf">1.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">theta</span><span class="p">);</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">fact2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">theta</span><span class="p">);</span>
<span class="w">        </span><span class="n">qt</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fact1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q1</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fact2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q2</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
<span class="w">        </span><span class="n">qt</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fact1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fact2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q2</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="n">qt</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fact1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fact2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q2</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">        </span><span class="n">qt</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fact1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q1</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fact2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q2</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Use LERP if sin(theta) is small</span>
<span class="w">        </span><span class="n">qt</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q1</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q2</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
<span class="w">        </span><span class="n">qt</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q2</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="n">qt</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q2</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">        </span><span class="n">qt</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q1</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q2</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">qt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then to apply SLERP replace the code used to calculate the <code class="docutils literal notranslate"><span class="pre">direction</span></code> quaternion with the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate direction quaternion</span>
<span class="n">Quaternion</span><span class="w"> </span><span class="n">newDirection</span><span class="p">;</span>
<span class="n">newDirection</span><span class="p">.</span><span class="n">eulerToQuat</span><span class="p">(</span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="n">yaw</span><span class="p">,</span><span class="w"> </span><span class="n">roll</span><span class="p">);</span>
<span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">slerp</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span><span class="w"> </span><span class="n">newDirection</span><span class="p">,</span><span class="w"> </span><span class="n">deltaTime</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we use a temporary quaternion <code class="docutils literal notranslate"><span class="pre">newDirection</span></code> which is calculated using the pitch, yaw and roll Euler angles of the camera and then used SLERP to interpolate between <code class="docutils literal notranslate"><span class="pre">direction</span></code> and <code class="docutils literal notranslate"><span class="pre">newDirection</span></code>. Compile and run your program and you should see that the third person camera now rotates smoothly around the character.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/09_Third_person_camera_with_SLERP.mp4" type="video/mp4">
</video>
</center>
</section>
<hr class="docutils" />
<section id="source-code">
<h2><span class="section-number">10.5. </span>Source code<a class="headerlink" href="#source-code" title="Permalink to this heading">#</a></h2>
<p>The source code for this lab, including the exercise solutions, can be downloaded using the links below.</p>
<ul class="simple">
<li><p><span class="xref myst">main.cpp</span></p></li>
<li><p><span class="xref myst">camera.hpp</span></p></li>
<li><p><span class="xref myst">camera.cpp</span></p></li>
<li><p><span class="xref myst">maths.hpp</span></p></li>
<li><p><span class="xref myst">maths.cpp</span></p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="09_Normal_mapping.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">9. </span>Normal Mapping</p>
      </div>
    </a>
    <a class="right-next"
       href="A_Complex_numbers_and_quaternions.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">A. Complex Numbers and Quaternions</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#complex-numbers">10.1. Complex Numbers</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rotation-using-complex-numbers">10.1.1. Rotation using complex numbers</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">10.2. Quaternions</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quaternion-rotations">10.2.1. Quaternion rotations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#euler-angles-to-quaternion">10.2.2. Euler angles to quaternion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#third-person-camera">10.3. Third person camera</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#slerp">10.4. SLERP</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">10.5. Source code</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dr Jon Shiach
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>