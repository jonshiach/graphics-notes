

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>5. Transformations &#8212; Computer Graphics</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"model": ["M\\!odel"], "view": ["V\\!iew"], "mvp": ["MV\\!P"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/05_transformations';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6. 3D Worlds" href="06_3D_worlds.html" />
    <link rel="prev" title="4. Vectors and Matrices" href="04_vectors_and_matrices.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Computer Graphics
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_intro_to_cpp.html">1. Introduction to C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_basic_shapes_in_OpenGL.html">2. Basic Shapes in OpenGL</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_textures.html">3. Textures</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_vectors_and_matrices.html">4. Vectors and Matrices</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">5. Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_3D_worlds.html">6. 3D Worlds</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_Moving_the_camera.html">7. Moving the camera</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_Lighting.html">8. Lighting</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_Normal_mapping.html">9. Normal Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_Quaternions.html">10. Quaternions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="A_Complex_numbers_and_quaternions.html">Complex Numbers and Quaternions</a></li>
<li class="toctree-l1"><a class="reference internal" href="C_Glossary.html">Glossary</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs/issues/new?title=Issue%20on%20page%20%2F_pages/05_transformations.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/_pages/05_transformations.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Transformations</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#translation">5.1. Translation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#translation-in-opengl">5.1.1. Translation in OpenGL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-maths-class">5.2. A Maths class</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#scaling">5.3. Scaling</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rotation">5.4. Rotation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rotation-in-opengl">5.4.1. Rotation in OpenGL</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axis-angle-rotation">5.4.2. Axis-angle rotation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axis-angle-rotation-in-opengl">5.4.3. Axis-angle rotation in OpenGL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#composite-transformations">5.5. Composite transformations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#composite-transformations-in-opengl">5.5.1. Composite transformations in OpenGL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#animating-the-rectangle">5.6. Animating the rectangle</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">5.7. Exercises</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="transformations">
<span id="transformations-section"></span><h1><span class="section-number">5. </span>Transformations<a class="headerlink" href="#transformations" title="Permalink to this heading">#</a></h1>
<p>Computer graphics requires that shapes are manipulated in space by moving the shapes, shrinking or stretching, rotating and reflection to name a few. We call these manipulations <strong>transformations</strong>. We need a convenient way of telling the computer how to apply our transformations and for this we make use of matrices which we covered in the previous lab on <a class="reference internal" href="04_vectors_and_matrices.html#vectors-and-matrices-section"><span class="std std-ref">vectors and matrices</span></a>.</p>
<p>Each transformation has an associated <strong>transformation matrix</strong> which we use to multiply the vertex co-ordinates of a shape to calculate the vertex co-ordinates of the transformed shape. For example if <span class="math notranslate nohighlight">\(A\)</span> is a transformation matrix for a particular transformation and <span class="math notranslate nohighlight">\((x,y,z)\)</span> are the co-ordinates of a vertex then we apply the transformation using</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{pmatrix} x' \\ y' \\ x' \end{pmatrix} = A \cdot \begin{pmatrix} x \\ y \\ z \end{pmatrix}, \end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\((x',y',z')\)</span> are the co-ordinates of the transformed point. Note that all vectors and co-ordinates are written as a column vector when multiplying by a matrix.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The co-ordinate system used by OpenGL is a <a href="https://en.wikipedia.org/wiki/Right-hand_rule" target="_blank">right-hand</a> 3D co-ordinate system (on your right hand the thumb represents the <span class="math notranslate nohighlight">\(x\)</span>-axis, the index finger the <span class="math notranslate nohighlight">\(y\)</span>-axis and the middle finger the <span class="math notranslate nohighlight">\(z\)</span>-axis) with the <span class="math notranslate nohighlight">\(x\)</span>-axis pointing to the right, the <span class="math notranslate nohighlight">\(y\)</span>-axis point upwards and the <span class="math notranslate nohighlight">\(z\)</span>-axis pointing out of the screen towards the user (<a class="reference internal" href="#opengl-co-ordinate-figure"><span class="std std-numref">Fig. 5.1</span></a>).</p>
<figure class="align-default" id="opengl-co-ordinate-figure">
<a class="reference internal image-reference" href="../_images/05_opengl_axes.svg"><img alt="../_images/05_opengl_axes.svg" src="../_images/05_opengl_axes.svg" width="250" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.1 </span><span class="caption-text">The OpenGL co-ordinate system.</span><a class="headerlink" href="#opengl-co-ordinate-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
<section id="translation">
<span id="translation-section"></span><h2><span class="section-number">5.1. </span>Translation<a class="headerlink" href="#translation" title="Permalink to this heading">#</a></h2>
<p>The <strong>translation</strong> transformation when applied to a set of points moves each point by the same amount. For example, consider the triangle in <a class="reference internal" href="#translation-figure"><span class="std std-numref">Fig. 5.2</span></a>, each of the vertices has been translated by the same vector <span class="math notranslate nohighlight">\(\mathbf{t}\)</span> which has that effect of moving the triangle.</p>
<figure class="align-default" id="translation-figure">
<a class="reference internal image-reference" href="../_images/05_translation.svg"><img alt="../_images/05_translation.svg" height="280" src="../_images/05_translation.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.2 </span><span class="caption-text">Translation of a triangle by the translation vector <span class="math notranslate nohighlight">\(\mathbf{t}= (t_x, t_y, t_z)\)</span>.</span><a class="headerlink" href="#translation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>A problem we have is that no transformation matrix exists for applying translation to the co-ordinates <span class="math notranslate nohighlight">\((x, y, z)\)</span>, i.e., we can’t find a matrix <span class="math notranslate nohighlight">\(Translate\)</span> such that</p>
<div class="math notranslate nohighlight">
\[\begin{split}Translate \cdot \begin{pmatrix} x  \\ y \\ z \end{pmatrix} = \begin{pmatrix} x + t_x \\ y + t_y \\ z + t_z \end{pmatrix}.\end{split}\]</div>
<p id="homogeneous-coordinates-section">We can use a trick where we use <a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates" target="_blank"><strong>homogeneous co-ordinates</strong></a>. Homogeneous co-ordinates add another value, <span class="math notranslate nohighlight">\(w\)</span> say, to the <span class="math notranslate nohighlight">\((x, y, z)\)</span> co-ordinates (known as Cartesian co-ordinates) such that when the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> values are divided by <span class="math notranslate nohighlight">\(w\)</span> we get the Cartesian co-ordinates.</p>
<div class="math notranslate nohighlight">
\[\underbrace{(x, y, z, w)}_{\textsf{homogeneous}} \equiv \underbrace{\left( \frac{x}{w}, \frac{y}{w}, \frac{z}{w} \right)}_{\textsf{Cartesian}}.\]</div>
<p>So if we choose <span class="math notranslate nohighlight">\(w=1\)</span> then we can write the Cartesian co-ordinates <span class="math notranslate nohighlight">\((x, y, z)\)</span> as the homogeneous co-ordinates <span class="math notranslate nohighlight">\((x, y, z, 1)\)</span> (remember that 4-element vector with the additional 1 in our <a class="reference internal" href="02_basic_shapes_in_OpenGL.html#vertex-shader-section"><span class="std std-ref">vertex shader</span></a>?). So how does that help us with our elusive translation matrix? Well we can now represent translation as a <span class="math notranslate nohighlight">\(4 \times 4\)</span> matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; t_x \\
        0 &amp; 1 &amp; 0 &amp; t_y \\
        0 &amp; 0 &amp; 1 &amp; t_z \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}
   \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix}
    =
   \begin{pmatrix} x + t_x \\ y + t_y \\ z + t_z \\ 1 \end{pmatrix},
\end{align*}\end{split}\]</div>
<p>which is our desired translation. So the <strong>translation matrix</strong> for translating a set of points by the vector <span class="math notranslate nohighlight">\(\mathbf{t} = (t_x, t_y, t_z)\)</span> is</p>
<div class="math notranslate nohighlight" id="equation-eq-translation-matrix">
<span class="eqno">(5.1)<a class="headerlink" href="#equation-eq-translation-matrix" title="Permalink to this equation">#</a></span>\[\begin{split} Translate = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; t_x \\
    0 &amp; 1 &amp; 0 &amp; t_y \\
    0 &amp; 0 &amp; 1 &amp; t_z \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}. \end{split}\]</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Recall that OpenGL and glm use <a class="reference internal" href="04_vectors_and_matrices.html#column-major-order-section"><span class="std std-ref">column-major order</span></a>, so when coding transformation matrices into C++ we need to code the transpose of the matrix. So the translation matrix we are going to use is</p>
<div class="math notranslate nohighlight">
\[\begin{split} Translate = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    t_x &amp; t_y &amp; t_z &amp; 1
\end{pmatrix}.\end{split}\]</div>
</div>
<section id="translation-in-opengl">
<h3><span class="section-number">5.1.1. </span>Translation in OpenGL<a class="headerlink" href="#translation-in-opengl" title="Permalink to this heading">#</a></h3>
<p>Now we know the mathematical theory behind applying a transformation lets apply it to OpenGL. Compile and run the <strong>Lab05_Transformations</strong> project and you should be presented with a rectangle textured with our old friend Mario as shown in <a class="reference internal" href="#texture-rectangle-mario-figure"><span class="std std-numref">Fig. 5.3</span></a>.</p>
<figure class="align-default" id="texture-rectangle-mario-figure">
<a class="reference internal image-reference" href="../_images/05_mario.png"><img alt="../_images/05_mario.png" src="../_images/05_mario.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.3 </span><span class="caption-text">A textured rectangle from the lab on <a class="reference internal" href="03_textures.html#textures-section"><span class="std std-ref">textures</span></a>.</span><a class="headerlink" href="#texture-rectangle-mario-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Lets translate the rectangle <span class="math notranslate nohighlight">\(0.4\)</span> to the right and <span class="math notranslate nohighlight">\(0.3\)</span> upwards (remember we are dealing with normalised device co-ordinates so the window co-ordinates are between <span class="math notranslate nohighlight">\(-1\)</span> and <span class="math notranslate nohighlight">\(1\)</span>). The transposed transformation matrix to perform this translation is</p>
<div class="math notranslate nohighlight">
\[\begin{split} Translate = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0.4 &amp; 0.3 &amp; 0 &amp; 1
\end{pmatrix}. \end{split}\]</div>
<p>In the <strong>Lab05_Transformations.cpp</strong> enter the following code just before we draw the triangles in the render loop.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define the translation matrix</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="p">;</span>
<span class="n">translate</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.4f</span><span class="p">,</span><span class="w"> </span><span class="n">translate</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="n">translate</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
</pre></div>
</div>
<p>We need a way of passing the <code class="docutils literal notranslate"><span class="pre">translate</span></code> matrix to the shader. We do this using a <a href="https://www.khronos.org/opengl/wiki/Uniform_(GLSL)" target="_blank">uniform</a> like we did in the lab on <a class="reference internal" href="03_textures.html#uniforms-section"><span class="std std-ref">texture maps</span></a>. Add the following code after we have defined the translation matrix.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send the transformation matrix to the shader</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="p">;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">transformationID</span><span class="p">;</span>
<span class="n">transformationID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;transformation&quot;</span><span class="p">);</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">transformationID</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">transformation</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
<p>Here we have created another matrix called <code class="docutils literal notranslate"><span class="pre">transformation</span></code> and copied the <code class="docutils literal notranslate"><span class="pre">translate</span></code> matrix into it (we have done this because we will be combining different transformations into a single matrix later). Then after getting the location of the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> uniform using the <code class="docutils literal notranslate"><span class="pre">glGetUniformatLocation()</span></code> function we send a reference to the first element of the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> matrix to the shaders using <code class="docutils literal notranslate"><span class="pre">glUniformMatrix4fv()</span></code> function.</p>
<p>All we now have to do is modify the vertex shader to use the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> matrix.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="c1">// Inputs</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>

<span class="c1">// Outputs</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">UV</span><span class="p">;</span>

<span class="c1">// Uniforms</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">transformation</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Output vertex position</span>
<span class="w">    </span><span class="n">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Output texture co-ordinates</span>
<span class="w">    </span><span class="n">UV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The changes we have made here is to specify that we are passing the transformation matrix via a uniform and we multiply the homogeneous co-ordinates of the vertex position by this matrix. Compile and run the program and you should see that our rectangle has been translated to the right and up a bit as shown in <a class="reference internal" href="#translate-rectangle-figure"><span class="std std-numref">Fig. 5.4</span></a>.</p>
<figure class="align-default" id="translate-rectangle-figure">
<a class="reference internal image-reference" href="../_images/05_translation.png"><img alt="../_images/05_translation.png" src="../_images/05_translation.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.4 </span><span class="caption-text">A rectangle translated by the vector <span class="math notranslate nohighlight">\((0.4, 0.3, 0)\)</span>.</span><a class="headerlink" href="#translate-rectangle-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
</section>
<hr class="docutils" />
<section id="a-maths-class">
<h2><span class="section-number">5.2. </span>A Maths class<a class="headerlink" href="#a-maths-class" title="Permalink to this heading">#</a></h2>
<p>Whilst it wasn’t particularly difficult to define the translation matrix, we may be doing this often so it makes sense to write a function to do this. Since we will also have other types of transformations we will create a <code class="docutils literal notranslate"><span class="pre">Maths</span></code> class to contain all of these function. If you open the <strong>maths.hpp</strong> file in the <strong>Lab05_Transformations</strong> project folder you will see that it is currently empty. Enter the following code to create a <code class="docutils literal notranslate"><span class="pre">Maths</span></code> class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glm/glm.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glm/gtx/io.hpp&gt;</span>

<span class="c1">// Maths class</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Maths</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Transformation matrices</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here we include the <code class="docutils literal notranslate"><span class="pre">iostream</span></code>, <code class="docutils literal notranslate"><span class="pre">cmath</span></code> and <code class="docutils literal notranslate"><span class="pre">glm</span></code> libraries before declaring our <code class="docutils literal notranslate"><span class="pre">Maths</span></code> class. We have also declared the method <code class="docutils literal notranslate"><span class="pre">translate()</span></code> that has a single input of a <code class="docutils literal notranslate"><span class="pre">glm::vec3</span></code> object.</p>
<p>In the <strong>maths.cpp</strong> file enter the following method definition.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;common/maths.hpp&gt;</span>

<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="nf">Maths::translate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">translate</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">translate</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">translate</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">translate</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You will notice this is similar to the <code class="docutils literal notranslate"><span class="pre">translate</span></code> matrix we defined in the main program. We can now use this method to calculate any translation matrix. Comment out the code we used to define the <code class="docutils literal notranslate"><span class="pre">translate</span></code> matrix in the main program and enter the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.4f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">));</span>
</pre></div>
</div>
<p>Running the program you should see no change to the output but we can now easily define translation matrices. Experiment with different values for the translation vector to see the effects it has.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You may have noticed that in our <code class="docutils literal notranslate"><span class="pre">translate()</span></code> function we accessed the first three elements of the glm vector <code class="docutils literal notranslate"><span class="pre">v</span></code> using <code class="docutils literal notranslate"><span class="pre">v.x</span></code>, <code class="docutils literal notranslate"><span class="pre">v.y</span></code> and <code class="docutils literal notranslate"><span class="pre">v.z</span></code> instead of <code class="docutils literal notranslate"><span class="pre">v[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">v[1]</span></code> and <code class="docutils literal notranslate"><span class="pre">v[2]</span></code>. This is called <em>swizzling</em> and can also be used in GLSL vector objects.</p>
</div>
</section>
<hr class="docutils" />
<section id="scaling">
<h2><span class="section-number">5.3. </span>Scaling<a class="headerlink" href="#scaling" title="Permalink to this heading">#</a></h2>
<p>Scaling is one of the simplest transformation we can apply. Multiplying the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> co-ordinates of a point by a scalar quantity (a number) has the effect of moving the point closer or further away from the origin (0,0). For example, consider the triangle in <a class="reference internal" href="#scaling-about-origin-figure"><span class="std std-numref">Fig. 5.5</span></a>. The <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> co-ordinates of each vertex has been multiplied by <span class="math notranslate nohighlight">\(s_x\)</span>, <span class="math notranslate nohighlight">\(s_y\)</span> and <span class="math notranslate nohighlight">\(s_y\)</span> respectively which has the effect of scaling the triangle and moving the vertices further away from the origin (in this case because <span class="math notranslate nohighlight">\(s_x\)</span>, <span class="math notranslate nohighlight">\(s_y\)</span> and <span class="math notranslate nohighlight">\(s_z\)</span> are all greater than 1).</p>
<figure class="align-default" id="scaling-about-origin-figure">
<a class="reference internal image-reference" href="../_images/05_scaling.svg"><img alt="../_images/05_scaling.svg" height="350" src="../_images/05_scaling.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.5 </span><span class="caption-text">Scaling a triangle centred at the origin.</span><a class="headerlink" href="#scaling-about-origin-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Since scaling is simply multiplying the co-ordinates by a number we have</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \begin{pmatrix}
        s_x &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; s_y &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; s_z &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}
    \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix}
    =
    \begin{pmatrix} s_xx \\ s_yy \\ s_zz \\ 1 \end{pmatrix},
\end{align*} \end{split}\]</div>
<p>so the <strong>scaling matrix</strong> for applying the scaling transformation is</p>
<div class="math notranslate nohighlight" id="equation-eq-scaling-matrix">
<span class="eqno">(5.2)<a class="headerlink" href="#equation-eq-scaling-matrix" title="Permalink to this equation">#</a></span>\[\begin{split} Scale =
\begin{pmatrix}
    s_x &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; s_y &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; s_z &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}. \end{split}\]</div>
<p>Lets now apply scaling to our rectangle in OpenGL to increase its size by a factor of 0.4 in the horizontal direction and 0.3 in the vertical direction. The process is very similar to how we did the translation and since we have already created a uniform, passed it to the vertex shader and modified the vertex shader, all we need to do to apply shading is calculate the scaling matrix which is</p>
<div class="math notranslate nohighlight">
\[\begin{split} Scale = \begin{pmatrix}
    0.4 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0.3 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}.\end{split}\]</div>
<p>Enter the following code into the main program after we defined the <code class="docutils literal notranslate"><span class="pre">translation</span></code> matrix.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define the scaling matrix</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
<span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.4f</span><span class="p">,</span><span class="w"> </span><span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="n">scale</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the indices <code class="docutils literal notranslate"><span class="pre">[0][0]</span></code>, <code class="docutils literal notranslate"><span class="pre">[1][1]</span></code> and <code class="docutils literal notranslate"><span class="pre">[2][2]</span></code> refer to the elements on the main diagonal of a <code class="docutils literal notranslate"><span class="pre">glm::mat4</span></code> object. Also, set the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> matrix equal to the <code class="docutils literal notranslate"><span class="pre">scale</span></code> matrix.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
</pre></div>
</div>
<p>Running the program you should see the image shown in <a class="reference internal" href="#scaling-rectangle-figure"><span class="std std-numref">Fig. 5.6</span></a>.</p>
<figure class="align-default" id="scaling-rectangle-figure">
<a class="reference internal image-reference" href="../_images/05_scaling.png"><img alt="../_images/05_scaling.png" src="../_images/05_scaling.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.6 </span><span class="caption-text">A rectangle scaled by the vector <span class="math notranslate nohighlight">\((0.4, 0.3, 1)\)</span>.</span><a class="headerlink" href="#scaling-rectangle-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Like with the translation matrix, it would be useful to have a Maths class method to calculate a scaling matrix. Add the following method prototype to the <code class="docutils literal notranslate"><span class="pre">Maths</span></code> class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="nf">scale</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<p>Then define the method by entering the following code in the <strong>maths.cpp</strong> file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="nf">Maths::scale</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="n">scale</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Check that the method works by commenting out the code used to define the <code class="docutils literal notranslate"><span class="pre">scale</span></code> matrix and add the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.4f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span>
</pre></div>
</div>
<p>Running the program you should see no change to the image from <a class="reference internal" href="#scaling-rectangle-figure"><span class="std std-numref">Fig. 5.6</span></a>.Experiment with different scaling vectors to see the affect this has.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If scaling is applied to a shape that is not centred at <span class="math notranslate nohighlight">\((0,0,0)\)</span> then the transformed shape is distorted and its centre is moved from its original position (<a class="reference internal" href="#scaling-not-centred-figure"><span class="std std-numref">Fig. 5.7</span></a>).</p>
<figure class="align-default" id="scaling-not-centred-figure">
<a class="reference internal image-reference" href="../_images/05_scaling_not_centred.svg"><img alt="../_images/05_scaling_not_centred.svg" src="../_images/05_scaling_not_centred.svg" width="550" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.7 </span><span class="caption-text">Scaling applied to a triangle not centred at <span class="math notranslate nohighlight">\((0,0,0)\)</span>.</span><a class="headerlink" href="#scaling-not-centred-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>If the desired result is to resize the shape whilst keeping its dimensions and location the same we first need to translate the vertex co-ordinates by <span class="math notranslate nohighlight">\(-\mathbf{c}\)</span> where <span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is the centre of volume for the shape so that it is at <span class="math notranslate nohighlight">\((0,0,0)\)</span>. Then we can apply the scaling before translating by <span class="math notranslate nohighlight">\(\mathbf{c}\)</span> so that the centre of volume is back at the original position (<a class="reference internal" href="#scaling-about-centre-figure"><span class="std std-numref">Fig. 5.8</span></a>).</p>
<figure class="align-default" id="scaling-about-centre-figure">
<a class="reference internal image-reference" href="../_images/05_scaling_about_centre.svg"><img alt="../_images/05_scaling_about_centre.svg" src="../_images/05_scaling_about_centre.svg" width="700" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.8 </span><span class="caption-text">The steps required to scale a shape about its centre.</span><a class="headerlink" href="#scaling-about-centre-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
<hr class="docutils" />
</section>
<section id="rotation">
<span id="rotation-section"></span><h2><span class="section-number">5.4. </span>Rotation<a class="headerlink" href="#rotation" title="Permalink to this heading">#</a></h2>
<p>As well as translating and scaling objects, the next most common transformation is the rotation of objects around the three co-ordinate axes <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span>. We define the rotation <strong>anti-clockwise</strong> around each of the co-ordinate axes by an angle <span class="math notranslate nohighlight">\(\theta\)</span> when looking down the axes (<a class="reference internal" href="#d-rotation-figure"><span class="std std-numref">Fig. 5.9</span></a>).</p>
<figure class="align-default" id="d-rotation-figure">
<a class="reference internal image-reference" href="../_images/05_3D_rotation.svg"><img alt="../_images/05_3D_rotation.svg" height="350" src="../_images/05_3D_rotation.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.9 </span><span class="caption-text">Rotation is assumed to be in the anti-clockwise direction when looking down the axis.</span><a class="headerlink" href="#d-rotation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The <strong>rotation matrices</strong> for achieving these rotations are</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    R_x &amp;=
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \cos(\theta) &amp; -\sin(\theta) &amp; 0 \\
        0 &amp; \sin(\theta) &amp;  \cos(\theta) &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}, \\
    R_y &amp;=
    \begin{pmatrix}
         \cos(\theta) &amp; 0 &amp; \sin(\theta) &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        -\sin(\theta) &amp; 0 &amp; \cos(\theta) &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}, \\
    R_z &amp;=
    \begin{pmatrix}
        \cos(\theta) &amp; -\sin(\theta) &amp; 0 &amp; 0 \\
        \sin(\theta) &amp;  \cos(\theta) &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p>You don’t really need to know how these are derived but if you are curious you can click on the dropdown link below.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Derivation of the rotation matrices (click to show)<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">We will consider rotation about the <span class="math notranslate nohighlight">\(z\)</span>-axis and will restrict our co-ordinates to 2D.</p>
<figure class="align-default" id="rotation-figure">
<a class="reference internal image-reference" href="../_images/05_rotation.svg"><img alt="../_images/05_rotation.svg" height="300" src="../_images/05_rotation.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.10 </span><span class="caption-text">Rotating the vector <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> anti-clockwise by angle <span class="math notranslate nohighlight">\(\theta\)</span> to the vector <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>.</span><a class="headerlink" href="#rotation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text">Consider <a class="reference internal" href="#rotation-figure"><span class="std std-numref">Fig. 5.10</span></a> where the vector <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> is rotated by angle <span class="math notranslate nohighlight">\(\theta\)</span> to the vector <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>. To get this rotation we first consider the rotation of the vector <span class="math notranslate nohighlight">\(\mathbf{t}\)</span>, which has the same length as <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> and points along the <span class="math notranslate nohighlight">\(x\)</span>-axis, by angle <span class="math notranslate nohighlight">\(\phi\)</span> to get to <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>. If we form a right-angled triangle (the blue one) then we know the length of the hypotenuse, <span class="math notranslate nohighlight">\(|\mathbf{a}|\)</span>, and the angle so we can calculate the lengths of the adjacent and opposite sides using trigonometry. Remember our trig ratios (SOH-CAH-TOA)</p>
<div class="math notranslate nohighlight">
\[ \begin{align*}
    \sin(\phi) &amp;= \frac{\textsf{opposite}}{\textsf{hypotenuse}}, &amp;
    \cos(\phi) &amp;= \frac{\textsf{adjacent}}{\textsf{hypotenuse}}, &amp;
    \tan(\phi) &amp;= \frac{\textsf{opposite}}{\textsf{adjacent}},
\end{align*} \]</div>
<p class="sd-card-text">so the length of the adjacent and opposite sides of the blue triangle is</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{adjacent} &amp;= \textsf{hypotenuse} \cdot \cos(\phi), \\
    \textsf{opposite} &amp;= \textsf{hypotenuse} \cdot \sin(\phi).
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Since <span class="math notranslate nohighlight">\(a_x\)</span> and <span class="math notranslate nohighlight">\(a_y\)</span> are the lengths of the adjacent and opposite sides respectively and <span class="math notranslate nohighlight">\(|\mathbf{a}|\)</span> is the length of the hypotenuse we have</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    a_x &amp;= |\mathbf{a}| \cos(\phi), \\
    a_y &amp;= |\mathbf{a}| \sin(\phi).
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Now consider the rotation from <span class="math notranslate nohighlight">\(\mathbf{c}\)</span> by the angle <span class="math notranslate nohighlight">\(\phi + \theta\)</span> to get to <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>. Using the same method as before we have</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    b_x &amp;= |\mathbf{a}| \cos(\phi + \theta), \\
    b_y &amp;= |\mathbf{a}| \sin(\phi + \theta).
\end{align*} \end{split}\]</div>
<p class="sd-card-text">We can rewrite <span class="math notranslate nohighlight">\(\cos(\phi+\theta)\)</span> and <span class="math notranslate nohighlight">\(\sin(\phi+\theta)\)</span> using <a href="https://en.wikipedia.org/wiki/List_of_trigonometric_identities#" target="_blank">trigonometric identities</a></p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \cos(\phi + \theta) &amp;= \cos(\phi) \cos(\theta) - \sin(\phi) \sin(\theta), \\
    \sin(\phi + \theta) &amp;= \sin(\phi) \cos(\theta) + \cos(\phi) \sin(\theta),
\end{align*} \end{split}\]</div>
<p class="sd-card-text">so</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    v_x &amp;= |\mathbf{a}| \cos(\phi) \cos(\theta) - |\mathbf{a}| \sin(\phi) \sin(\theta), \\
    v_y &amp;= |\mathbf{a}| \sin(\phi) \cos(\theta) + |\mathbf{a}| \cos(\phi) \sin(\theta).
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Since <span class="math notranslate nohighlight">\( a_x = |\mathbf{a}| \cos(\phi)\)</span> and <span class="math notranslate nohighlight">\(a_y = |\mathbf{a}| \sin(\phi)\)</span> then</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    b_x &amp;= a_x \cos(\theta) - a_y \sin(\theta), \\
    b_y &amp;= a_y \sin(\phi) + a_x \sin(\theta),
\end{align*} \end{split}\]</div>
<p class="sd-card-text">which can be written using matrices as</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \begin{pmatrix} b_x \\ b_y \end{pmatrix} =
    \begin{pmatrix} \cos(\theta) &amp; -\sin(\theta) \\ \sin(\theta) &amp; \cos(\theta) \end{pmatrix}
    \begin{pmatrix} a_x \\ a_y \end{pmatrix},
\end{align*} \end{split}\]</div>
<p class="sd-card-text">so the transformation (non-transposed) matrix for rotating around the <span class="math notranslate nohighlight">\(z\)</span>-axis in 2D is</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{pmatrix} \cos(\theta) &amp; -\sin(\theta) \\ \sin(\theta) &amp; \cos(\theta) \end{pmatrix}. \end{split}\]</div>
<p class="sd-card-text">We need a <span class="math notranslate nohighlight">\(4\times 4\)</span> matrix to represent 3D rotation around the <span class="math notranslate nohighlight">\(z\)</span>-axis so we replace the 3rd and 4th row and columns with the 3rd and 4th row and column from the <span class="math notranslate nohighlight">\(4\times 4\)</span> identity matrix giving</p>
<div class="math notranslate nohighlight">
\[\begin{split} R_z = \begin{pmatrix}
    \cos(\theta) &amp; -\sin(\theta) &amp; 0 &amp; 0 \\
    \sin(\theta) &amp; \cos(\theta) &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}. \end{split}\]</div>
<p class="sd-card-text">The rotation matrices for the rotation around the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> axes are derived using a similar process.</p>
</div>
</details><section id="rotation-in-opengl">
<h3><span class="section-number">5.4.1. </span>Rotation in OpenGL<a class="headerlink" href="#rotation-in-opengl" title="Permalink to this heading">#</a></h3>
<p>Lets rotate our original rectangle anti-clockwise about the <span class="math notranslate nohighlight">\(z\)</span>-axis by <span class="math notranslate nohighlight">\(\theta = 45^\circ\)</span>. The transposed rotation matrix to do this is</p>
<div class="math notranslate nohighlight">
\[\begin{split} Rotate =
\begin{pmatrix}
     \cos(45^\circ) &amp; \sin(45^\circ) &amp; 0 &amp; 0 \\
    -\sin(45^\circ) &amp; \cos(45^\circ) &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}. \end{split}\]</div>
<p>Define the rotation matrix using the code below</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define the rotation matrix</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">rotate</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">45.0f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">3.1416f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">180.0f</span><span class="p">;</span>
<span class="n">rotate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="w"> </span><span class="n">rotate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">);</span>
<span class="n">rotate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="w"> </span><span class="n">rotate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we also needed to convert <span class="math notranslate nohighlight">\(45^\circ\)</span> into <a href="https://en.wikipedia.org/wiki/Radian" target="_blank"><strong>radians</strong></a> since OpenGL expects angles to be in radians (1 radian is equal to <span class="math notranslate nohighlight">\(\pi/180\)</span> degrees). Set the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> matrix equal to the <code class="docutils literal notranslate"><span class="pre">rotate</span></code> matrix, run the program and you should see the rotated rectangle shown in <a class="reference internal" href="#rotation-rectangle-figure"><span class="std std-numref">Fig. 5.11</span></a>.</p>
<figure class="align-default" id="rotation-rectangle-figure">
<a class="reference internal image-reference" href="../_images/05_rotation.png"><img alt="../_images/05_rotation.png" src="../_images/05_rotation.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.11 </span><span class="caption-text">Rectangle rotated anti-clockwise about the <span class="math notranslate nohighlight">\(z\)</span>-axis by <span class="math notranslate nohighlight">\(45^\circ\)</span>.</span><a class="headerlink" href="#rotation-rectangle-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="axis-angle-rotation">
<span id="axis-angle-rotation-section"></span><h3><span class="section-number">5.4.2. </span>Axis-angle rotation<a class="headerlink" href="#axis-angle-rotation" title="Permalink to this heading">#</a></h3>
<p>The three rotation transformations are only useful if we want to only rotate around one of the three co-ordinate axes. A more useful transformation is the rotation around the axis that points in the direction of a vector, <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> say, which has its tail at (0,0,0) (<a class="reference internal" href="#axis-angle-rotation-figure"><span class="std std-numref">Fig. 5.12</span></a>).</p>
<figure class="align-default" id="axis-angle-rotation-figure">
<a class="reference internal image-reference" href="../_images/05_axis_angle_rotation.svg"><img alt="../_images/05_axis_angle_rotation.svg" height="300" src="../_images/05_axis_angle_rotation.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.12 </span><span class="caption-text">Axis-angle rotation.</span><a class="headerlink" href="#axis-angle-rotation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The transposed transformation matrix for rotation around a unit vector <span class="math notranslate nohighlight">\(\hat{\mathbf{v}} = (v_x, v_y, v_z)\)</span>, anti-clockwise by angle <span class="math notranslate nohighlight">\(\theta\)</span> when looking down the vector is.</p>
<div class="math notranslate nohighlight" id="equation-eq-axis-angle-rotation-matrix">
<span class="eqno">(5.3)<a class="headerlink" href="#equation-eq-axis-angle-rotation-matrix" title="Permalink to this equation">#</a></span>\[\begin{split} \begin{align*}
    Rotate =
    \begin{pmatrix}
        v_x^2 (1 - \cos(\theta)) + \cos(\theta) &amp;
        v_xv_y(1 - \cos(\theta)) + v_z\sin(\theta) &amp;
        v_xv_z(1 - \cos(\theta)) - v_y\sin(\theta) &amp;
        0 \\
        v_xv_y(1 - \cos(\theta)) - v_z\sin(\theta) &amp;
         v_y^2(1 - \cos(\theta)) + \cos(\theta) &amp;
        v_yv_z(1 - \cos(\theta)) + v_x\sin(\theta) &amp;
        0 \\
        v_xv_z(1 - \cos(\theta)) + v_y\sin(\theta) &amp;
        v_yv_z(1 - \cos(\theta)) - v_x\sin(\theta) &amp;
        v_z^2 (1 - \cos(\theta)) + \cos(\theta) &amp;
        0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p>Again, you don’t really need to know how this is derived but if you are curious click on the dropdown link below.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Derivation of the axis-angle rotation matrix (click to show)<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">The rotation about the unit vector <span class="math notranslate nohighlight">\(\hat{\mathbf{v}} = (v_x, v_y, v_z)\)</span> by angle <span class="math notranslate nohighlight">\(\theta\)</span> is the <a class="reference internal" href="#composite-transformations-section"><span class="std std-ref">composition</span></a> of 5 separate rotations:</p>
<ol class="arabic simple">
<li><p class="sd-card-text">Rotate <span class="math notranslate nohighlight">\(\hat{\mathbf{v}}\)</span> around the <span class="math notranslate nohighlight">\(x\)</span>-axis so that it is in the <span class="math notranslate nohighlight">\(xz\)</span>-plane (the <span class="math notranslate nohighlight">\(y\)</span> component of the vector is 0);</p></li>
<li><p class="sd-card-text">Rotate the vector around the <span class="math notranslate nohighlight">\(y\)</span>-axis so that it points along the <span class="math notranslate nohighlight">\(z\)</span>-axis (the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> components are 0 and the <span class="math notranslate nohighlight">\(z\)</span> component is a positive number);</p></li>
<li><p class="sd-card-text">Perform the rotation around the <span class="math notranslate nohighlight">\(z\)</span>-axis;</p></li>
<li><p class="sd-card-text">Reverse the rotation around the <span class="math notranslate nohighlight">\(y\)</span>-axis;</p></li>
<li><p class="sd-card-text">Reverse the rotation around the <span class="math notranslate nohighlight">\(x\)</span>-axis.</p></li>
</ol>
<p class="sd-card-text">The rotation around the <span class="math notranslate nohighlight">\(x\)</span>-axis is achieved by forming a right-angled triangle in the <span class="math notranslate nohighlight">\(yz\)</span>-plane where the the angle of rotation <span class="math notranslate nohighlight">\(\theta\)</span> has an adjacent side of length <span class="math notranslate nohighlight">\(v_z\)</span>, an opposite side of length <span class="math notranslate nohighlight">\(v_y\)</span> and a hypotenuse of length <span class="math notranslate nohighlight">\(\sqrt{v_y^2 + v_z^2}\)</span> (<a class="reference internal" href="#axis-angle-rotation1-figure"><span class="std std-numref">Fig. 5.13</span></a>).</p>
<figure class="align-default" id="axis-angle-rotation1-figure">
<a class="reference internal image-reference" href="../_images/05_axis_angle_rotation_1.svg"><img alt="../_images/05_axis_angle_rotation_1.svg" height="250" src="../_images/05_axis_angle_rotation_1.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.13 </span><span class="caption-text">Rotate <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> around the <span class="math notranslate nohighlight">\(x\)</span>-axis</span><a class="headerlink" href="#axis-angle-rotation1-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text">Therefore <span class="math notranslate nohighlight">\(\cos(\theta) = \dfrac{v_z}{\sqrt{v_y^2 + v_z^2}}\)</span> and <span class="math notranslate nohighlight">\(\sin(\theta) = \dfrac{v_y}{\sqrt{v_y^2 + v_z^2}}\)</span> so the rotation matrix is</p>
<div class="math notranslate nohighlight">
\[\begin{split} R_1 = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \dfrac{v_z}{\sqrt{v_y^2 + v_z^2}} &amp; -\dfrac{v_x}{\sqrt{v_y^2 + v_z^2}} &amp; 0 \\
    0 &amp; \dfrac{v_y}{\sqrt{v_y^2 + v_z^2}} &amp;  \dfrac{v_z}{\sqrt{v_y^2 + v_z^2}} &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}.\end{split}\]</div>
<p class="sd-card-text">The rotation around the <span class="math notranslate nohighlight">\(y\)</span>-axis is achieved by forming another right-angled triangle in the <span class="math notranslate nohighlight">\(xz\)</span>-plane where <span class="math notranslate nohighlight">\(\theta\)</span> has an adjacent side of length <span class="math notranslate nohighlight">\(\sqrt{v_y^2 + v_z^2}\)</span>, an opposite side of length <span class="math notranslate nohighlight">\(v_x\)</span> and a hypotenuse of length 1 since <span class="math notranslate nohighlight">\(\hat{\mathbf{v}}\)</span> is a unit vector (<a class="reference internal" href="#axis-angle-rotation2-figure"><span class="std std-numref">Fig. 5.14</span></a>).</p>
<figure class="align-default" id="axis-angle-rotation2-figure">
<a class="reference internal image-reference" href="../_images/05_axis_angle_rotation_2.svg"><img alt="../_images/05_axis_angle_rotation_2.svg" height="250" src="../_images/05_axis_angle_rotation_2.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.14 </span><span class="caption-text">Rotate around the <span class="math notranslate nohighlight">\(y\)</span>-axis</span><a class="headerlink" href="#axis-angle-rotation2-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text">Therefore <span class="math notranslate nohighlight">\(\cos(\theta) = \sqrt{v_y^2 + v_z^2}\)</span> and <span class="math notranslate nohighlight">\(\sin(\theta) = v_x\)</span>. Note that here we are rotating in the clockwise direction so the rotation matrix is</p>
<div class="math notranslate nohighlight">
\[\begin{split} R_2 = \begin{pmatrix}
    \sqrt{v_y^2 + v_z^2} &amp; 0 &amp; -v_x &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    v_x &amp; 0 &amp; \sqrt{v_y^2 + v_z^2} &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}.\end{split}\]</div>
<p class="sd-card-text">Now that the vector points along the <span class="math notranslate nohighlight">\(z\)</span>-axis we perform the rotation so the rotation matrix for this is</p>
<div class="math notranslate nohighlight">
\[\begin{split} R_3 = \begin{pmatrix}
    \cos(\theta) &amp; -\sin(\theta) &amp; 0 &amp; 0 \\
    \sin(\theta) &amp;  \cos(\theta) &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}. \end{split}\]</div>
<p class="sd-card-text">The reverse rotation around the <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(x\)</span> axes is simply the rotation matrices <span class="math notranslate nohighlight">\(R_2\)</span> and <span class="math notranslate nohighlight">\(R_1\)</span> with the negative sign for <span class="math notranslate nohighlight">\(\sin(\theta)\)</span> swapped</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    R_4 &amp;= \begin{pmatrix} 
       \sqrt{v_y^2 + v_z^2} &amp; 0 &amp; v_x &amp; 0 \\
       0 &amp; 1 &amp; 0 &amp; 0 \\
       -v_x &amp; 0 &amp; \sqrt{v_y^2 + v_z^2} &amp; 0 \\
       0 &amp; 0 &amp; 0 &amp; 1
   \end{pmatrix}, \\
   R_5 &amp;= \begin{pmatrix} 
       1 &amp; 0 &amp; 0 &amp; 0 \\ 
       0 &amp;  \dfrac{v_z}{\sqrt{v_y^2 + v_z^2}} &amp; \dfrac{v_y}{\sqrt{v_y^2 + v_z^2}} &amp; 0 \\
       0 &amp; -\dfrac{v_x}{\sqrt{v_y^2 + v_z^2}} &amp; \dfrac{v_z}{\sqrt{v_y^2 + v_z^2}} &amp; 0 \\
       0 &amp; 0 &amp; 0 &amp; 1
   \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Multiplying all of the separate matrices together gives</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    Rotate &amp;= R_5 \cdot R_4 \cdot R_3 \cdot R_2 \cdot R_1 \\
    &amp;=
    \begin{pmatrix}
        \dfrac{v_x^2 + (v_y^2 + v_z^2)\cos(\theta)}{\|\mathbf{v}\|^2} &amp;
        \dfrac{v_xv_y(1 - \cos(\theta))}{\|\mathbf{v}\|^2} + \dfrac{v_z\sin(\theta)}{\|\mathbf{v}\|} &amp;
        \dfrac{v_xv_z(1 - \cos(\theta))}{\|\mathbf{v}\|^2} - \dfrac{v_y\sin(\theta)}{\|\mathbf{v}\|} &amp;
        0 \\
        \dfrac{v_xv_y(1 - \cos(\theta))}{\|\mathbf{v}\|^2} - \dfrac{v_z\sin(\theta)}{\|\mathbf{v}\|} &amp;
        \dfrac{v_y^2 + (v_x^2 + v_y^2)\cos(\theta)}{\|\mathbf{v}\|^2} &amp;
        \dfrac{v_yv_z(1 - \cos(\theta))}{\|\mathbf{v}\|^2} - \dfrac{v_x\sin(\theta)}{\|\mathbf{v}\|} &amp;
        0 \\
        \dfrac{v_xv_z(1 - \cos(\theta))}{\|\mathbf{v}\|^2} + \dfrac{v_y\sin(\theta)}{\|\mathbf{v}\|} &amp;
        \dfrac{v_yv_z(1 - \cos(\theta))}{\|\mathbf{v}\|^2} - \dfrac{v_x\sin(\theta)}{\|\mathbf{v}\|} &amp;
        \dfrac{v_z^2 + (v_x^2 + v_y^2)\cos(\theta)}{\|\mathbf{v}\|^2} &amp;
        0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Substituting <span class="math notranslate nohighlight">\(v_y^2 + v_z^2 = 1 - v_x^2\)</span> and the matrix simplifies to</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    Rotate &amp;= R_1 \cdot R_2 \cdot R_3 \cdot R_4 \cdot R_5 \\
    &amp;=
    \begin{pmatrix}
        v_x^2 (1 - \cos(\theta)) + \cos(\theta) &amp; 11
        v_xv_y(1 - \cos(\theta)) - v_z\sin(\theta) &amp; 12
        v_xv_z(1 - \cos(\theta)) + v_y\sin(\theta) &amp; 13
        0 \\
        v_xv_y(1 - \cos(\theta)) + v_z\sin(\theta) &amp; 21
         v_y^2(1 - \cos(\theta)) + \cos(\theta) &amp; 22
        v_yv_z(1 - \cos(\theta)) - v_x\sin(\theta) &amp; 23
        0 \\
        v_xv_z(1 - \cos(\theta)) - v_y\sin(\theta) &amp; 31
        v_yv_z(1 - \cos(\theta)) + v_x\sin(\theta) &amp; 32
        v_z^2 (1 - \cos(\theta)) + \cos(\theta) &amp; 33
        0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}.
\end{align*} \end{split}\]</div>
</div>
</details></section>
<section id="axis-angle-rotation-in-opengl">
<h3><span class="section-number">5.4.3. </span>Axis-angle rotation in OpenGL<a class="headerlink" href="#axis-angle-rotation-in-opengl" title="Permalink to this heading">#</a></h3>
<p>The rotations around the three co-ordinates axis can be calculated using the axis-angle rotation matrix (by letting <span class="math notranslate nohighlight">\(\hat{\mathbf{v}}\)</span> be <span class="math notranslate nohighlight">\((1,0,0)\)</span>, <span class="math notranslate nohighlight">\((0,1,0)\)</span> or <span class="math notranslate nohighlight">\((0,0,1)\)</span> for rotating around the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> axes respectively) so it makes sense to define a single function for rotation using <a class="reference internal" href="#equation-eq-axis-angle-rotation-matrix">(5.3)</a>. Define a couple of functions in the Maths class by entering the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nf">radians</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">angle</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="nf">rotate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">&amp;</span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<p>Then define these methods by entering the following code in the <strong>maths.cpp</strong> file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="nf">Maths::radians</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">angle</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">3.1416f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">180.0f</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="nf">Maths::rotate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">&amp;</span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">xy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">xz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">yz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w">   </span><span class="n">ys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w">   </span><span class="n">zs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>

<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">rotate</span><span class="p">;</span>
<span class="w">    </span><span class="n">rotate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="n">rotate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">xy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">zs</span><span class="p">;</span>
<span class="w">    </span><span class="n">rotate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">xz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ys</span><span class="p">;</span>
<span class="w">    </span><span class="n">rotate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">xy</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">zs</span><span class="p">;</span>
<span class="w">    </span><span class="n">rotate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="n">rotate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">yz</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xs</span><span class="p">;</span>
<span class="w">    </span><span class="n">rotate</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">xz</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ys</span><span class="p">;</span>
<span class="w">    </span><span class="n">rotate</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">yz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xs</span><span class="p">;</span>
<span class="w">    </span><span class="n">rotate</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">rotate</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Check that the <code class="docutils literal notranslate"><span class="pre">rotate()</span></code> method works by commenting out the code used to define the rotation matrix and add the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">angle</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">45.0f</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span>
</pre></div>
</div>
<p>Running the program you should see no change to the image shown in <a class="reference internal" href="#rotation-rectangle-figure"><span class="std std-numref">Fig. 5.11</span></a>. Experiment with different angles and rotation vectors to see the affects this has.</p>
<hr class="docutils" />
</section>
</section>
<section id="composite-transformations">
<span id="composite-transformations-section"></span><h2><span class="section-number">5.5. </span>Composite transformations<a class="headerlink" href="#composite-transformations" title="Permalink to this heading">#</a></h2>
<p>So far we have performed translation, scaling and rotation transformations on our rectangle separately. What if we wanted to combine these transformations so that we can control the size, rotation and position of the rectangle? If we apply the transformations in the order scale <span class="math notranslate nohighlight">\(\rightarrow\)</span> rotate <span class="math notranslate nohighlight">\(\rightarrow\)</span> translate then applying the scaling we have</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \begin{pmatrix} x' \\ y' \\ z' \\ 1 \end{pmatrix}
    &amp;=
    Scale \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p>Next applying rotation to the scaled co-ordinates we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
    \begin{pmatrix} x' \\ y' \\ z' \\ 1 \end{pmatrix} &amp;=
    Rotate \cdot Scale \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p>Finally applying translation to the scaled and rotated co-ordinates we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
    \begin{pmatrix} x' \\ y' \\ z' \\ 1 \end{pmatrix}
    &amp;=
    Translate \cdot Rotate \cdot Scale \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p><span class="math notranslate nohighlight">\(Translate \cdot Rotate \cdot Scale\)</span> is a single <span class="math notranslate nohighlight">\(4 \times 4\)</span> transformation matrix that combines the three transformations known as the <strong>composite transformation matrix</strong>. Note the order that the translations are applied to the co-ordinates is read from right to left so here we have scale <span class="math notranslate nohighlight">\(\to\)</span> rotate <span class="math notranslate nohighlight">\(\to\)</span> translate.</p>
<section id="composite-transformations-in-opengl">
<h3><span class="section-number">5.5.1. </span>Composite transformations in OpenGL<a class="headerlink" href="#composite-transformations-in-opengl" title="Permalink to this heading">#</a></h3>
<p>Lets apply scaling, rotation and translation (in that order) to our rectangle. Since we have already calculated the separate transformation matrices all we need to do is to multiply them together and set it equal to <code class="docutils literal notranslate"><span class="pre">transformation</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
</pre></div>
</div>
<p>After compiling and running the program you should see the image shown in <a class="reference internal" href="#composite-transformation-figure"><span class="std std-numref">Fig. 5.15</span></a>.</p>
<figure class="align-default" id="composite-transformation-figure">
<a class="reference internal image-reference" href="../_images/05_composite_transformation.png"><img alt="../_images/05_composite_transformation.png" src="../_images/05_composite_transformation.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.15 </span><span class="caption-text">Scaling, rotation and translation applied to the textured rectangle.</span><a class="headerlink" href="#composite-transformation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<hr class="docutils" />
</section>
</section>
<section id="animating-the-rectangle">
<span id="animating-objects-section"></span><h2><span class="section-number">5.6. </span>Animating the rectangle<a class="headerlink" href="#animating-the-rectangle" title="Permalink to this heading">#</a></h2>
<p>It may appear that our application is displaying a static image of the textured rectangle but what is actually happening is that the window is constantly being updated with new frame buffers as and when they have been calculated. We can animate our rectangle by applying the transformations within the render loop.</p>
<p>We are going to animate our rectangle, so that is rotates around its own centre. To do this we are going to use the time the has elapsed since the application was started to calculate the rotation angle. Comment out the code used to define the translation, scaling and rotation matrices and enter the following code just before the transformation matrix is sent to the shader</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Animate rectangle</span>
<span class="kt">float</span><span class="w"> </span><span class="n">angle</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">glfwGetTime</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">360.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.4f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">));</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.4f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">));</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">rotate</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span>
</pre></div>
</div>
<p>Here we use the <code class="docutils literal notranslate"><span class="pre">glfwGetTime()</span></code> function to get the time of the current frame since the application was started and use it to calculate the rotation angle so that the rectangle performs one complete rotation every 3 seconds. Compile and run the program and you should see something similar to the following.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/05_rotating_mario_1.mp4" type="video/mp4">
</video>
</center>
<p>When calculating the composite transformation matrix the order in which we multiply the individual transformations will determine the effects of the composite transformation. To see this lets translate the rectangle first before rotating it by changing the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> calculation to the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
</pre></div>
</div>
<p>Compile and run the program and we have something quite different.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/05_rotating_mario_2.mp4" type="video/mp4">
</video>
</center>
<p>What has happened here is the rectangle has been scaled and translated so that its centre is now at <span class="math notranslate nohighlight">\((0.4, 0.3, 0)\)</span>. Then when rotation is applied the triangle is rotated about the origin.</p>
</section>
<hr class="docutils" />
<section id="exercises">
<h2><span class="section-number">5.7. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Scale the original rectangle so that it is a quarter of the original size and apply translation so that the rectangle moves anti-clockwise around a circle centred at the window centre with radius 0.5 and completes one full rotation every 5 seconds. Hint: the co-ordinates of points on a circle centered at <span class="math notranslate nohighlight">\((0,0)\)</span> with radius <span class="math notranslate nohighlight">\(r\)</span> can be calculated using <span class="math notranslate nohighlight">\(x = r\cos(t)\)</span> and <span class="math notranslate nohighlight">\(y = r\sin(t)\)</span> where <span class="math notranslate nohighlight">\(t\)</span> is some number.</p></li>
</ol>
<center>
<video controls muted="true" loop="true" width="400">
    <source src="../_static/05_Ex1.mp4" type="video/mp4">
</video>
</center>
<ol class="arabic simple" start="2">
<li><p>Rotate your rectangle from exercise 1 in a clockwise rotation about its centre at twice the rotation speed used in exercise 1.</p></li>
</ol>
<center>
<video controls muted="true" loop="true" width="400">
    <source src="../_static/05_Ex2.mp4" type="video/mp4">
</video>
</center>
<ol class="arabic simple" start="3">
<li><p>Scale your rectangle from exercise 2 so that it grows and shrinks about its centre. Hint: The <span class="math notranslate nohighlight">\(\sin(t)\)</span> function oscillates between 0 and 1 as <span class="math notranslate nohighlight">\(t\)</span> increases.</p></li>
</ol>
<center>
<video controls muted="true" loop="true" width="400">
    <source src="../_static/05_Ex3.mp4" type="video/mp4">
</video>
</center>
<ol class="arabic simple" start="4">
<li><p>Create a simple screensaver by doing the following:</p></li>
</ol>
<ul class="simple">
<li><p>Before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function, define two 3-element vectors for the position and velocity with initial values <span class="math notranslate nohighlight">\(\mathbf{p} = (0,0,0)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v} = (0.01, 0.005, 0)\)</span> respectively</p></li>
<li><p>Inside the render loop, calculate the new centre position using <span class="math notranslate nohighlight">\(\mathbf{p} = \mathbf{p} + \mathbf{v}\)</span></p></li>
<li><p>Scale the original rectangle so that it is one fifth its original size and translate the rectangle so that its center is at <span class="math notranslate nohighlight">\(\mathbf{p}\)</span></p></li>
<li><p>Reflect the rectangle off the edges of the window by reversing the sign of the elements of the velocity vector when the center of the rectangle gets to within 0.1 of the window edge.</p></li>
</ul>
<center>
<video controls muted="true" loop="true" width="400">
    <source src="../_static/05_Ex4.mp4" type="video/mp4">
</video>
</center>
<ol class="arabic simple" start="5">
<li><p>Run your program from exercise 4 until the rectangle perfectly hits a corner (just kidding).</p></li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="04_vectors_and_matrices.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">4. </span>Vectors and Matrices</p>
      </div>
    </a>
    <a class="right-next"
       href="06_3D_worlds.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">6. </span>3D Worlds</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#translation">5.1. Translation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#translation-in-opengl">5.1.1. Translation in OpenGL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-maths-class">5.2. A Maths class</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#scaling">5.3. Scaling</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rotation">5.4. Rotation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rotation-in-opengl">5.4.1. Rotation in OpenGL</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axis-angle-rotation">5.4.2. Axis-angle rotation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axis-angle-rotation-in-opengl">5.4.3. Axis-angle rotation in OpenGL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#composite-transformations">5.5. Composite transformations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#composite-transformations-in-opengl">5.5.1. Composite transformations in OpenGL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#animating-the-rectangle">5.6. Animating the rectangle</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">5.7. Exercises</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dr Jon Shiach
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>