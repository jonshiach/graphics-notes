

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>8. Lighting &#8212; Computer Graphics</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"model": ["M\\!odel"], "view": ["V\\!iew"], "mvp": ["MV\\!P"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/08_Lighting';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="9. Normal Mapping" href="09_Normal_mapping.html" />
    <link rel="prev" title="7. Moving the camera" href="07_Moving_the_camera.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Computer Graphics
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_intro_to_cpp.html">1. Introduction to C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_basic_shapes_in_OpenGL.html">2. Basic Shapes in OpenGL</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_textures.html">3. Textures</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_vectors_and_matrices.html">4. Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_transformations.html">5. Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_3D_worlds.html">6. 3D Worlds</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_Moving_the_camera.html">7. Moving the camera</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">8. Lighting</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_Normal_mapping.html">9. Normal Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_Quaternions.html">10. Quaternions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="A_Complex_numbers_and_quaternions.html">A. Complex Numbers and Quaternions</a></li>
<li class="toctree-l1"><a class="reference internal" href="B_Code.html">B. Code and Assets</a></li>
<li class="toctree-l1"><a class="reference internal" href="C_Glossary.html">C Glossary</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs/issues/new?title=Issue%20on%20page%20%2F_pages/08_Lighting.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/_pages/08_Lighting.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Lighting</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-model-class">8.1. The Model class</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wavefront-obj-files">8.1.1. Wavefront (.obj) files</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#phong-s-lighting-model">8.2. Phong’s lighting model</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ambient-reflection">8.2.1. Ambient reflection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffuse-reflection">8.2.2. Diffuse reflection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#specular-reflection">8.2.3. Specular reflection</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#attenuation">8.3. Attenuation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multiple-light-sources">8.4. Multiple light sources</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spotlights">8.5. Spotlights</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#directional-light">8.6. Directional light</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">8.7. Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-an-obj-file-in-blender">8.8. Creating an .obj file in Blender</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#video-walkthrough">8.9. Video walkthrough</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="lighting">
<span id="lighting-section"></span><h1><span class="section-number">8. </span>Lighting<a class="headerlink" href="#lighting" title="Permalink to this heading">#</a></h1>
<p>In this lab we will be looking at adding a basic lighting model to our application. Lighting modelling is in itself a huge topic within the field of computer graphics and modern games and movies can look very lifelike thanks to some very clever techniques. Lighting models come in two main types: local illumination and global illumination:</p>
<ul class="simple">
<li><p><strong>local illumination</strong> – the colour and brightness of individual points on a surface are determined by the light emanating from one or more light sources.</p></li>
<li><p><strong>global illumination</strong> – the colour and brightness of individual points on a surface are determine both by the light emanating from light sources <strong>in addition to</strong> light that is reflected off of other objects in the scene.</p></li>
</ul>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/08_local_global_illumination.svg"><img alt="../_images/08_local_global_illumination.svg" src="../_images/08_local_global_illumination.svg" width="500" /></a>
</figure>
<p>Here we will be applying a local illumination model since they are easier to apply than global illumination and quicker to compute. The downside is that they don’t produce a rendering as realistic than with global illumination.</p>
<p>Compile and run the <strong>Lab08_Lighting</strong> project and you will see the window below showing a wire frame representation of the Utah teapot.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/08_teapot_wireframe.png"><img alt="../_images/08_teapot_wireframe.png" src="../_images/08_teapot_wireframe.png" style="width: 500px;" /></a>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Utah teapot is a standard test model for computer graphics first created in 1975 by Martin Newell whilst at the University of Utah. It has become a bit of an in-joke in the computer graphics community and has appeared in Pixar’s <em>Toy Story</em> and in <em>The Simpsons</em> episode <em>Treehouse of Horror VI</em>.</p>
</div>
<p>The teapot has been rendered as a wire frame model since in the absence of light and shadow we wouldn’t be able to tell that it was in fact a 3D model. We can turn of the wire frame rendering by commenting out the line <code class="docutils literal notranslate"><span class="pre">glPolygonMode(GL_FRONT_AND_BACK,</span> <span class="pre">GL_LINE);</span></code>. Do this and you should see the following.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/08_teapot_solid.png"><img alt="../_images/08_teapot_solid.png" src="../_images/08_teapot_solid.png" style="width: 500px;" /></a>
</figure>
<section id="the-model-class">
<h2><span class="section-number">8.1. </span>The Model class<a class="headerlink" href="#the-model-class" title="Permalink to this heading">#</a></h2>
<p>If you take a look at the source code in the <strong>Lab08_Lighting</strong> you will notice that in addition to the classes introduced in previous labs (Texture, Shader and Camera) we have an addition class called Model which is defined in the <strong>model.hpp</strong> and <strong>model.cpp</strong> files. The Model class has been written so that we can load the vertex and texture co-ordinates from external files rather than having to define these in our code. Take a look at the <strong>Lab08_Lighting.cpp</strong> file where the following Model class methods have been called:</p>
<ul class="simple">
<li><p>Line 89: <code class="docutils literal notranslate"><span class="pre">Model</span> <span class="pre">teapot(&quot;../assets/teapot.obj)</span></code> – this is the constructor for the Model class and creates an object called <code class="docutils literal notranslate"><span class="pre">teapot</span></code>, loads the vertex and texture co-ordinates from an .obj file (see below) and creates the relevant buffers.</p></li>
<li><p>Line 92: <code class="docutils literal notranslate"><span class="pre">teapot.addTexture(&quot;../assets/blue.bmp&quot;,</span> <span class="pre">&quot;diffuse&quot;);</span></code> – this method loads a texture map called <code class="docutils literal notranslate"><span class="pre">blue.bmp</span></code> and sets its type to <code class="docutils literal notranslate"><span class="pre">diffuse</span></code>.</p></li>
<li><p>Line 131: <code class="docutils literal notranslate"><span class="pre">teapot.draw(shaderID)</span></code> - this method binds the buffers objects and instructs OpenGL to draw the model</p></li>
</ul>
<section id="wavefront-obj-files">
<h3><span class="section-number">8.1.1. </span>Wavefront (.obj) files<a class="headerlink" href="#wavefront-obj-files" title="Permalink to this heading">#</a></h3>
<p>The Model class includes a private member function called <code class="docutils literal notranslate"><span class="pre">loadObj()</span></code> written by contributors of <a href = "https://www.opengl-tutorial.org" target="_blank">opengl-tutorial.org</a> which loads in a <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file" target="_blank"><strong>wavefront (.obj)</strong></a> file. A wavefront file is one of the many different types of file that is used to describe 3D models in computer graphics. In the <strong>assets/</strong> folder you will see some files with the extension .obj. Open the file <strong>cube.obj</strong> using a text editor and you will see the following.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># Blender 4.0.2
# www.blender.org
mtllib cube.mtl
o Cube
v 1.000000 1.000000 -1.000000
v 1.000000 -1.000000 -1.000000
v 1.000000 1.000000 1.000000
v 1.000000 -1.000000 1.000000
v -1.000000 1.000000 -1.000000
v -1.000000 -1.000000 -1.000000
v -1.000000 1.000000 1.000000
v -1.000000 -1.000000 1.000000
vn -0.0000 1.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 -1.0000
vt 0.875000 0.500000
vt 0.625000 0.750000
vt 0.625000 0.500000
vt 0.375000 0.990255
vt 0.375000 0.750000
vt 0.625000 0.008121
vt 0.375000 0.250000
vt 0.375000 0.008121
vt 0.375000 0.500000
vt 0.125000 0.750000
vt 0.125000 0.500000
vt 0.625000 0.250000
vt 0.875000 0.750000
vt 0.625000 0.988631
s 0
usemtl Material
f 5/1/1 3/2/1 1/3/1
f 3/2/2 8/4/2 4/5/2
f 7/6/3 6/7/3 8/8/3
f 2/9/4 8/10/4 6/11/4
f 1/3/5 4/5/5 2/9/5
f 5/12/6 2/9/6 6/7/6
f 5/1/1 7/13/1 3/2/1
f 3/2/2 7/14/2 8/4/2
f 7/6/3 5/12/3 6/7/3
f 2/9/4 4/5/4 8/10/4
f 1/3/5 3/2/5 4/5/5
f 5/12/6 1/3/6 2/9/6
</pre></div>
</div>
<p>The vertex and face data is given in lines with the following abbreviations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> – the <span class="math notranslate nohighlight">\((x, y, z)\)</span> co-ordinates of a vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vn</span></code> – the <span class="math notranslate nohighlight">\((n_x, n_y, n_z)\)</span> normal vector for the vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vt</span></code> – the <span class="math notranslate nohighlight">\((u, v)\)</span> texture co-ordinates</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> – indices of the vertices of a face. Each face is defined by 3 vertices so we have 3 sets of 3 values. The face vertices are of the form <code class="docutils literal notranslate"><span class="pre">v/vt/vn</span></code> so <code class="docutils literal notranslate"><span class="pre">3/2/1</span></code> refers to a vertex where the co-ordinates are given by the 3rd <code class="docutils literal notranslate"><span class="pre">v</span></code> line, the texture co-ordinates are given by the 2nd <code class="docutils literal notranslate"><span class="pre">vt</span></code> line and the normal vector is given by the 1st <code class="docutils literal notranslate"><span class="pre">vn</span></code> line.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">loadObj()</span></code> private member function in the Model class is quite simplistic and we need to make sure our .obj file is in the correct form. There are some model loading libraries available such as <a href="http://www.assimp.org" target="_blank">assimp</a> (open ASSet IMPorter library) that can handle most common object formats but use of this requires compiling source code and configuring the IDE which is a bit too fiddly for what we are doing here.</p>
</div>
<p>To see how you can use <a href="https://www.blender.org" target="_blank">Blender</a> to create .obj files <a class="reference internal" href="#blender-section"><span class="std std-ref">see below</span></a>.</p>
</section>
</section>
<hr class="docutils" />
<section id="phong-s-lighting-model">
<h2><span class="section-number">8.2. </span>Phong’s lighting model<a class="headerlink" href="#phong-s-lighting-model" title="Permalink to this heading">#</a></h2>
<p>Phong’s lighting model first described by Bui Tuong Phong is a local illumination model that simulates the interaction of light falling on surfaces. The brightness of a point on a surface is based on three components</p>
<ul class="simple">
<li><p><strong>ambient reflection</strong> – a simplified model of light that reflects off all objects in a scene</p></li>
<li><p><strong>diffuse reflection</strong> – describes the direct illumination of a surface by a light source based on the angle between the light source direction and the normal vector to the surface</p></li>
<li><p><strong>specular reflection</strong> – models the shiny highlights on a surface caused by a light source based on the angle between the light source direction, the normal vector and the view direction</p></li>
</ul>
<p>The colour intensity of a fragment on the surface is calculated as a sum of these components, i.e.,</p>
<div class="math notranslate nohighlight">
\[ \mathbf{colour} = \mathbf{ambient} + \mathbf{diffuse} + \mathbf{specular},\]</div>
<p>where theses are 3-element vectors of RGB colour values.</p>
<section id="ambient-reflection">
<h3><span class="section-number">8.2.1. </span>Ambient reflection<a class="headerlink" href="#ambient-reflection" title="Permalink to this heading">#</a></h3>
<p>Ambient reflection is light that is scatters off of all surfaces in a scene. To model this we simply assume that the object emits some light. The equation to do this is</p>
<div class="math notranslate nohighlight" id="equation-ambient-reflection-equation">
<span class="eqno">(8.1)<a class="headerlink" href="#equation-ambient-reflection-equation" title="Permalink to this equation">#</a></span>\[ \mathbf{ambient} = k_a \mathbf{O}_d \]</div>
<p>where <span class="math notranslate nohighlight">\(k_a\)</span> is known as the <strong>ambient reflection constant</strong> which takes on a value between 0 and 1 and <span class="math notranslate nohighlight">\(\mathbf{O}_d\)</span> is the object colour. <span class="math notranslate nohighlight">\(k_a\)</span> is a property of the object so we specify a value for this for each objects in our scene. Add the following code to the <strong>Lab08_Lighting.cpp</strong> file just before the render loop.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define teapot object lighting properties</span>
<span class="n">teapot</span><span class="p">.</span><span class="n">ka</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.2f</span><span class="p">;</span>
</pre></div>
</div>
<p>All of the lighting calculations will be performed by the shaders so we need to send the ambient constant to the fragment shader using a <a class="reference internal" href="03_textures.html#uniforms-section"><span class="std std-ref">uniform</span></a>. In the render loop add the following code after we activate the shader.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send light source properties to the shader</span>
<span class="n">glUniform1f</span><span class="w"> </span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ka&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">teapot</span><span class="p">.</span><span class="n">ka</span><span class="p">);</span>
</pre></div>
</div>
<p>Then edit <strong>fragmentShader.glsl</strong> to add the uniform for the ambient constant and use it calculate ambient lighting.</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="c1">// Inputs</span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">UV</span><span class="p">;</span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">;</span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>

<span class="c1">// Output</span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">fragmentColour</span><span class="p">;</span>

<span class="c1">// Uniforms</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">sampler2D</span><span class="w"> </span><span class="n">diffuseMap</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">ka</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Object colour</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">diffuseMap</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">));</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Ambient reflection</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ka</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Fragment colour</span>
<span class="w">    </span><span class="n">fragmentColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ambient</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Changing the value of <span class="math notranslate nohighlight">\(k_a\)</span> will make the colour of the teapot lighter or darker.</p>
<div class="sd-container-fluid sd-sphinx-override sd-mb-4 docutils">
<div class="sd-row docutils">
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="id1">
<img alt="../_images/08_teapot_ambient_0.2.png" src="../_images/08_teapot_ambient_0.2.png" />
<figcaption>
<p><span class="caption-number">Fig. 8.1 </span><span class="caption-text"><span class="math notranslate nohighlight">\(k_a=0.2\)</span></span><a class="headerlink" href="#id1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="id2">
<img alt="../_images/08_teapot_ambient_0.5.png" src="../_images/08_teapot_ambient_0.5.png" />
<figcaption>
<p><span class="caption-number">Fig. 8.2 </span><span class="caption-text"><span class="math notranslate nohighlight">\(k_a=0.5\)</span></span><a class="headerlink" href="#id2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="id3">
<img alt="../_images/08_teapot_ambient_0.8.png" src="../_images/08_teapot_ambient_0.8.png" />
<figcaption>
<p><span class="caption-number">Fig. 8.3 </span><span class="caption-text"><span class="math notranslate nohighlight">\(k_a=0.8\)</span></span><a class="headerlink" href="#id3" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="diffuse-reflection">
<h3><span class="section-number">8.2.2. </span>Diffuse reflection<a class="headerlink" href="#diffuse-reflection" title="Permalink to this heading">#</a></h3>
<p>Diffuse reflection is the reflection of light off a rough surface. Consider <a class="reference internal" href="#diffuse-reflection-figure"><span class="std std-numref">Fig. 8.4</span></a> that shows parallel light rays hitting a surface where light is scattered in multiple directions.</p>
<figure class="align-default" id="diffuse-reflection-figure">
<a class="reference internal image-reference" href="../_images/08_diffuse_reflection.svg"><img alt="../_images/08_diffuse_reflection.svg" src="../_images/08_diffuse_reflection.svg" width="400" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.4 </span><span class="caption-text">Light rays hitting a rough surface are scattered in all directions.</span><a class="headerlink" href="#diffuse-reflection-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To model diffuse reflection we assume that light is reflected equally in all directions (<a class="reference internal" href="#diffuse-figure"><span class="std std-numref">Fig. 8.5</span></a>).</p>
<figure class="align-default" id="diffuse-figure">
<a class="reference internal image-reference" href="../_images/08_diffuse.svg"><img alt="../_images/08_diffuse.svg" src="../_images/08_diffuse.svg" width="350" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.5 </span><span class="caption-text">Diffuse reflection scatters light equally in all directions.</span><a class="headerlink" href="#diffuse-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The amount of light that is reflected to the viewer is modelled using the angle <span class="math notranslate nohighlight">\(\theta\)</span> between the light vector <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> which points from the fragment to the light source and the normal vector <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> which points perpendicular to the surface. If <span class="math notranslate nohighlight">\(\theta\)</span> is small then the light source is directly in front of the surface so most of the light will be reflected to the viewer. Whereas if <span class="math notranslate nohighlight">\(\theta\)</span> is close to 90<span class="math notranslate nohighlight">\(^\circ\)</span> then the light source is nearly in line with the surface and little of the light will be reflected to the viewer. When <span class="math notranslate nohighlight">\(\theta &gt; 90^\circ\)</span> the light source is behind the surface so no light is reflected to the viewer. We model this using <span class="math notranslate nohighlight">\(\cos(\theta)\)</span> since <span class="math notranslate nohighlight">\(\cos(0^\circ) = 1\)</span> and <span class="math notranslate nohighlight">\(\cos(90^\circ)=0\)</span>. Diffuse reflection is calculated using</p>
<div class="math notranslate nohighlight" id="equation-diffuse-reflection-equation">
<span class="eqno">(8.2)<a class="headerlink" href="#equation-diffuse-reflection-equation" title="Permalink to this equation">#</a></span>\[ \mathbf{diffuse} = k_d \mathbf{I}_p \mathbf{O}_d \cos(\theta) ,\]</div>
<p>where <span class="math notranslate nohighlight">\(k_d\)</span> is known as the <strong>diffuse reflection constant</strong> which takes a value between 0 and 1, and <span class="math notranslate nohighlight">\(\mathbf{I}_p\)</span> is the colour intensity of the point light source. Recall that the angle between two vectors is related by <a class="reference internal" href="04_vectors_and_matrices.html#dot-product-section"><span class="std std-ref">dot product</span></a> so if the <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> vectors are unit vectors then <span class="math notranslate nohighlight">\(\cos(\theta) = \mathbf{L} \cdot \mathbf{n}\)</span>. If <span class="math notranslate nohighlight">\(\theta &gt; 90^\circ\)</span> then light source is behind the surface and no light should be reflected to the viewer. When <span class="math notranslate nohighlight">\(\theta\)</span> is between 90<span class="math notranslate nohighlight">\(^\circ\)</span> and 180<span class="math notranslate nohighlight">\(^\circ\)</span>, <span class="math notranslate nohighlight">\(\cos(\theta)\)</span> is negative so we limit the value of <span class="math notranslate nohighlight">\(\cos(\theta )\)</span> to positive values</p>
<div class="math notranslate nohighlight">
\[ \cos(\theta) = \max(\mathbf{L} \cdot \mathbf{n}, 0). \]</div>
<p>Like the ambient constant, the diffuse constant is a property of the object. Set the diffuse constant for our teapot by adding the following code where we defined the ambient constant</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">teapot</span><span class="p">.</span><span class="n">kd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.7f</span><span class="p">;</span>
</pre></div>
</div>
<p>and add the following after where we defined the object properties</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define light source properties</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">lightPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">lightColour</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we have defined a point light source positioned at <span class="math notranslate nohighlight">\((2, 2, 2)\)</span> in the world space and has a colour of white since the RGB values are <span class="math notranslate nohighlight">\((1, 1, 1)\)</span>.</p>
<p>All calculations performed in the fragment shader is done in the screen space so the vertex shader outputs <code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> which is the screen space vertex co-ordinates. However, we want to perform lighting calculations in the view space so we also need to calculate the view space co-ordinates of the object vertices and of the light source position. For the vertices we calculate the <span class="math notranslate nohighlight">\(MV\)</span> matrix that transforms from the model space to the view space</p>
<div class="math notranslate nohighlight">
\[MV = View \cdot Model,\]</div>
<p>and pass this, along with the view matrix for transforming the light source position to the view space, to the vertex shader using uniforms. Add the following code after the <span class="math notranslate nohighlight">\(MV\!P\)</span> matrix is sent to the shader.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send MV and view matrices to the vertex shader</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">MV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="p">;</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MV&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MV</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
<p>Now add the following code just after we send the colour of the ambient light to the shader to do the same for the diffuse light constant, colour and view space position.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glUniform1f</span><span class="w"> </span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;kd&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">teapot</span><span class="p">.</span><span class="n">kd</span><span class="p">);</span>
<span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lightColour&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lightColour</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">viewSpaceLightPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="n">lightPosition</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span>
<span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lightPosition&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewSpaceLightPosition</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
<p>OpenGL interpolates the outputs from the vertex shader and passes the interpolated values for each fragment to the fragment shader so we calculate view space versions of the fragment position, normal vector and light source positions in the vertex shader. The view space fragment position is calculated by multiplying the vertex position by the <span class="math notranslate nohighlight">\(MV\)</span> matrix, however the view space normal vector is calculated using the following transformation</p>
<div class="math notranslate nohighlight" id="equation-view-space-normal-equation">
<span class="eqno">(8.3)<a class="headerlink" href="#equation-view-space-normal-equation" title="Permalink to this equation">#</a></span>\[ \begin{align*}
    \mathbf{n}_{view} = (MV^{-1})^\mathsf{T} \mathbf{n}
\end{align*} \]</div>
<p>Recall that <span class="math notranslate nohighlight">\(A^\mathsf{T}\)</span> is the <a class="reference internal" href="04_vectors_and_matrices.html#transpose-section"><span class="std std-ref">transpose</span></a> and <span class="math notranslate nohighlight">\(A^{-1}\)</span> is the <a class="reference internal" href="04_vectors_and_matrices.html#inverse-matrix-section"><span class="std std-ref">inverse</span></a> of the matrix <span class="math notranslate nohighlight">\(A\)</span>. We use this transformation to ensure that the normal vector is perpendicular to the surface after the object vertices have been multiplied by the <span class="math notranslate nohighlight">\(MV\)</span> matrix. If you are interested in the derivation of this transformation, click on the dropdown link below.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Derivation of the view space normal transformation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">Consider the diagram in <a class="reference internal" href="#view-space-normal-1-figure"><span class="std std-numref">Fig. 8.6</span></a> that shows the normal and tangent vectors to a surface in the object space. If the combined model and view transformations preserves the scaling of the edge such the equal scaling is used in the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> axes then the normal and tangent vectors are perpendicular in the view space.</p>
<figure class="align-default" id="view-space-normal-1-figure">
<a class="reference internal image-reference" href="../_images/08_view_space_normal_1.svg"><img alt="../_images/08_view_space_normal_1.svg" src="../_images/08_view_space_normal_1.svg" width="200" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.6 </span><span class="caption-text">Normal and tangent vectors in the object space.</span><a class="headerlink" href="#view-space-normal-1-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text">If the model and view transformations do not preserve the scaling then the the view space normal vector is no longer perpendicular to the tangent vector (<a class="reference internal" href="#view-space-normal-2-figure"><span class="std std-numref">Fig. 8.7</span></a>).</p>
<figure class="align-default" id="view-space-normal-2-figure">
<a class="reference internal image-reference" href="../_images/08_view_space_normal_2.svg"><img alt="../_images/08_view_space_normal_2.svg" src="../_images/08_view_space_normal_2.svg" width="200" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.7 </span><span class="caption-text">Normal and tangent vectors in the view space.</span><a class="headerlink" href="#view-space-normal-2-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text">We need to derive a transformation matrix <span class="math notranslate nohighlight">\(A\)</span> that transforms the object space normal vector <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> to the view space normal vector <span class="math notranslate nohighlight">\(\mathbf{n}_{view}\)</span> such that it is perpendicular to the view space tangent vector <span class="math notranslate nohighlight">\(\mathbf{T}_{view}\)</span>. The view space normal and tangent vectors are calculated using</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \mathbf{n}_{view} &amp;= A \mathbf{n}, \\
    \mathbf{T}_{view} &amp;= MV \mathbf{T}.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">The dot product between two perpendicular vectors is zero, so</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
    \mathbf{n}_{view} \cdot \mathbf{T}_{view} &amp;= 0 \\
    \therefore A \mathbf{n} \cdot MV \mathbf{T} &amp;= 0.
\end{align*}\end{split}\]</div>
<p class="sd-card-text">We can replace the dot product by a matrix multiplication by transposing <span class="math notranslate nohighlight">\(A \mathbf{n}\)</span></p>
<div class="math notranslate nohighlight">
\[(A \mathbf{n})^\mathsf{T} MV \mathbf{T} = 0.\]</div>
<p class="sd-card-text">A property of matrix multiplication is that the transpose of a multiplication is equal to the multiplication of the transposes swapped (i.e., <span class="math notranslate nohighlight">\((AB)^\mathsf{T} = B^\mathsf{T} A^\mathsf{T}\)</span>) so we can write this as</p>
<div class="math notranslate nohighlight">
\[\mathbf{n}^\mathsf{T} A^\mathsf{T} MV \mathbf{T} = 0\]</div>
<p class="sd-card-text">If <span class="math notranslate nohighlight">\(A^\mathsf{T}  MV = I\)</span> then the view space normal and tangent vectors are perpendicular. Solving for <span class="math notranslate nohighlight">\(A\)</span> gives</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    A^\mathsf{T} MV &amp;=  I \\
    A^\mathsf{T} &amp;=  MV^{-1} \\
    A &amp;=  (MV^{-1})^\mathsf{T}.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">The matrix <span class="math notranslate nohighlight">\((MV^{-1})^\mathsf{T}\)</span> is the transformation matrix to transform the object space normal vectors to the view space that ensures the view space normal vectors are perpendicular to the surface.</p>
</div>
</details><p>Edit the vertex shader so that is looks like the following.</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="c1">// Inputs</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>

<span class="c1">// Outputs</span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">;</span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">UV</span><span class="p">;</span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">Normal</span><span class="p">;</span>

<span class="c1">// Uniforms</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">mat4</span><span class="w"> </span><span class="n">MVP</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">mat4</span><span class="w"> </span><span class="n">MV</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Output vertex position</span>
<span class="w">    </span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MVP</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Output texture co-ordinates</span>
<span class="w">    </span><span class="n">UV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Output view space fragment position and normal vector</span>
<span class="w">    </span><span class="n">fragmentPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="n">MV</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">));</span>
<span class="w">    </span><span class="n">Normal</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="kt">mat3</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="n">MV</span><span class="p">)))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we use the <span class="math notranslate nohighlight">\(MV\)</span> matrix to calculate the view space fragment position and use the transformation from equation <a class="reference internal" href="#equation-view-space-normal-equation">(8.3)</a> to calculate the normal vector in the view space.</p>
<p>In the fragment shader we need to input the view space fragment position and the normal vector outputted by the vertex shader as well as declaring the uniforms for the diffuse constant, light source position and colour. Edit the fragment shader so that it looks like the following.</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="c1">// Inputs</span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">UV</span><span class="p">;</span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">;</span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">Normal</span><span class="p">;</span>

<span class="c1">// Output</span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">fragmentColour</span><span class="p">;</span>

<span class="c1">// Uniforms</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">sampler2D</span><span class="w"> </span><span class="n">diffuseMap</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">ka</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">kd</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">lightColour</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">lightPosition</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Object colour</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">diffuseMap</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">));</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Ambient reflection</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ka</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Diffuse reflection</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">light</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">lightPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">normal</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosTheta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">light</span><span class="p">),</span><span class="w"> </span><span class="mo">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">kd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lightColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cosTheta</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Calculate fragment colour</span>
<span class="w">    </span><span class="n">fragmentColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diffuse</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we have added code to calculate diffuse reflection using equation <a class="reference internal" href="#equation-diffuse-reflection-equation">(8.2)</a>. Compile and run the program and you should see the result of applying ambient and diffuse reflection to the teapot as shown in <a class="reference internal" href="#teapot-diffuse-figure"><span class="std std-numref">Fig. 8.8</span></a>.</p>
<figure class="align-default" id="teapot-diffuse-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_diffuse.png"><img alt="../_images/08_teapot_diffuse.png" src="../_images/08_teapot_diffuse.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.8 </span><span class="caption-text">Ambient and diffuse reflection: <span class="math notranslate nohighlight">\(k_a = 0.2\)</span>, <span class="math notranslate nohighlight">\(k_d = 0.7\)</span>.</span><a class="headerlink" href="#teapot-diffuse-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>We now have visual cues as to the geometry of the teapot. Use the keyboard and mouse to view the teapot from different angles. You will notice that the side of the teapot facing away from the light source is darker since the angle between the normal vectors and the light source vector is larger.</p>
</section>
<section id="specular-reflection">
<h3><span class="section-number">8.2.3. </span>Specular reflection<a class="headerlink" href="#specular-reflection" title="Permalink to this heading">#</a></h3>
<p>Consider <a class="reference internal" href="#specular-reflection-figure"><span class="std std-numref">Fig. 8.9</span></a> that shows parallel light rays hitting a smooth surface where the reflected rays will point mostly in the same direction (think of a mirrored surface).</p>
<figure class="align-default" id="specular-reflection-figure">
<a class="reference internal image-reference" href="../_images/08_specular_reflection.svg"><img alt="../_images/08_specular_reflection.svg" src="../_images/08_specular_reflection.svg" width="400" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.9 </span><span class="caption-text">Light rays hitting a smooth surface are reflected in the same direction.</span><a class="headerlink" href="#specular-reflection-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Specular reflection depends upon the position of the light source and the fragment in the view space. Consider <a class="reference internal" href="#reflection-figure"><span class="std std-numref">Fig. 8.10</span></a> that shows a surface with a normal vector <span class="math notranslate nohighlight">\(\mathbf{n}\)</span>, a vector <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> pointing from the surface to a light source and a vector <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> pointing in the direction of reflected light off the surface. The angle between <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{n}\)</span>, <span class="math notranslate nohighlight">\(\theta\)</span> which is known as the incidence angle, and the angle between <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> are the same.</p>
<figure class="align-default" id="reflection-figure">
<a class="reference internal image-reference" href="../_images/08_reflection.svg"><img alt="../_images/08_reflection.svg" src="../_images/08_reflection.svg" width="350" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.10 </span><span class="caption-text">The light vector is reflected about the normal vector.</span><a class="headerlink" href="#reflection-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>If <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> are unit vectors then the <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> vector is calculated using</p>
<div class="math notranslate nohighlight">
\[ \begin{align*}
    \mathbf{R} = - \mathbf{L} + 2 (\mathbf{L} \cdot \mathbf{n}) \mathbf{n}
\end{align*} \]</div>
<p>If you are interested in the derivation of this formula, click on the dropdown below.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Derivation of the reflection vector<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">The <a href="https://en.wikipedia.org/wiki/Vector_projection" target="_blank">vector projection</a> of a vector <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> onto another vector <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is the vector <span class="math notranslate nohighlight">\(\operatorname{proj}_\mathbf{b} \mathbf{a}\)</span> that points in the same direction as <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> with a length that is equal to the adjacent side of a right-angled triangle where <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> is the hypotenuse and the vector <span class="math notranslate nohighlight">\(\operatorname{proj}_\mathbf{b} \mathbf{a}\)</span> is the adjacent side <a class="reference internal" href="#vector-projection-figure"><span class="std std-numref">Fig. 8.11</span></a>.</p>
<figure class="align-default" id="vector-projection-figure">
<a class="reference internal image-reference" href="../_images/08_vector_projection.svg"><img alt="../_images/08_vector_projection.svg" src="../_images/08_vector_projection.svg" width="250" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.11 </span><span class="caption-text">The projection of <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> onto <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>.</span><a class="headerlink" href="#vector-projection-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text"><span class="math notranslate nohighlight">\(\operatorname{proj}_\mathbf{b} \mathbf{a}\)</span> is represented by the green vector in <a class="reference internal" href="#vector-projection-figure"><span class="std std-numref">Fig. 8.11</span></a> and is calculated by multiplying the unit vector <span class="math notranslate nohighlight">\(\hat{\mathbf{b}}\)</span> by the length of the adjacent side of the right-angled triangle. Using trigonometry this gives</p>
<div class="math notranslate nohighlight">
\[ \operatorname{proj}_\mathbf{b} \mathbf{a} = \| \mathbf{a} \| \cos(\theta) \hat{\mathbf{b}}. \]</div>
<p class="sd-card-text">Recall that the geometric definition of the dot product is</p>
<div class="math notranslate nohighlight">
\[\mathbf{a} \cdot \mathbf{b} = \| \mathbf{a} \| \| \mathbf{b} \| \cos(\theta)\]</div>
<p class="sd-card-text">which can be rearranged to</p>
<div class="math notranslate nohighlight">
\[ \cos(\theta) = \frac{\mathbf{a} \cdot \mathbf{b}}{\| \mathbf{a} \| \| \mathbf{b} \|} \]</div>
<p class="sd-card-text">so</p>
<div class="math notranslate nohighlight">
\[ \begin{align*}
    \operatorname{proj}_\mathbf{b} \mathbf{a} = \| \mathbf{a} \| \frac{\mathbf{a} \cdot \mathbf{b}}{\| \mathbf{a} \| \| \mathbf{b} \|} \hat{\mathbf{b}} = (\mathbf{a} \cdot \hat{\mathbf{b}}) \hat{\mathbf{b}}
\end{align*} \]</div>
<p class="sd-card-text">Consider <a class="reference internal" href="#reflection-vector-figure"><span class="std std-numref">Fig. 8.12</span></a> that shows a surface with a normal vector <span class="math notranslate nohighlight">\(\mathbf{n}\)</span>, a light source vector <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> and a reflection vector <span class="math notranslate nohighlight">\(\mathbf{R}\)</span>.</p>
<figure class="align-default" id="reflection-vector-figure">
<a class="reference internal image-reference" href="../_images/08_reflection_vector.svg"><img alt="../_images/08_reflection_vector.svg" src="../_images/08_reflection_vector.svg" width="325" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.12 </span><span class="caption-text">Calculating the reflection vector <span class="math notranslate nohighlight">\(\mathbf{R}\)</span>.</span><a class="headerlink" href="#reflection-vector-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text">If <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> are unit vectors, then the reflection vector <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> can be calculated by reversing <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> and adding two projections <span class="math notranslate nohighlight">\((\mathbf{L} \cdot \mathbf{n}) \mathbf{n}\)</span> to it</p>
<div class="math notranslate nohighlight">
\[ \mathbf{R} = - \mathbf{L} + 2 (\mathbf{L} \cdot \mathbf{n}) \mathbf{n} \]</div>
</div>
</details><p>For a perfectly smooth surface the reflected ray will point in the direction of the <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> vector so in order to see the light the viewer would need to be positioned in the direction of the <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> vector. The position of the camera is represented by the <span class="math notranslate nohighlight">\(\mathbf{camera}\)</span> vector which points from the fragment to the camera (which is at <span class="math notranslate nohighlight">\((0,0,0)\)</span> in the view space). Since most surfaces are not perfectly smooth we add a bit of scattering to the model the amount of specular reflection seen by the viewer. This is determined by the angle <span class="math notranslate nohighlight">\(\alpha\)</span> between the <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> vector and the <span class="math notranslate nohighlight">\(\mathbf{camera}\)</span> vector. The closer the camera vector is to the reflection vector, the smaller the value of <span class="math notranslate nohighlight">\(\alpha\)</span> will be and the more of the light will be reflected towards the camera.</p>
<figure class="align-default" id="specular-figure">
<a class="reference internal image-reference" href="../_images/08_specular.svg"><img alt="../_images/08_specular.svg" src="../_images/08_specular.svg" width="400" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.13 </span><span class="caption-text">Specular reflection scatters light mainly towards the reflection vector.</span><a class="headerlink" href="#specular-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Phong modelled the scattering of the reflected light rays using <span class="math notranslate nohighlight">\(\cos(\alpha)\)</span> raised to a power</p>
<div class="math notranslate nohighlight" id="equation-specular-reflection-equation">
<span class="eqno">(8.4)<a class="headerlink" href="#equation-specular-reflection-equation" title="Permalink to this equation">#</a></span>\[\mathbf{specular} = k_s \mathbf{I}_p \cos(\alpha)^{N_s},\]</div>
<p>where <span class="math notranslate nohighlight">\(k_s\)</span> is the <strong>specular reflection constant</strong> similar to its ambient and diffuse counterparts and <span class="math notranslate nohighlight">\(N_s\)</span> is the <strong>specular exponent</strong> that determines the size of the specular highlights. If <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{camera}\)</span> are unit vectors, then <span class="math notranslate nohighlight">\(\cos(\alpha)\)</span> can be calculated using the dot product between the <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{camera}\)</span> vector limited to positive values</p>
<div class="math notranslate nohighlight">
\[ \cos(\alpha) = \max(\mathbf{camera} \cdot \mathbf{R}, 0)^{N_s}.\]</div>
<p>In the <strong>Lab08_Lighting.cpp</strong> file, specify the following values for the specular constant and exponent</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">teapot</span><span class="p">.</span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="n">teapot</span><span class="p">.</span><span class="n">Ns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20.0f</span><span class="p">;</span>
</pre></div>
</div>
<p>and send the specular light source constant and exponent to the shader where we did this for the ambient and diffuse colours.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ks&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">teapot</span><span class="p">.</span><span class="n">ks</span><span class="p">);</span>
<span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Ns&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">teapot</span><span class="p">.</span><span class="n">Ns</span><span class="p">);</span>
</pre></div>
</div>
<p>In the fragment shader add uniforms for the specular light source values</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">ks</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Ns</span><span class="p">;</span>
</pre></div>
</div>
<p>and in the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function add specular refection to our teapot.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Specular reflection</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">camera</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">reflection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">light</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">light</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">cosAlpha</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span><span class="w"> </span><span class="n">reflection</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">ks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lightColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cosAlpha</span><span class="p">,</span><span class="w"> </span><span class="n">Ns</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we calculate the <span class="math notranslate nohighlight">\(\mathbf{camera}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> vectors before calculating the specular reflection using equation <a class="reference internal" href="#equation-specular-reflection-equation">(8.4)</a> (the <code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y)</span></code> function calculates <span class="math notranslate nohighlight">\(x^y\)</span>).  Now we just need to add the specular reflection to the fragment colour.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Fragment colour</span>
<span class="n">fragmentColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span>
</pre></div>
</div>
<p>Compile and run your program and you should see the image shown in <a class="reference internal" href="#teapot-specular-figure"><span class="std std-numref">Fig. 8.14</span></a>.</p>
<figure class="align-default" id="teapot-specular-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_specular.png"><img alt="../_images/08_teapot_specular.png" src="../_images/08_teapot_specular.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.14 </span><span class="caption-text">Ambient, diffuse and reflection: <span class="math notranslate nohighlight">\(k_a = 0.2\)</span>, <span class="math notranslate nohighlight">\(k_d = 0.7\)</span>, <span class="math notranslate nohighlight">\(k_s = 1.0\)</span>, <span class="math notranslate nohighlight">\(N_s = 20\)</span>.</span><a class="headerlink" href="#teapot-specular-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Move the camera around the teapot and notice how the specular highlights (the white bits) change due to the position of the camera and the normal vectors of the teapot surface.</p>
</section>
</section>
<hr class="docutils" />
<section id="attenuation">
<h2><span class="section-number">8.3. </span>Attenuation<a class="headerlink" href="#attenuation" title="Permalink to this heading">#</a></h2>
<p><strong>Attenuation</strong> is the gradual decrease in light intensity as the distance between the light source and a surface increases. We can use attenuation to model light from low intensity light source, for example, a candle or torch which will only illuminate an area close to the source. Theoretically attenuation should follow the inverse square law where the light intensity is inversely proportional to the square of the distance between the light source and the surface. However, in practice this tends to result in a scene that is too dark so we calculate attenuation using an inverse quadratic function</p>
<div class="math notranslate nohighlight">
\[ attenuation = \frac{1}{constant + linear \cdot d + quadratic \cdot d^2}, \]</div>
<p>where <span class="math notranslate nohighlight">\(d\)</span> is the distance between the light source and the fragment and <span class="math notranslate nohighlight">\(constant\)</span>, <span class="math notranslate nohighlight">\(linear\)</span> and <span class="math notranslate nohighlight">\(quadratic\)</span> are coefficients that determine how quickly the light intensity decreases. The graph in <a class="reference internal" href="#attenuation-figure"><span class="std std-numref">Fig. 8.15</span></a> shows a typical attenuation profile where the light intensity rapidly decreases when the distance is small levelling off as the distance gets larger.</p>
<figure class="align-default" id="attenuation-figure">
<a class="reference internal image-reference" href="../_images/08_attenuation.svg"><img alt="../_images/08_attenuation.svg" src="../_images/08_attenuation.svg" width="500" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.15 </span><span class="caption-text">Attenuation can be modelled by an inverse quadratic function.</span><a class="headerlink" href="#attenuation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To add attenuation to our scene define the attenuation coefficients in the <strong>Lab08_Lighting.cpp</strong> file where we defined the other lighting properties</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">constant</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1f</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">quadratic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.02f</span><span class="p">;</span>
</pre></div>
</div>
<p>These values depend on the type of light source being modelled, here we have a weak light source to demonstrate the loss of light intensity over space but for stronger light sources you may wish to experiment with these values. Send the attenuation coefficients to the fragment shader using a uniform like we did for the other lighting properties.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glUniform1f</span><span class="w"> </span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;constant&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">constant</span><span class="p">);</span>
<span class="n">glUniform1f</span><span class="w"> </span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;linear&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">linear</span><span class="p">);</span>
<span class="n">glUniform1f</span><span class="w"> </span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;quadratic&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">quadratic</span><span class="p">);</span>
</pre></div>
</div>
<p>In the fragment shader declare the uniforms for the attenuation coefficients</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">constant</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">quadratic</span><span class="p">;</span>
</pre></div>
</div>
<p>and then in the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function add the code to calculate and apply attenuation.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Attenuation</span>
<span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">lightPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">attenuation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">constant</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">quadratic</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="p">);</span>

<span class="c1">// Fragment colour</span>
<span class="n">fragmentColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">specular</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">attenuation</span><span class="p">;</span>
</pre></div>
</div>
<p>To demonstrate the affects of applying attenuation we are going to need some more objects that a positioned a different distances from the light source. In your <strong>Lab08_Lighting.cpp</strong> file before the render loop define arrays for the position vectors and rotation angles for the teapots (taken from the multiple cubes example from <a class="reference internal" href="06_3D_worlds.html#multiple-objects-section"><span class="std std-ref">Lab06 3D Worlds</span></a>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Teapot positions</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">teapotPositions</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">5.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-10.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">-3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-3.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">-4.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-8.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-6.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">-4.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-8.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-5.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-4.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">-1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">// Teapot rotation angles</span>
<span class="kt">float</span><span class="w"> </span><span class="n">teapotAngles</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">teapotAngles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">20.0f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
</pre></div>
</div>
<p>Replace the code used to calculate the model, <span class="math notranslate nohighlight">\(MVP\)</span> and <span class="math notranslate nohighlight">\(MV\)</span> matrices as well as drawing the teapot with the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send the view matrix to the shader</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;V&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">camera</span><span class="p">.</span><span class="n">view</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>

<span class="c1">// Loop through objects</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Calculate model matrix</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">teapotPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.75f</span><span class="p">));</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">rotate</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">teapotAngles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">));</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Send the MVP and MV matrices to the vertex shader</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">MV</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">MVP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">MV</span><span class="p">;</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MVP&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MVP</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MV&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MV</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Draw the model</span>
<span class="w">    </span><span class="n">teapot</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">shaderID</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It would also be useful to render the light source. After the for loop to draw the teapots add the following code</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ---------------------------------------------------------------------</span>
<span class="c1">// Draw light sources</span>
<span class="c1">// Activate light source shader</span>
<span class="n">glUseProgram</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">);</span>

<span class="c1">// Calculate model matrix</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">lightPosition</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.1f</span><span class="p">));</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>

<span class="c1">// Send the MVP and MV matrices to the vertex shader</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">MVP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="p">;</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MVP&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MVP</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>

<span class="c1">// Send model, view, projection matrices and light colour to light shader</span>
<span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lightColour&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lightColour</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="c1">// Draw light source</span>
<span class="n">sphere</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">);</span>
<span class="c1">// ---------------------------------------------------------------------</span>
</pre></div>
</div>
<p>Moving the camera to a different position allows us to see the affects of attenuation (<a class="reference internal" href="#teapot-attenuation-figure"><span class="std std-numref">Fig. 8.16</span></a>). Note how the teapots further away from the light source are darker as the light intensity has been reduced.</p>
<figure class="align-default" id="teapot-attenuation-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_attenuation.png"><img alt="../_images/08_teapot_attenuation.png" src="../_images/08_teapot_attenuation.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.16 </span><span class="caption-text">The affects of applying attenuation.</span><a class="headerlink" href="#teapot-attenuation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<hr class="docutils" />
<section id="multiple-light-sources">
<h2><span class="section-number">8.4. </span>Multiple light sources<a class="headerlink" href="#multiple-light-sources" title="Permalink to this heading">#</a></h2>
<p>To add another light sources to a scene is simply a matter of calculating the ambient, diffuse and specular reflection for the additional light source and then adding them to the fragment colour. We have seen for a single light source we have to define the three light source colours, the position of the light source in the world space and the three attenuation constants. Given that we would like to do this for multiple light sources we need data structure for each light source.</p>
<p>A data structure in C++ and GLSL is defined in a similar way using the <a href="https://cplusplus.com/doc/tutorial/structures/" target="_blank">struct</a> declaration.</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="n">Light</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">colour</span><span class="p">;</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">constant</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">quadratic</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This defines a data structure called <code class="docutils literal notranslate"><span class="pre">Light</span></code> that contains the information required to calculate the lighting model for a single light source. In the fragment shader we can create a uniform for an array of <code class="docutils literal notranslate"><span class="pre">Light</span></code> data structures.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uniform</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numLights</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">Light</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</pre></div>
</div>
<p>This defines a 10 element array of <code class="docutils literal notranslate"><span class="pre">Light</span></code> data structures (assuming we have a maximum of 10 light sources) and the actual number of lights sources we have is passed in using the <code class="docutils literal notranslate"><span class="pre">numLights</span></code> uniform. Then all we need to do is loop through each of the light sources, calculate the fragment colour for the current source and add it to the total fragment colour. Open the file <strong>multipleLightsFragmentShader.glsl</strong> in the <strong>Lab08_Lighting/</strong> folder and you should see the following.</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="cp"># define maxLights 10</span>

<span class="c1">// Inputs</span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">UV</span><span class="p">;</span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">;</span>
<span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">Normal</span><span class="p">;</span>

<span class="c1">// Outputs</span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">fragmentColour</span><span class="p">;</span>

<span class="c1">// Light struct</span>
<span class="k">struct</span><span class="w"> </span><span class="n">Light</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">colour</span><span class="p">;</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">constant</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">quadratic</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Uniforms</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">sampler2D</span><span class="w"> </span><span class="n">diffuseMap</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">ka</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">kd</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">ks</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Ns</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="n">Light</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="n">maxLights</span><span class="p">];</span>

<span class="c1">// Function prototypes</span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">pointLight</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">lightPosition</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">lightColour</span><span class="p">,</span>
<span class="w">                </span><span class="kt">float</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">quadratic</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">fragmentColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numLights</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Determine light properties for current light source</span>
<span class="w">        </span><span class="kt">vec3</span><span class="w"> </span><span class="n">lightPosition</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">;</span>
<span class="w">        </span><span class="kt">vec3</span><span class="w"> </span><span class="n">lightColour</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">colour</span><span class="p">;</span>
<span class="w">        </span><span class="kt">vec3</span><span class="w"> </span><span class="n">lightDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">direction</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">constant</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">constant</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">linear</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">quadratic</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">quadratic</span><span class="p">;</span>
<span class="w">        </span>
<span class="w">        </span><span class="c1">// Calculate point light</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">            </span><span class="n">fragmentColour</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pointLight</span><span class="p">(</span><span class="n">lightPosition</span><span class="p">,</span><span class="w"> </span><span class="n">lightColour</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="n">linear</span><span class="p">,</span><span class="w"> </span><span class="n">quadratic</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Calculate point light</span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">pointLight</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">lightPosition</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">lightColour</span><span class="p">,</span><span class="w"> </span>
<span class="w">                </span><span class="kt">float</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">quadratic</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Object colour</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">diffuseMap</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">));</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Ambient reflection</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ka</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Diffuse reflection</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">light</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">lightPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">normal</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosTheta</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">light</span><span class="p">),</span><span class="w"> </span><span class="mo">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">kd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lightColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cosTheta</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Specular reflection</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">reflection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">light</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">light</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">camera</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosAlpha</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span><span class="w"> </span><span class="n">reflection</span><span class="p">),</span><span class="w"> </span><span class="mo">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">specular</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">ks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lightColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cosAlpha</span><span class="p">,</span><span class="w"> </span><span class="n">Ns</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Attenuation</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">lightPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">attenuation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">constant</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">+</span>
<span class="w">                               </span><span class="n">quadratic</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Fragment colour</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">specular</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we have defined a function prototype for the function <code class="docutils literal notranslate"><span class="pre">pointLight()</span></code> that contains the commands used to calculate the fragment colour for a single point light source. In the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function we have a for loop to loop through each light source, perform the light calculations for the current light source and add it to the fragment colour.</p>
<p>We also need to make changes to the <strong>Lab08_Lighting.cpp</strong> file. Add the <code class="docutils literal notranslate"><span class="pre">Light</span></code> data structure before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function declaration</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Light struct</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Light</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">colour</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">constant</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">quadratic</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Since we are using a different file for the fragment shader we need to tell OpenGL to use our new fragment shader which it compiles the shader program.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Compile shader programs</span>
<span class="n">shaderID</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">LoadShaders</span><span class="p">(</span><span class="s">&quot;vertexShader.glsl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;multipleLightsFragmentShader.glsl&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>We now define the lighting properties for multiple lights sources using our <code class="docutils literal notranslate"><span class="pre">Light</span></code> structure in a C++ <a href="https://en.cppreference.com/w/cpp/container/vector" target="_blank">vector</a>. Where we defined the colour and position of the single light source, replace the code with the following</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create vector of light sources</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Light</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lightSources</span><span class="p">;</span>

<span class="c1">// Add first point light source</span>
<span class="n">Light</span><span class="w"> </span><span class="n">light</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">);</span>
<span class="n">light</span><span class="p">.</span><span class="n">colour</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
<span class="n">light</span><span class="p">.</span><span class="n">constant</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">linear</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">quadratic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.02f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">type</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">lightSources</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">light</span><span class="p">);</span>

<span class="c1">// Add second point light source</span>
<span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-8.0f</span><span class="p">);</span>
<span class="n">light</span><span class="p">.</span><span class="n">colour</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
<span class="n">light</span><span class="p">.</span><span class="n">constant</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">linear</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">quadratic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.02f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">type</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">lightSources</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">light</span><span class="p">);</span>
</pre></div>
</div>
<p>This code creates two light sources, defines the values of the data structures and stores then in the <code class="docutils literal notranslate"><span class="pre">lightSources</span></code> vector. The <code class="docutils literal notranslate"><span class="pre">lightSources.push_back(light)</span></code> command adds the current light source to the end of the <code class="docutils literal notranslate"><span class="pre">lightSources</span></code> vector. Now we need to send the light and material values to the shader using uniforms, comment out the code used to send the light properties to the shader and add the code below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send multiple light source properties to the shader</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numLights</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lightSources</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="n">glUniform1i</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;numLights&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">numLights</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numLights</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">viewSpaceLightPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lightSources[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].colour&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">colour</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lightSources[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].position&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewSpaceLightPosition</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="w"> </span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lightSources[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].constant&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">constant</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="w"> </span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lightSources[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].linear&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">linear</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="w"> </span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lightSources[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].quadratic&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">quadratic</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform1i</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="w"> </span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lightSources[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].type&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Send object lighting properties to the fragment shader</span>
<span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ka&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">teapot</span><span class="p">.</span><span class="n">ka</span><span class="p">);</span>
<span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;kd&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">teapot</span><span class="p">.</span><span class="n">kd</span><span class="p">);</span>
<span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ks&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">teapot</span><span class="p">.</span><span class="n">ks</span><span class="p">);</span>
<span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Ns&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">teapot</span><span class="p">.</span><span class="n">Ns</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we simply loop through the vector of light sources and send the values for each individual light to the shader (unfortunately we can’t send a vector of structs using a uniform, we could use <a href="https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)" target="_blank">GLSL interface blocks</a> but I wanted to keep things simple here).</p>
<p>Finally to draw each light source we loop through each of the light sources and change the translation matrix and light source colour uniform for the current light. Comment out the exist code used to calculate the model matrix and draw the light source and add the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numLights</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Calculate model matrix</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.1f</span><span class="p">));</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Send the MVP and MV matrices to the vertex shader</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">MVP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="p">;</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MVP&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MVP</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>

<span class="w">    </span><span class="c1">// Send model, view, projection matrices and light colour to light shader</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lightColour&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">colour</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="w">    </span><span class="c1">// Draw light source</span>
<span class="w">    </span><span class="n">sphere</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Hopefully once you’ve made all of the changes it compiles and runs to show the following</p>
<figure class="align-default" id="multiple-lights-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_multiple_lights.png"><img alt="../_images/08_teapot_multiple_lights.png" src="../_images/08_teapot_multiple_lights.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.17 </span><span class="caption-text">Teapots lit using 2 light sources.</span><a class="headerlink" href="#multiple-lights-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Use the keyboard and mouse to move the camera around the teapots to see the affects of the light sources.</p>
</section>
<hr class="docutils" />
<section id="spotlights">
<h2><span class="section-number">8.5. </span>Spotlights<a class="headerlink" href="#spotlights" title="Permalink to this heading">#</a></h2>
<p>A spotlight is a light source that emits light along a specific direction vector so that only those objects that are within some distance of this vector are illuminated. These are useful for modelling light sources such as flashlights, street lights, car headlights etc.</p>
<figure class="align-default" id="spot-light-figure">
<a class="reference internal image-reference" href="../_images/08_spot_light.svg"><img alt="../_images/08_spot_light.svg" src="../_images/08_spot_light.svg" width="350" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.18 </span><span class="caption-text">A spotlight only illuminates fragments where <span class="math notranslate nohighlight">\(\theta &lt; \phi\)</span>.</span><a class="headerlink" href="#spot-light-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Consider <a class="reference internal" href="#spot-light-figure"><span class="std std-numref">Fig. 8.18</span></a> that shows a spotlight emitting light in the direction given by the <span class="math notranslate nohighlight">\(\mathbf{d}\)</span> vector. The <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> vector points from the light source position to the position of the fragment and the angle <span class="math notranslate nohighlight">\(\phi\)</span> determines the spread of the light. If the angle <span class="math notranslate nohighlight">\(\theta\)</span> between <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{d}\)</span> is less than <span class="math notranslate nohighlight">\(\phi\)</span> then the fragment is illuminated by the spotlight.</p>
<p>To add spotlights to our scene we need to add attributes to the <code class="docutils literal notranslate"><span class="pre">Light</span></code> data structure for the direction vector <span class="math notranslate nohighlight">\(\mathbf{d}\)</span> and the value of <span class="math notranslate nohighlight">\(\cos(\phi)\)</span> in the fragment shader</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">cosPhi</span><span class="p">;</span>
</pre></div>
</div>
<p>We will be defining a function called <code class="docutils literal notranslate"><span class="pre">spotLight()</span></code> to calculate our spotlight but first we need to declare the function prototype before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="nf">spotLight</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">lightPosition</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">direction</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">lightColour</span><span class="p">,</span>
<span class="w">               </span><span class="kt">float</span><span class="w"> </span><span class="n">cosPhi</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">quadratic</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">spotLight()</span></code> function is below, copy and paste this (or type if out) after the <code class="docutils literal notranslate"><span class="pre">pointLight()</span></code> function.</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate spotlight</span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">spotLight</span><span class="p">(</span><span class="kt">vec3</span><span class="w"> </span><span class="n">lightPosition</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">lightDirection</span><span class="p">,</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">lightColour</span><span class="p">,</span>
<span class="w">               </span><span class="kt">float</span><span class="w"> </span><span class="n">cosPhi</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">quadratic</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Object colour</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">diffuseMap</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">));</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Ambient reflection</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ka</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Diffuse reflection</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">light</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">lightPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">normal</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosTheta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">light</span><span class="p">),</span><span class="w"> </span><span class="mo">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">kd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lightColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cosTheta</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Specular reflection</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">reflection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">light</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">light</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">camera</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosAlpha</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span><span class="w"> </span><span class="n">reflection</span><span class="p">),</span><span class="w"> </span><span class="mo">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">specular</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">ks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lightColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cosAlpha</span><span class="p">,</span><span class="w"> </span><span class="n">Ns</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Attenuation</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">lightPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">attenuation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">constant</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">+</span>
<span class="w">                               </span><span class="n">quadratic</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Directional light intensity</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">direction</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">lightDirection</span><span class="p">);</span>
<span class="w">    </span><span class="n">cosTheta</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">light</span><span class="p">,</span><span class="w"> </span><span class="n">direction</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cosTheta</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">cosPhi</span><span class="p">)</span>
<span class="w">        </span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Return fragment colour</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">specular</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">attenuation</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">intensity</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After calculating the ambient, diffuse and specular reflection and attenuation in the same way as for the point light sources we have additional code to calculate <span class="math notranslate nohighlight">\(\cos(\theta)\)</span> between the <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{d}\)</span> vectors. A float <code class="docutils literal notranslate"><span class="pre">intensity</span></code> is calculated so that its value is 1 if <span class="math notranslate nohighlight">\(\cos(\theta) &gt; \cos(\phi)\)</span> so <span class="math notranslate nohighlight">\(\theta &gt; \phi\)</span> and 0 otherwise. This is then multiplied by the ambient, diffuse and specular reflections so the lighting is turned on or off depending on the position of the fragment.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function of the fragment shader, add the following to the for loop to calculate the spotlight sources</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate spotlight</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="n">fragmentColour</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">spotLight</span><span class="p">(</span><span class="n">lightPosition</span><span class="p">,</span><span class="w"> </span><span class="n">lightDirection</span><span class="p">,</span><span class="w"> </span><span class="n">lightColour</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                </span><span class="n">cosPhi</span><span class="p">,</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="n">linear</span><span class="p">,</span><span class="w"> </span><span class="n">quadratic</span><span class="p">);</span>
</pre></div>
</div>
<p>So here we are using a <code class="docutils literal notranslate"><span class="pre">type</span></code> value of 1 to specify a point light source and a value of 2 to specify a spotlight source.</p>
<p>Now we need to define our spotlight source values in the <strong>Lab08_Lighting.cpp</strong> file which is done in a similar way to the point light sources. Add the <code class="docutils literal notranslate"><span class="pre">direction</span></code> and <code class="docutils literal notranslate"><span class="pre">cosPhi</span></code> attributes to the <code class="docutils literal notranslate"><span class="pre">Light</span></code> data structure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">cosPhi</span><span class="p">;</span>
</pre></div>
</div>
<p>and after we defined our point light sources add the following code to add a single spotlight source.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Add spotlight</span>
<span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">light</span><span class="p">.</span><span class="n">colour</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">light</span><span class="p">.</span><span class="n">constant</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">linear</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">quadratic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.02f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">cosPhi</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">Maths</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">45.0f</span><span class="p">));</span>
<span class="n">light</span><span class="p">.</span><span class="n">type</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">lightSources</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">light</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we have defined a single spotlight which is positioned above the first teapot at <span class="math notranslate nohighlight">\((0, 3, 0)\)</span> and with a direction vector pointing straight down so <span class="math notranslate nohighlight">\(\mathbf{d} = (0, -1, 0)\)</span>. The colour of the spotlight is yellow since the RGB values are <span class="math notranslate nohighlight">\((1, 1, 0)\)</span> and the spread angle of the light is <span class="math notranslate nohighlight">\(\phi = 45^\circ\)</span>. We have also specified that this light source has a <code class="docutils literal notranslate"><span class="pre">type</span></code> value of 2 for a spotlight. Note that we are only going to use one spotlight for now but have the ability to add more if we want.</p>
<p>We need to send the additional <code class="docutils literal notranslate"><span class="pre">direction</span></code> and <code class="docutils literal notranslate"><span class="pre">cosPhi</span></code> values to the shader so where we send the other light properties, add the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">viewSpaceLightDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">direction</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">));</span>
<span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lightSources[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].direction&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewSpaceLightDirection</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="w"> </span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lightSources[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].cosPhi&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cosPhi</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that here we calculate the direction vector of the spotlight in the view space by multiplying it by the view matrix. Fingers crossed everything compiles and runs ok and you are presented with the following.</p>
<figure class="align-default" id="directional-light-harsh-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_spotlight_harsh.png"><img alt="../_images/08_teapot_spotlight_harsh.png" src="../_images/08_teapot_spotlight_harsh.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.19 </span><span class="caption-text">Teapots lit using a spotlight.</span><a class="headerlink" href="#directional-light-harsh-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Use the keyboard and mouse to move the camera around the teapots. You may notice that there is an abrupt cutoff between the region illuminated by the spotlight and the region in darkness. In the real world this doesn’t usually happen as light on this edge gets softened by various effects. We can model this softening by dividing the difference between <span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span> by some small angle <span class="math notranslate nohighlight">\(\delta\)</span> and limiting the values to between 0 and 1. The effect of this can be seen in <a class="reference internal" href="#soft-edge-figure"><span class="std std-numref">Fig. 8.20</span></a> where the intensity is 1 until <span class="math notranslate nohighlight">\(\phi - \delta\)</span> where it reduces to 0 at <span class="math notranslate nohighlight">\(\phi\)</span>. So using this will gradually reduce the intensity are the edge of the illuminated region.</p>
<figure class="align-default" id="soft-edge-figure">
<a class="reference internal image-reference" href="../_images/08_soft_edge.svg"><img alt="../_images/08_soft_edge.svg" src="../_images/08_soft_edge.svg" width="600" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.20 </span><span class="caption-text">Intensity value over a range of <span class="math notranslate nohighlight">\(\theta\)</span>.</span><a class="headerlink" href="#soft-edge-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Replace the <code class="docutils literal notranslate"><span class="pre">intensity</span></code> calculation with the following to soften the edge of the spotlight.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">delta</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">radians</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clamp</span><span class="p">((</span><span class="n">cosTheta</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">lightSource</span><span class="p">.</span><span class="n">cosPhi</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">clamp(x,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> limits the value of <code class="docutils literal notranslate"><span class="pre">x</span></code> so that is is not less than <code class="docutils literal notranslate"><span class="pre">a</span></code> and not greater than <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<figure class="align-default" id="directional-light-soft-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_spotlight_soft.png"><img alt="../_images/08_teapot_spotlight_soft.png" src="../_images/08_teapot_spotlight_soft.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.21 </span><span class="caption-text">Teapots lit using a spotlight with softened edges.</span><a class="headerlink" href="#directional-light-soft-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<hr class="docutils" />
<section id="directional-light">
<h2><span class="section-number">8.6. </span>Directional light<a class="headerlink" href="#directional-light" title="Permalink to this heading">#</a></h2>
<p>The final light source type we will look at is <strong>directional light</strong>. When a light source is far away the light rays are very close to being parallel. It does not matter where the object is in the view space as all objects are lit from the same direction.</p>
<figure class="align-default" id="directional-light-figure">
<a class="reference internal image-reference" href="../_images/08_directional_light.svg"><img alt="../_images/08_directional_light.svg" src="../_images/08_directional_light.svg" width="400" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.22 </span><span class="caption-text">Directional lighting</span><a class="headerlink" href="#directional-light-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The lighting calculations are the same as for the other light sources seen above with the exception that we do not need the light source position and we do not apply the attenuation. The light vector <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> is simply the direction vector <span class="math notranslate nohighlight">\(\mathbf{d}\)</span> negated.</p>
<p>We are going to use a function to calculate the directional lighting, add the function prototype before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="nf">directionalLight</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">lightDirection</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">lightColour</span><span class="p">);</span>
</pre></div>
</div>
<p>and then copy and paste (or type out) the following code at the bottom of the file</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate directional light</span>
<span class="n">vec3</span><span class="w"> </span><span class="nf">directionalLight</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">lightDirection</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">lightColour</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Object colour</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">diffuseMap</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">));</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Ambient reflection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ka</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Diffuse reflection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">light</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">lightDirection</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosTheta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">light</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">kd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lightColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cosTheta</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Specular reflection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">reflection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">light</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">light</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">camera</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosAlpha</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span><span class="w"> </span><span class="n">reflection</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">ks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lightColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cosAlpha</span><span class="p">,</span><span class="w"> </span><span class="n">Ns</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Return fragment colour</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once we’ve defined the function to calculate the directional light we need to tell our <code class="docutils literal notranslate"><span class="pre">main()</span></code> function to use it and add the directional light colour to the fragment colour. Add the following code to the for loop.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate directional light</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lightSources</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w">    </span><span class="n">fragmentColour</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">directionalLight</span><span class="p">(</span><span class="n">lightDirection</span><span class="p">,</span><span class="w"> </span><span class="n">lightColour</span><span class="p">);</span>
</pre></div>
</div>
<p>Now we need to define a directional light source in the <strong>Lab08_Lighting.cpp</strong> file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Add directional light</span>
<span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">light</span><span class="p">.</span><span class="n">colour</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">light</span><span class="p">.</span><span class="n">type</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="n">lightSources</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">light</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we define a directional light source with rays coming down from the top left as we look down the <span class="math notranslate nohighlight">\(z\)</span>-axis. We have also specified that our directional light source is red since the RBG values are <span class="math notranslate nohighlight">\((1, 0, 0)\)</span>.</p>
<p>Run your program and you should see something similar to the following</p>
<figure class="align-default" id="teapot-directional-light-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_directional_light.png"><img alt="../_images/08_teapot_directional_light.png" src="../_images/08_teapot_directional_light.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 8.23 </span><span class="caption-text">Directional and point light sources.</span><a class="headerlink" href="#teapot-directional-light-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>We can see that the teapots have been illuminated from a directional light source from the left hand side in addition to the two point light sources and the spotlight.</p>
</section>
<hr class="docutils" />
<section id="exercises">
<h2><span class="section-number">8.7. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Experiment with the positions, colours and material properties of the various light sources to see what effects they have.</p></li>
<li><p>Use a spotlight to model a flashlight controlled by the user such that the light is positioned at <code class="docutils literal notranslate"><span class="pre">camera.position</span></code>, is pointing in the same direction as <code class="docutils literal notranslate"><span class="pre">camera.direction</span></code> and has a spread of <span class="math notranslate nohighlight">\(\phi = 20^\circ\)</span>. Turn off all other light sources (either by commenting out code or setting the colours to zero) for extra spookiness.</p></li>
</ol>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/10_exercise_2.mp4" type="video/mp4">
</video>
</center>
<ol class="arabic simple" start="3">
<li><p>Change the colour of the second point light source to magenta and rotate its position in a circle centred at (0,0,-5) with radius 5. Turn off any spotlights and directional lighting. Hint: the co-ordinates of points on a circle can be calculated using <span class="math notranslate nohighlight">\((x, y, z) = (0,0,-5) + 5 * (\cos({\tt time}), 0, \sin(\tt time))\)</span>.</p></li>
</ol>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/10_exercise_3.mp4" type="video/mp4">
</video>
</center>
<ol class="arabic simple" start="4">
<li><p>The planet Narkov has a red sun and a single day lasts for just 5 of our seconds. Use directional lighting to model the illumination of the sun as it passes through the sky and also beneath the horizon (fortunately Narkovians like tea so using our teapots would not seem unusual). The background colour can also be changed to match the colour of the light source.</p></li>
</ol>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/10_exercise_4.mp4" type="video/mp4">
</video>
</center>
<hr class="docutils" />
</section>
<section id="creating-an-obj-file-in-blender">
<span id="blender-section"></span><h2><span class="section-number">8.8. </span>Creating an .obj file in Blender<a class="headerlink" href="#creating-an-obj-file-in-blender" title="Permalink to this heading">#</a></h2>
<p>To create an .obj file we can use the popular open source application <a href="https://www.blender.org" target="_blank">Blender</a> (this is installed on the machines in the Dalton building).</p>
<ol class="arabic simple">
<li><p>Create your object in blender and sort out the material textures, UV co-ordinates etc. (lots of tutorials on youtube to help you with this). Or you can import a model produced by someone else (be sure to give credit if doing this).</p></li>
<li><p>Click on <strong>File &gt; Export &gt; Wavefront (.obj)</strong></p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/08_blender_export_obj_1.png"><img alt="../_images/08_blender_export_obj_1.png" src="../_images/08_blender_export_obj_1.png" style="width: 600px;" /></a>
</figure>
<ol class="arabic simple" start="3">
<li><p>Make sure <strong>Include Normals</strong>, <strong>Include UVs</strong> and <strong>Triangular Faces</strong> are selected.</p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/08_blender_export_obj_2.png"><img alt="../_images/08_blender_export_obj_2.png" src="../_images/08_blender_export_obj_2.png" style="width: 600px;" /></a>
</figure>
<ol class="arabic simple" start="4">
<li><p>Navigate to your chosen folder e.g., <code class="docutils literal notranslate"><span class="pre">Lab10_Lighting/objects/</span></code>, and give it an appropriate name.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Model class that we are using here is very simple and will only work with simple models.</p>
</div>
</section>
<hr class="docutils" />
<section id="video-walkthrough">
<h2><span class="section-number">8.9. </span>Video walkthrough<a class="headerlink" href="#video-walkthrough" title="Permalink to this heading">#</a></h2>
<p>The video below walks you through these lab materials.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/v9e_557Wl_U?si=6fLfaMWJL5s3P5Qs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="07_Moving_the_camera.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">7. </span>Moving the camera</p>
      </div>
    </a>
    <a class="right-next"
       href="09_Normal_mapping.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">9. </span>Normal Mapping</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-model-class">8.1. The Model class</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wavefront-obj-files">8.1.1. Wavefront (.obj) files</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#phong-s-lighting-model">8.2. Phong’s lighting model</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ambient-reflection">8.2.1. Ambient reflection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffuse-reflection">8.2.2. Diffuse reflection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#specular-reflection">8.2.3. Specular reflection</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#attenuation">8.3. Attenuation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multiple-light-sources">8.4. Multiple light sources</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spotlights">8.5. Spotlights</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#directional-light">8.6. Directional light</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">8.7. Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-an-obj-file-in-blender">8.8. Creating an .obj file in Blender</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#video-walkthrough">8.9. Video walkthrough</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dr Jon Shiach
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>