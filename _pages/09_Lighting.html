

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>9. Lighting &#8212; Computer Graphics</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"vec": ["\\mathbf{#1}", 1], "model": ["M\\!odel"], "view": ["V\\!iew"], "mvp": ["MV\\!P"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/08_Lighting';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="10. Normal Mapping" href="09_Normal_mapping.html" />
    <link rel="prev" title="8. Quaternions" href="10_Quaternions.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Computer Graphics
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_intro_to_cpp.html">1. Introduction to C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_basic_shapes_in_OpenGL.html">2. Basic Shapes in OpenGL</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_textures.html">3. Textures</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_vectors_and_matrices.html">4. Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_transformations.html">5. Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_3D_worlds.html">6. 3D Worlds</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_Moving_the_camera.html">7. Moving the camera</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_Quaternions.html">8. Quaternions</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">9. Lighting</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_Normal_mapping.html">10. Normal Mapping</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="A_Complex_numbers_and_quaternions.html">A. Complex Numbers and Quaternions</a></li>
<li class="toctree-l1"><a class="reference internal" href="B_Code.html">B. Code and Assets</a></li>
<li class="toctree-l1"><a class="reference internal" href="C_Glossary.html">C Glossary</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs/issues/new?title=Issue%20on%20page%20%2F_pages/08_Lighting.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/_pages/08_Lighting.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Lighting</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-model-class">9.1. The Model class</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wavefront-obj-files">9.1.1. Wavefront (.obj) files</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#phong-s-lighting-model">9.2. Phong’s lighting model</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ambient-reflection">9.2.1. Ambient reflection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffuse-reflection">9.2.2. Diffuse reflection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#specular-reflection">9.2.3. Specular reflection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#attenuation">9.2.4. Attenuation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multiple-light-sources">9.3. Multiple light sources</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spotlights">9.4. Spotlights</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#directional-light">9.5. Directional light</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">9.6. Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">9.7. Source code</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-an-obj-file-in-blender">9.8. Creating an .obj file in Blender</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#video-walkthrough">9.9. Video walkthrough</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="lighting">
<span id="lighting-section"></span><h1><span class="section-number">9. </span>Lighting<a class="headerlink" href="#lighting" title="Permalink to this heading">#</a></h1>
<p>In this lab we will be looking at adding a basic lighting model to our application. Lighting modelling is in itself a huge topic within the field of computer graphics and modern games and movies can look very lifelike thanks to some very clever techniques. Lighting models come in two main types: local illumination and global illumination:</p>
<ul class="simple">
<li><p><strong>local illumination</strong> - the colour and brightness of individual points on a surface are determined by the light emanating from one or more light sources.</p></li>
<li><p><strong>global illumination</strong> - the colour and brightness of individual points on a surface are determine both by the light emanating from light sources <strong>in addition to</strong> light that is reflected off of other objects in the scene.</p></li>
</ul>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/08_local_global_illumination.svg"><img alt="../_images/08_local_global_illumination.svg" src="../_images/08_local_global_illumination.svg" width="500" /></a>
</figure>
<p>Here we will be applying a local illumination model since they are easier to apply than global illumination and quicker to compute. The downside is that they don’t produce a rendering as realistic than with global illumination.</p>
<p>Compile and run the project and you will see the window below showing a wire frame representation of the Utah teapot.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/08_teapot_wireframe.png"><img alt="../_images/08_teapot_wireframe.png" src="../_images/08_teapot_wireframe.png" style="width: 500px;" /></a>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Utah teapot is a standard test model for computer graphics first created in 1975 by Martin Newell whilst at the University of Utah. It has become a bit of an in-joke in the computer graphics community and has appeared in Pixar’s <em>Toy Story</em> and in <em>The Simpsons</em> episode <em>Treehouse of Horror VI</em>.</p>
</div>
<p>The teapot has been rendered as a wire frame model since in the absence of light and shadow we wouldn’t be able to tell that it was in fact a 3D model. We can turn of the wire frame rendering by commenting out the line <code class="docutils literal notranslate"><span class="pre">glPolygonMode(GL_FRONT_AND_BACK,</span> <span class="pre">GL_LINE);</span></code>. Do this and you should see the following.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/08_teapot_solid.png"><img alt="../_images/08_teapot_solid.png" src="../_images/08_teapot_solid.png" style="width: 500px;" /></a>
</figure>
<section id="the-model-class">
<h2><span class="section-number">9.1. </span>The Model class<a class="headerlink" href="#the-model-class" title="Permalink to this heading">#</a></h2>
<p>If you take a look at the source code in the <code class="docutils literal notranslate"><span class="pre">Lab10_Lighting/source</span></code> folder you will notice that in addition to the classes introduced in previous labs (Texture, Shader and Camera) we have an addition class called Model which is defined in the <code class="docutils literal notranslate"><span class="pre">model.hpp</span></code> and <code class="docutils literal notranslate"><span class="pre">model.cpp</span></code> files. The Model class has been written so that we can load the vertex and texture co-ordinates from external files rather than having to define these in our code. Take a look at the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file where the following Model class methods have been called:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Model</span> <span class="pre">teapot(&quot;../objects/teapot.obj)</span></code> - this is the constructor for the Model class and creates an object called <code class="docutils literal notranslate"><span class="pre">teapot</span></code>, loads the vertex co-ordinates, texture co-ordinates and vertex normals from an .obj file (see below) and creates the VAO and relevant buffers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">teapot.addTexture(&quot;../objects/blue.bmp&quot;,</span> <span class="pre">&quot;diffuse&quot;);</span></code> - this method loads a texture map called <code class="docutils literal notranslate"><span class="pre">blue.bmp</span></code> and sets its type to <code class="docutils literal notranslate"><span class="pre">diffuse</span></code>. The texture loader now uses a library so our textures no longer have to be bitmaps.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">teapot.draw(shaderID)</span></code> - this method binds the objects buffers and textures and instructs OpenGL to draw the model.</p></li>
</ul>
<section id="wavefront-obj-files">
<h3><span class="section-number">9.1.1. </span>Wavefront (.obj) files<a class="headerlink" href="#wavefront-obj-files" title="Permalink to this heading">#</a></h3>
<p>The Model class includes a private member function called <code class="docutils literal notranslate"><span class="pre">loadObj()</span></code> written by contributors of <a href = "https://www.opengl-tutorial.org" target="_blank">opengl-tutorial.org</a> which loads in a <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file" target="_blank"><strong>wavefront (.obj)</strong></a> file. A wavefront file is one of the many different types of file that is used to describe 3D models in computer graphics. In the <code class="docutils literal notranslate"><span class="pre">Lab10_Lighting/objects/</span></code> folder you will see some <code class="docutils literal notranslate"><span class="pre">.obj</span></code> files. Open the <code class="docutils literal notranslate"><span class="pre">cube.obj</span></code> file using a text editor and you will see the following.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># Blender 4.0.2
# www.blender.org
mtllib cube.mtl
o Cube
v 1.000000 1.000000 -1.000000
v 1.000000 -1.000000 -1.000000
v 1.000000 1.000000 1.000000
v 1.000000 -1.000000 1.000000
v -1.000000 1.000000 -1.000000
v -1.000000 -1.000000 -1.000000
v -1.000000 1.000000 1.000000
v -1.000000 -1.000000 1.000000
vn -0.0000 1.0000 -0.0000
vn -0.0000 -0.0000 1.0000
vn -1.0000 -0.0000 -0.0000
vn -0.0000 -1.0000 -0.0000
vn 1.0000 -0.0000 -0.0000
vn -0.0000 -0.0000 -1.0000
vt 0.875000 0.500000
vt 0.625000 0.750000
vt 0.625000 0.500000
vt 0.375000 0.990255
vt 0.375000 0.750000
vt 0.625000 0.008121
vt 0.375000 0.250000
vt 0.375000 0.008121
vt 0.375000 0.500000
vt 0.125000 0.750000
vt 0.125000 0.500000
vt 0.625000 0.250000
vt 0.875000 0.750000
vt 0.625000 0.988631
s 0
usemtl Material
f 5/1/1 3/2/1 1/3/1
f 3/2/2 8/4/2 4/5/2
f 7/6/3 6/7/3 8/8/3
f 2/9/4 8/10/4 6/11/4
f 1/3/5 4/5/5 2/9/5
f 5/12/6 2/9/6 6/7/6
f 5/1/1 7/13/1 3/2/1
f 3/2/2 7/14/2 8/4/2
f 7/6/3 5/12/3 6/7/3
f 2/9/4 4/5/4 8/10/4
f 1/3/5 3/2/5 4/5/5
f 5/12/6 1/3/6 2/9/6
</pre></div>
</div>
<p>The vertex and face data is given in lines with the following abbreviations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> - the <span class="math notranslate nohighlight">\(\mathsf{(x, y, z)}\)</span> co-ordinates of a vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vn</span></code> - the <span class="math notranslate nohighlight">\(\mathsf{(n_x, n_y, n_z)}\)</span> normal vector for the vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vt</span></code> - the <span class="math notranslate nohighlight">\(\mathsf{(u, v)}\)</span> texture co-ordinates</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> - indices of the vertices of a face. Each face is defined by 3 vertices so we have 3 sets of 3 values. The face vertices are of the form <code class="docutils literal notranslate"><span class="pre">v/vt/vn</span></code> so <code class="docutils literal notranslate"><span class="pre">3/2/1</span></code> refers to a vertex where the co-ordinates are given by the 3rd <code class="docutils literal notranslate"><span class="pre">v</span></code> line, the texture co-ordinates are given by the 2nd <code class="docutils literal notranslate"><span class="pre">vt</span></code> line and the normal vector is given by the 1st <code class="docutils literal notranslate"><span class="pre">vn</span></code> line.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">loadObj()</span></code> private member function in the Model class is quite simplistic and we need to make sure our .obj file is in the correct form. There are some model loading libraries available such as <a href="http://www.assimp.org" target="_blank">assimp</a> (open ASSet IMPorter library) that can handle most common object formats but use of this requires compiling source code and configuring the IDE which is a bit too fiddly for what we are doing here.</p>
</div>
<p>To see how you can use <a href="https://www.blender.org" target="_blank">Blender</a> to create .obj files <a class="reference internal" href="#blender-section"><span class="std std-ref">see below</span></a>.</p>
</section>
</section>
<hr class="docutils" />
<section id="phong-s-lighting-model">
<h2><span class="section-number">9.2. </span>Phong’s lighting model<a class="headerlink" href="#phong-s-lighting-model" title="Permalink to this heading">#</a></h2>
<p>Phong’s lighting model first described by Bui Tuong Phong is a local illumination model that simulates the interaction of light falling on surfaces. The brightness of a point on a surface is based on three components</p>
<ul class="simple">
<li><p><strong>ambient reflection</strong> - a simplified model of light that reflects off all objects in a scene</p></li>
<li><p><strong>diffuse reflection</strong> - describes the direct illumination of a surface by a light source based on the angle between the light source direction and the normal vector to the surface</p></li>
<li><p><strong>specular reflection</strong> - models the shiny highlights on a surface caused by a light source based on the angle between the light source direction, the normal vector and the view direction</p></li>
</ul>
<p>The colour of a fragment on the surface is calculated as a sum of these components, i.e.,</p>
<div class="math notranslate nohighlight">
\[ \texttt{fragment colour}  = \texttt{ambient} + \texttt{diffuse} + \texttt{specular}.\]</div>
<p>All colours are defined as 3-element vectors containing the RGB colour values.</p>
<section id="ambient-reflection">
<h3><span class="section-number">9.2.1. </span>Ambient reflection<a class="headerlink" href="#ambient-reflection" title="Permalink to this heading">#</a></h3>
<p>Ambient reflection is light that is scatters off of all surfaces in a scene. To model this we use a massive cheat, we assume that all fragments of the object are lit equally with the same amount of intensity. The equation to do this is</p>
<div class="math notranslate nohighlight">
\[ \texttt{ambient} = k_a * \texttt{light colour} * \texttt{object colour}\]</div>
<p>where <span class="math notranslate nohighlight">\(k_a\)</span> is the <strong>ambient reflection constant</strong> that determines the amount of ambient lighting used, <span class="math notranslate nohighlight">\(\texttt{light colour}\)</span> is the colour of the light source and <span class="math notranslate nohighlight">\(\texttt{object colour}\)</span> is the colour of the fragment (usually determined by a texture map). Lets create a light source and calculate the ambient lighting. We need to create a vector for the light colour and send it to the shaders using a uniform. Add the following code to the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file just before the render loop.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define object properties</span>
<span class="kt">float</span><span class="w"> </span><span class="n">ka</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.2f</span><span class="p">;</span><span class="w">    </span><span class="c1">// ambient constant</span>

<span class="c1">// Define light colours</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">white</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">lightAmbient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ka</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">white</span><span class="p">;</span><span class="w">                    </span><span class="c1">// ambient light colour</span>
</pre></div>
</div>
<p>Here we have defined the ambient constant for the teapot as <span class="math notranslate nohighlight">\(k_a=0.2\)</span> and the <span class="math notranslate nohighlight">\(\texttt{light colour}\)</span> as white. In the render loop add the following code just before we calculate the model matrix to send the <code class="docutils literal notranslate"><span class="pre">lightAmbient</span></code> to the shaders.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send light source properties to the shader</span>
<span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lightAmbient&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lightAmbient</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
<p>Then edit <code class="docutils literal notranslate"><span class="pre">fragmentShader.frag</span></code> so that it takes in the <code class="docutils literal notranslate"><span class="pre">lightAmbient</span></code> uniform and calculates the ambient reflection.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="c1">// Interpolated values from the vertex shaders</span>
<span class="n">in</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">UV</span><span class="p">;</span>

<span class="c1">// Output data</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">fragmentColour</span><span class="p">;</span>

<span class="c1">// Uniforms</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">sampler2D</span><span class="w"> </span><span class="n">diffuse1</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">lightAmbient</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Object colour</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">diffuse1</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// Ambient reflection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lightAmbient</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Fragment colour</span>
<span class="w">    </span><span class="n">fragmentColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ambient</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Changing the value of <span class="math notranslate nohighlight">\(k_a\)</span> will make the colour of the teapot lighter or darker.</p>
<div class="sd-container-fluid sd-sphinx-override sd-mb-4 docutils">
<div class="sd-row docutils">
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="id1">
<img alt="../_images/08_teapot_ambient_0.2.png" src="../_images/08_teapot_ambient_0.2.png" />
<figcaption>
<p><span class="caption-number">Fig. 9.1 </span><span class="caption-text"><span class="math notranslate nohighlight">\(k_a=0.2\)</span></span><a class="headerlink" href="#id1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="id2">
<img alt="../_images/08_teapot_ambient_0.5.png" src="../_images/08_teapot_ambient_0.5.png" />
<figcaption>
<p><span class="caption-number">Fig. 9.2 </span><span class="caption-text"><span class="math notranslate nohighlight">\(k_a=0.5\)</span></span><a class="headerlink" href="#id2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="id3">
<img alt="../_images/08_teapot_ambient_0.8.png" src="../_images/08_teapot_ambient_0.8.png" />
<figcaption>
<p><span class="caption-number">Fig. 9.3 </span><span class="caption-text"><span class="math notranslate nohighlight">\(k_a=0.8\)</span></span><a class="headerlink" href="#id3" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="diffuse-reflection">
<h3><span class="section-number">9.2.2. </span>Diffuse reflection<a class="headerlink" href="#diffuse-reflection" title="Permalink to this heading">#</a></h3>
<p>Diffuse and specular reflection depend upon the position of the light source and the fragment in the view space. Introducing a <span class="math notranslate nohighlight">\(\tt light\)</span> vector that points from the position of the fragment to the light source and <span class="math notranslate nohighlight">\(\tt normal\)</span> which is the surface normal for the fragment. The direction that light is reflected off the surface is described by the <span class="math notranslate nohighlight">\(\tt reflection\)</span> vector which makes the same angle <span class="math notranslate nohighlight">\(\theta\)</span> to the <span class="math notranslate nohighlight">\(\tt normal\)</span> vector that the <span class="math notranslate nohighlight">\(\tt light\)</span> vector does.</p>
<figure class="align-default" id="reflection-figure">
<a class="reference internal image-reference" href="../_images/08_reflection.svg"><img alt="../_images/08_reflection.svg" src="../_images/08_reflection.svg" width="350" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.4 </span><span class="caption-text">The light vector is reflected about the normal vector.</span><a class="headerlink" href="#reflection-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>If <span class="math notranslate nohighlight">\(\texttt{normal}\)</span> and <span class="math notranslate nohighlight">\(\texttt{light}\)</span> are unit vectors then the <span class="math notranslate nohighlight">\(\tt reflection\)</span> vector is calculated using</p>
<div class="math notranslate nohighlight">
\[ \begin{align*}
    \texttt{reflection} = - \texttt{light} + 2 (\texttt{light} \cdot \texttt{normal}) \texttt{normal}.
\end{align*} \]</div>
<p>Diffuse reflection is the reflection of light off a rough surface. Consider <a class="reference internal" href="#diffuse-reflection-figure"><span class="std std-numref">Fig. 9.5</span></a> that shows parallel light rays hitting a surface. Since the the normal vectors vary across a rough surface then the light rays are scattered in multiple directions.</p>
<figure class="align-default" id="diffuse-reflection-figure">
<a class="reference internal image-reference" href="../_images/08_diffuse_reflection.svg"><img alt="../_images/08_diffuse_reflection.svg" src="../_images/08_diffuse_reflection.svg" width="400" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.5 </span><span class="caption-text">Light rays hitting a rough surface are scattered in all directions.</span><a class="headerlink" href="#diffuse-reflection-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To model diffuse reflection we assume that light is reflected equally in all directions (<a class="reference internal" href="#diffuse-figure"><span class="std std-numref">Fig. 9.6</span></a>).</p>
<figure class="align-default" id="diffuse-figure">
<a class="reference internal image-reference" href="../_images/08_diffuse.svg"><img alt="../_images/08_diffuse.svg" src="../_images/08_diffuse.svg" width="350" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.6 </span><span class="caption-text">Diffuse reflection scatters light equally in all directions.</span><a class="headerlink" href="#diffuse-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The amount of light that is reflected to the viewer is modelled using the angle <span class="math notranslate nohighlight">\(\theta\)</span> between the <span class="math notranslate nohighlight">\(\tt light\)</span> and <span class="math notranslate nohighlight">\(\tt normal\)</span> vectors. If <span class="math notranslate nohighlight">\(\theta\)</span> is small then the light source is directly in front of the surface so most of the light will be reflected to the viewer. Whereas if <span class="math notranslate nohighlight">\(\theta\)</span> is close to 90<span class="math notranslate nohighlight">\(^\circ\)</span> then the light source is nearly in line with the surface and little of the light will be reflected to the viewer. When <span class="math notranslate nohighlight">\(\theta &gt; 90^\circ\)</span> the light source is behind the surface so no light is reflected to the viewer. We model this using the cosine of <span class="math notranslate nohighlight">\(\theta\)</span> since <span class="math notranslate nohighlight">\(\cos(0^\circ) = 1\)</span> and <span class="math notranslate nohighlight">\(\cos(90^\circ)=0\)</span>. Diffuse reflection is calculated using</p>
<div class="math notranslate nohighlight">
\[ \texttt{diffuse} = k_d * \texttt{light colour} * \texttt{object colour} * \cos(\theta),\]</div>
<p>where <span class="math notranslate nohighlight">\(k_d\)</span> is the <strong>diffuse reflection constant</strong> that determines the amount of diffuse lighting seen by the viewer. Recall that the angle between two vectors is related by <a class="reference internal" href="04_vectors_and_matrices.html#dot-product-section"><span class="std std-ref">dot product</span></a> so if the <span class="math notranslate nohighlight">\(\tt light\)</span> and <span class="math notranslate nohighlight">\(\tt normal\)</span> vectors are unit vectors then <span class="math notranslate nohighlight">\(\cos(\theta) = \tt light \cdot normal\)</span>. If <span class="math notranslate nohighlight">\(\theta &gt; 90^\circ\)</span> then light source is behind the surface and no light should be reflected to the viewer. When <span class="math notranslate nohighlight">\(\theta\)</span> is between 90<span class="math notranslate nohighlight">\(^\circ\)</span> and 180<span class="math notranslate nohighlight">\(^\circ\)</span>, <span class="math notranslate nohighlight">\(\cos(\theta)\)</span> is negative so we limit the value of <span class="math notranslate nohighlight">\(\cos(\theta )\)</span> between 0 and 1.</p>
<p>Lets define a position for a light source and the colour of the diffuse light. Define a float for the the diffuse constant and set its value to <span class="math notranslate nohighlight">\(k_d = 0.7\)</span></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">kd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.7f</span><span class="p">;</span><span class="w">    </span><span class="c1">// diffuse constant</span>
</pre></div>
</div>
<p>and add the following after where we defined the ambient light colour.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">lightDiffuse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">white</span><span class="p">;</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">lightPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">);</span>
</pre></div>
</div>
<p>So the light source is positioned at (2,2,2) and the diffuse light is pure white.</p>
<p>All calculations performed in the fragment shader is done in the view space and the <code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> which is calculated in the vertex shader is the screen space vertex position so we also need to calculate the view space co-ordinates of the light source position. We could do this in the vertex shader but since the light position is the same for all fragments it is better do this in the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file rather than recalculating it for each fragment in the shaders. Add the following code just after we sent the colour of the ambient light to the shader to do the same for the diffuse light and the light position.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">viewSpaceLightPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="n">lightPosition</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span>
<span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lightDiffuse&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lightDiffuse</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lightPosition&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewSpaceLightPosition</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
<p>As well as the view space light position co-ordinates we also need view space versions of the fragment position and normal vector. OpenGL interpolates the outputs from the vertex shader and passes the interpolated values for each fragment to the fragment shader so we calculate view space fragment position and normal in the vertex shader.The view space fragment position is calculated by multiplying <code class="docutils literal notranslate"><span class="pre">position</span></code> by the <code class="docutils literal notranslate"><span class="pre">view</span></code> and <code class="docutils literal notranslate"><span class="pre">model</span></code> matrices. The view space normal vector is calculated using</p>
<div class="math notranslate nohighlight" id="equation-view-space-normal-equation">
<span class="eqno">(9.1)<a class="headerlink" href="#equation-view-space-normal-equation" title="Permalink to this equation">#</a></span>\[ \begin{align*}
    \texttt{view space normal} = ((\textsf{view matrix} * \textsf{model matrix})^{-1})^\mathsf{T} * \tt normal.
\end{align*} \]</div>
<p>Recall that <span class="math notranslate nohighlight">\(A^\mathsf{T}\)</span> is the <a class="reference internal" href="04_vectors_and_matrices.html#transpose-section"><span class="std std-ref">transpose</span></a> and <span class="math notranslate nohighlight">\(A^{-1}\)</span> is the <a class="reference internal" href="04_vectors_and_matrices.html#inverse-matrix-section"><span class="std std-ref">inverse</span></a> of the matrix <span class="math notranslate nohighlight">\(A\)</span>. You don’t need to know why we use this equation but if you are curious click on the download link below.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Derivation of the view space normal transformation<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">Consider the diagram in <a class="reference internal" href="#view-space-normal-1-figure"><span class="std std-numref">Fig. 9.7</span></a> that shows the normal and tangent vectors to a surface in the object space. If the combined model and view transformations preserves the scaling of the edge such the equal scaling is used in the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> axes then the normal and tangent vectors are perpendicular in the view space.</p>
<figure class="align-default" id="view-space-normal-1-figure">
<a class="reference internal image-reference" href="../_images/08_view_space_normal_1.svg"><img alt="../_images/08_view_space_normal_1.svg" src="../_images/08_view_space_normal_1.svg" width="200" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.7 </span><span class="caption-text">Normal and tangent vectors in the object space.</span><a class="headerlink" href="#view-space-normal-1-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text">If the model and view transformations do not preserve the scaling then the the view space normal vector is no longer perpendicular to the tangent vector (<a class="reference internal" href="#view-space-normal-2-figure"><span class="std std-numref">Fig. 9.8</span></a>).</p>
<figure class="align-default" id="view-space-normal-2-figure">
<a class="reference internal image-reference" href="../_images/08_view_space_normal_2.svg"><img alt="../_images/08_view_space_normal_2.svg" src="../_images/08_view_space_normal_2.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.8 </span><span class="caption-text">Normal and tangent vectors in the view space.</span><a class="headerlink" href="#view-space-normal-2-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text">Let <span class="math notranslate nohighlight">\(M\)</span> be the first 3 rows and columns of the <span class="math notranslate nohighlight">\(\textsf{view matrix} * \textsf{model matrix}\)</span> then the view space tangent vector is calculated using <span class="math notranslate nohighlight">\(M * {\tt tangent}\)</span> (here I’ve used <span class="math notranslate nohighlight">\(*\)</span> to denote column major matrix multiplication so that it is consistent with our code). We need to derive a <span class="math notranslate nohighlight">\(3\times 3\)</span> transformation matrix <span class="math notranslate nohighlight">\(A\)</span> such that the view space normal vector is calculated using <span class="math notranslate nohighlight">\(A * {\tt normal}\)</span> where this is perpendicular to the view space tangent vector, i.e.,</p>
<div class="math notranslate nohighlight">
\[(A * {\tt normal}) \cdot (M * {\tt tangent}) = 0.\]</div>
<p class="sd-card-text">We can replace the dot product by a matrix multiplication by transposing <span class="math notranslate nohighlight">\((A * {\tt normal})\)</span></p>
<div class="math notranslate nohighlight">
\[(A * {\tt normal})^\mathsf{T} * (M * {\tt tangent} )= 0.\]</div>
<p class="sd-card-text">A property of matrix multiplication is that the transpose of a multiplication is equal to the multiplication of the transposes swapped (i.e., <span class="math notranslate nohighlight">\((A * B)^\mathsf{T} = B^\mathsf{T} * A^\mathsf{T}\)</span>) so we can write this as</p>
<div class="math notranslate nohighlight">
\[{\tt normal}^\textsf{T} * A^\mathsf{T} * M * {\tt tangent} = 0.\]</div>
<p class="sd-card-text">If <span class="math notranslate nohighlight">\(A^\mathsf{T} * M = I\)</span> then the view space normal and tangent vectors are perpendicular. Solving for <span class="math notranslate nohighlight">\(A\)</span> gives</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    A^\mathsf{T} * M &amp;=  I \\
    A^\mathsf{T} &amp;=  M^{-1} \\
    A &amp;=  (M^{-1})^\mathsf{T}.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Since <span class="math notranslate nohighlight">\(M = \textsf{view} * \textsf{model}\)</span> then the matrix that transforms a model space normal vector to the view space is <span class="math notranslate nohighlight">\(A = ((\textsf{view matrix} * \textsf{model matrix})^{-1})^\mathsf{T}\)</span></p>
</div>
</details><p>Edit <code class="docutils literal notranslate"><span class="pre">vertexShader.vert</span></code> so that is looks like the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="c1">// Input vertex data</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>

<span class="c1">// Output data</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">UV</span><span class="p">;</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">;</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">Normal</span><span class="p">;</span>

<span class="c1">// Uniforms</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">view</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">projection</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Output vertex position</span>
<span class="w">    </span><span class="n">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Output (u,v) co-ordinates</span>
<span class="w">    </span><span class="n">UV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Output view space fragment position and normal</span>
<span class="w">    </span><span class="n">fragmentPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">));</span>
<span class="w">    </span><span class="n">Normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mat3</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="p">)))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">fragmentShader.frag</span></code> we need let OpenGL know we are importing <code class="docutils literal notranslate"><span class="pre">fragmentPosition</span></code> and <code class="docutils literal notranslate"><span class="pre">Normal</span></code> from the vertex shader so add the following at the top where we import the <code class="docutils literal notranslate"><span class="pre">UV</span></code> co-ordinates.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">Normal</span><span class="p">;</span>
<span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">;</span>
</pre></div>
</div>
<p>Add <code class="docutils literal notranslate"><span class="pre">vec3</span></code> uniforms for the <code class="docutils literal notranslate"><span class="pre">lightPosition</span></code> and <code class="docutils literal notranslate"><span class="pre">lightDiffuse</span></code> vectors</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uniform</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">lightDiffuse</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">lightPosition</span><span class="p">;</span>
</pre></div>
</div>
<p>and in the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function add the following to calculate diffuse reflection.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Diffuse reflection</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">light</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">lightPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">cosTheta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">light</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lightDiffuse</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cosTheta</span><span class="p">;</span>
</pre></div>
</div>
<p>Finally add the diffuse reflection to the ambient reflection to calculate the fragment colour.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Fragment colour</span>
<span class="n">fragmentColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diffuse</span><span class="p">;</span>
</pre></div>
</div>
<p>The result of applying ambient and diffuse reflection is shown in <a class="reference internal" href="#teapot-diffuse-figure"><span class="std std-numref">Fig. 9.9</span></a>.</p>
<figure class="align-default" id="teapot-diffuse-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_diffuse.png"><img alt="../_images/08_teapot_diffuse.png" src="../_images/08_teapot_diffuse.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.9 </span><span class="caption-text">Ambient and diffuse reflection: <span class="math notranslate nohighlight">\(k_a = 0.2\)</span>, <span class="math notranslate nohighlight">\(k_d = 0.7\)</span>.</span><a class="headerlink" href="#teapot-diffuse-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Use the keyboard and mouse to view the teapot from different angles. You should notice that the side of the teapot facing away from the light source is darker.</p>
</section>
<section id="specular-reflection">
<h3><span class="section-number">9.2.3. </span>Specular reflection<a class="headerlink" href="#specular-reflection" title="Permalink to this heading">#</a></h3>
<p>Consider <a class="reference internal" href="#specular-reflection-figure"><span class="std std-numref">Fig. 9.10</span></a> that shows parallel light rays hitting a smooth surface. The normal vectors will be similar across the surface so the reflected rays will point mostly in the same directions. This is known as <strong>specular reflection</strong>.</p>
<figure class="align-default" id="specular-reflection-figure">
<a class="reference internal image-reference" href="../_images/08_specular_reflection.svg"><img alt="../_images/08_specular_reflection.svg" src="../_images/08_specular_reflection.svg" width="400" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.10 </span><span class="caption-text">Light rays hitting a smooth surface are reflected in the same direction.</span><a class="headerlink" href="#specular-reflection-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>For a perfectly smooth surface the reflected ray will point in the direction of the <span class="math notranslate nohighlight">\(\tt reflection\)</span> vector so in order to see the light the viewer would need to be positioned in the direction of the <span class="math notranslate nohighlight">\(\tt reflection\)</span> vector. The position of the viewer is represented by the <span class="math notranslate nohighlight">\(\texttt{eye}\)</span> vector with points from the fragment to the camera (which is at (0,0,0). Since most surfaces are not perfectly smooth we add a bit of scattering to the model the amount of specular reflection seen by the viewer. This is determined by the angle <span class="math notranslate nohighlight">\(\alpha\)</span> between the <span class="math notranslate nohighlight">\(\tt reflection\)</span> vector and the <span class="math notranslate nohighlight">\(\tt eye\)</span> vector. The closer the viewer is to the reflection vector, the smaller the value of <span class="math notranslate nohighlight">\(\alpha\)</span> will be and the more of the reflected light will be seen.</p>
<figure class="align-default" id="specular-figure">
<a class="reference internal image-reference" href="../_images/08_specular.svg"><img alt="../_images/08_specular.svg" src="../_images/08_specular.svg" width="350" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.11 </span><span class="caption-text">Specular reflection scatters light mainly towards the reflection vector.</span><a class="headerlink" href="#specular-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>We model the scattering of the reflected light rays using <span class="math notranslate nohighlight">\(\cos(\alpha)\)</span> raised to power</p>
<div class="math notranslate nohighlight">
\[ \texttt{specular} = k_s * \texttt{light colour} * \cos(\alpha)^{N_s},\]</div>
<p>where <span class="math notranslate nohighlight">\(k_s\)</span> is the <strong>specular reflection constant</strong> similar to its ambient and diffuse counterparts and <span class="math notranslate nohighlight">\(N_s\)</span> is the <strong>specular exponent</strong> that determines the size of the specular highlights (i.e., the shininess of the object). The angle <span class="math notranslate nohighlight">\(\alpha\)</span> is calculated using a dot product between the <span class="math notranslate nohighlight">\(\tt reflection\)</span> vector and the <span class="math notranslate nohighlight">\(\tt eye\)</span> vector.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> define a float for the specular constant and exponent with values <span class="math notranslate nohighlight">\(k_s = 1.0\)</span> and <span class="math notranslate nohighlight">\(N_s = 20.0\)</span></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span><span class="w">    </span><span class="c1">// specular constant</span>
<span class="kt">float</span><span class="w"> </span><span class="n">Ns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20.0f</span><span class="p">;</span><span class="w">   </span><span class="c1">// specular exponent</span>
</pre></div>
</div>
<p>and define the colour of the specular light where we defined the colours of the ambient and diffuse light.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">lightSpecular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">white</span><span class="p">;</span>
</pre></div>
</div>
<p>Send the specular colour to the shader where we did this for the ambient and diffuse colours.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lightSpecular&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lightSpecular</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Ns&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Ns</span><span class="p">);</span>
</pre></div>
</div>
<p>In the fragment shader add a vec3 uniform for <code class="docutils literal notranslate"><span class="pre">Ns</span></code> and <code class="docutils literal notranslate"><span class="pre">lightSpecular</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uniform</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">lightSpecular</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Ns</span><span class="p">;</span>
</pre></div>
</div>
<p>and in the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function add specular refection to our teapot.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Specular reflection</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">eye</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">reflection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">light</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">light</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">cosAlpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">eye</span><span class="p">,</span><span class="w"> </span><span class="n">reflection</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lightSpecular</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cosAlpha</span><span class="p">,</span><span class="w"> </span><span class="n">Ns</span><span class="p">);</span>
</pre></div>
</div>
<p>Don’t forget to add the specular reflection to the fragment colour.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Fragment colour</span>
<span class="n">fragmentColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span>
</pre></div>
</div>
<p>The result of applying ambient, diffuse and specular reflection is shown in <a class="reference internal" href="#teapot-specular-figure"><span class="std std-numref">Fig. 9.12</span></a>.</p>
<figure class="align-default" id="teapot-specular-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_specular.png"><img alt="../_images/08_teapot_specular.png" src="../_images/08_teapot_specular.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.12 </span><span class="caption-text">Ambient, diffuse and reflection: <span class="math notranslate nohighlight">\(k_a = 0.2\)</span>, <span class="math notranslate nohighlight">\(k_d = 0.7\)</span>, <span class="math notranslate nohighlight">\(k_s = 1.0\)</span>, <span class="math notranslate nohighlight">\(N_s = 20\)</span>.</span><a class="headerlink" href="#teapot-specular-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Move the camera around the teapot and watch what happens to the specular highlights.</p>
</section>
<section id="attenuation">
<h3><span class="section-number">9.2.4. </span>Attenuation<a class="headerlink" href="#attenuation" title="Permalink to this heading">#</a></h3>
<p><strong>Attenuation</strong> is the gradual decrease in light intensity as the distance between the light source and a surface increases. We can use attenuation to model light from low intensity light source, for example, a candle or torch which will only illuminate an area close to the source. Theoretically attenuation should follow the inverse square law where the light intensity is inversely proportional to the square of the distance between the light source and the surface. However, in practice this tends to result in a scene that is too dark so we calculate attenuation using the following</p>
<div class="math notranslate nohighlight">
\[ \textsf{attenuation} = \frac{1}{\textsf{constant} + \textsf{linear} * \textsf{distance} + \textsf{quadratic} * \textsf{distance}^2}, \]</div>
<p>where constant, linear and quadratic are values that determine who quickly the light intensity decreases, the values of which are set to model the type of light source, and distance is the distance of the fragment from the light source. The graph in <a class="reference internal" href="#attenuation-figure"><span class="std std-numref">Fig. 9.13</span></a> shows a typical attenuation profile where the light intensity rapidly decreases when the distance is small levelling off as the distance gets larger.</p>
<figure class="align-default" id="attenuation-figure">
<a class="reference internal image-reference" href="../_images/08_attenuation.svg"><img alt="../_images/08_attenuation.svg" src="../_images/08_attenuation.svg" width="500" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.13 </span><span class="caption-text">Attenuation can be modelled by an inverse quadratic function.</span><a class="headerlink" href="#attenuation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To model attenuation edit the fragment shader so that constant values are defined before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">quadratic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.02</span><span class="p">;</span>
</pre></div>
</div>
<p>The values of these will depend on the type of light source being modelled. We want a weak light source to demonstrate the attenuation but for stronger light sources you may wish to experiment with these values. In the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function and the following to apply attenuation.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Attenuation</span>
<span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">lightPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">attenuation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">constant</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">quadratic</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="p">);</span>

<span class="c1">// Fragment colour</span>
<span class="n">fragmentColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">specular</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">attenuation</span><span class="p">;</span>
</pre></div>
</div>
<p>To demonstrate the affects of applying attenuation we are going to need some more objects that are further away from the light source. In your <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file before the render loop define an array of position vectors</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Specify world space object positions</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">positions</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">5.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-10.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">-3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-4.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">-4.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-8.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-4.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">-4.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-10.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-8.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-6.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">-1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>
</div>
<p>and then replace the <code class="docutils literal notranslate"><span class="pre">model</span></code> matrix and drawing commands with the following (it should be fairly obvious what we are doing here).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Loop through objects</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Calculate model matrix</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">));</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="mf">30.0f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">));</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Send the model matrix to the shader</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;model&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Draw the model</span>
<span class="w">    </span><span class="n">teapot</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">shaderID</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It would also be useful to render the light source. After you’ve drawn the teapots add the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Draw light sources</span>
<span class="c1">// Activate light source shader</span>
<span class="n">glUseProgram</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">);</span>

<span class="c1">// Calculate model matrix</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">lightPosition</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.1f</span><span class="p">));</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>

<span class="c1">// Send model, view, projection matrices and light colour to light shader</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;model&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;view&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">view</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;projection&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">projection</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lightColour&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lightSpecular</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="c1">// Draw light source</span>
<span class="n">sphere</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">);</span>
</pre></div>
</div>
<p>Moving the camera to a different position allows us to see the affects of attenuation (<a class="reference internal" href="#teapot-attenuation-figure"><span class="std std-numref">Fig. 9.14</span></a>). Note how the teapots further away from the light source are darker as the light intensity has been reduced.</p>
<figure class="align-default" id="teapot-attenuation-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_attenuation.png"><img alt="../_images/08_teapot_attenuation.png" src="../_images/08_teapot_attenuation.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.14 </span><span class="caption-text">The affects of applying attenuation.</span><a class="headerlink" href="#teapot-attenuation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>If you are having difficulty with this check out the source code <a class="reference download internal" download="" href="../_downloads/cf5e33e68955ebc48bc71ff6afba1cda/Lab10_single_light.cpp"><span class="xref download myst">Lab10_single_light.cpp</span></a> and the shaders <a class="reference download internal" download="" href="../_downloads/717d558f4333dffa0e43ca4b09299ec0/vertexShader.vert"><span class="xref download myst">vertexShader.vert</span></a> and <a class="reference download internal" download="" href="../_downloads/e627a4b5143e33f8cce51a424c1d6589/fragmentShader.frag"><span class="xref download myst">fragmentShader.frag</span></a>.</p>
</section>
</section>
<section id="multiple-light-sources">
<h2><span class="section-number">9.3. </span>Multiple light sources<a class="headerlink" href="#multiple-light-sources" title="Permalink to this heading">#</a></h2>
<p>In theory to add another light sources to a scene is simply a matter of calculating the ambient, diffuse and specular reflection for the additional light source and then adding them to the fragment colour. We have seen for a single light source we have to define the three light source colours, the position of the light source in the world space and the three attenuation constants. Given that we would like to do this for multiple light sources we need data structure for each light source.</p>
<p>A data structure in C++ and GLSL is defined in a similar way using the <a href="https://cplusplus.com/doc/tutorial/structures/" target="_blank">struct</a> declaration.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Structs</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Light</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="p">,</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="n">quadratic</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This defines a data structure called <code class="docutils literal notranslate"><span class="pre">Light</span></code> that contains the information required to calculate the lighting model for a single light source. In the fragment shader we can create a uniform for an array of <code class="docutils literal notranslate"><span class="pre">Light</span></code> data structures.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define maxLights 10;</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">Light</span><span class="w"> </span><span class="n">lights</span><span class="p">[</span><span class="n">maxLights</span><span class="p">];</span>
<span class="n">uniform</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numLights</span><span class="p">;</span>
</pre></div>
</div>
<p>This defines a 10 element array of <code class="docutils literal notranslate"><span class="pre">Light</span></code> data structures (hopefully we will not need more than 10 light sources but if you then simply increase the number of <code class="docutils literal notranslate"><span class="pre">maxLights</span></code>) and the actual number of lights we have is passed in using the <code class="docutils literal notranslate"><span class="pre">numLights</span></code> uniform. Then all we need to do is loop through each of the light sources, calculate the fragment colour for the current source and add it to the total fragment colour. The fragment shader for multiple light sources is given below. Create a new file called <code class="docutils literal notranslate"><span class="pre">multipleLightsFragmentShader.frag</span></code> in the <code class="docutils literal notranslate"><span class="pre">source/</span></code> directory and paste this code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="c1">// Interpolated values from the vertex shaders</span>
<span class="n">in</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">UV</span><span class="p">;</span>
<span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">;</span>
<span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">Normal</span><span class="p">;</span>

<span class="c1">// Output data</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">fragmentColour</span><span class="p">;</span>

<span class="c1">// Structs</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Light</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="p">,</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="n">quadratic</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Uniforms</span>
<span class="cp">#define maxLights 10</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">sampler2D</span><span class="w"> </span><span class="n">diffuse1</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">Light</span><span class="w"> </span><span class="n">lights</span><span class="p">[</span><span class="n">maxLights</span><span class="p">];</span>
<span class="n">uniform</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numLights</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Ns</span><span class="p">;</span>

<span class="c1">// Function prototypes</span>
<span class="n">vec3</span><span class="w"> </span><span class="nf">calculatePointLight</span><span class="p">(</span><span class="n">Light</span><span class="w"> </span><span class="n">ptLight</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">eye</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>

<span class="w">    </span><span class="c1">// Calculate normal and eye vectors (these are the same for all light sources)</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">eye</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">fragmentPosition</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Loop through the point light sources</span>
<span class="w">    </span><span class="n">fragmentColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numLights</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fragmentColour</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">calculatePointLight</span><span class="p">(</span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">eye</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Calculate point light</span>
<span class="n">vec3</span><span class="w"> </span><span class="nf">calculatePointLight</span><span class="p">(</span><span class="n">Light</span><span class="w"> </span><span class="n">ptLight</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">eye</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Object colour</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">diffuse1</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">));</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Ambient reflection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptLight</span><span class="p">.</span><span class="n">ambient</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Diffuse reflection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">light</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">ptLight</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosTheta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">light</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptLight</span><span class="p">.</span><span class="n">diffuse</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cosTheta</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Specular reflection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">reflection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">light</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">light</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosAlpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">eye</span><span class="p">,</span><span class="w"> </span><span class="n">reflection</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptLight</span><span class="p">.</span><span class="n">specular</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cosAlpha</span><span class="p">,</span><span class="w"> </span><span class="n">Ns</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Attenuation</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">ptLight</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">attenuation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">ptLight</span><span class="p">.</span><span class="n">constant</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ptLight</span><span class="p">.</span><span class="n">linear</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ptLight</span><span class="p">.</span><span class="n">quadratic</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Return fragment colour</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">specular</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we have defined a function called <code class="docutils literal notranslate"><span class="pre">calculatePointLight()</span></code> that contains the commands used to calculate the fragment colour for a single light source. In the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function we have a for loop to loop through each light source, perform the light calculations for the current light source and add it to the fragment colour. Note the the <span class="math notranslate nohighlight">\(\texttt{normal}\)</span> and <span class="math notranslate nohighlight">\(\texttt{eye}\)</span> vectors are the same for all light sources so these are calculated outside of the for loop.</p>
<p>We also need to make changes to the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file. Add the <code class="docutils literal notranslate"><span class="pre">Light</span></code> data structure before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function declaration</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Light structs</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Light</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="n">linear</span><span class="p">,</span><span class="w"> </span><span class="n">quadratic</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Since we are using a different file for the fragment shader we need to tell OpenGL to use our new fragment shader which it compiles the shader program.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Compile shader programs</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">shaderID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoadShaders</span><span class="p">(</span><span class="s">&quot;vertexShader.vert&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;multipleLightsFragmentShader.frag&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>We want to define the lighting properties for multiple lights sources so we are going to store our <code class="docutils literal notranslate"><span class="pre">Light</span></code> structures in a <a href="https://en.cppreference.com/w/cpp/container/vector" target="_blank">vector</a>. Where we defined the colour and position of the single light source, replace the code with the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define light colours</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">white</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>

<span class="c1">// Create vector of Light structs</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Light</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lights</span><span class="p">;</span>

<span class="c1">// Add first light source</span>
<span class="n">Light</span><span class="w"> </span><span class="n">light</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">);</span>
<span class="n">light</span><span class="p">.</span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ka</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">white</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">diffuse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">white</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">specular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">white</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">constant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">linear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">quadratic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.02f</span><span class="p">;</span>
<span class="n">lights</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">light</span><span class="p">);</span>

<span class="c1">// Add second light source</span>
<span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-8.0f</span><span class="p">);</span>
<span class="n">light</span><span class="p">.</span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ka</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">white</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">diffuse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">white</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">specular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">white</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">constant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">linear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1f</span><span class="p">;</span>
<span class="n">light</span><span class="p">.</span><span class="n">quadratic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.02f</span><span class="p">;</span>
<span class="n">lights</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">light</span><span class="p">);</span>
</pre></div>
</div>
<p>This code creates two light sources, defines the values of the data structures and stores then in the vector <code class="docutils literal notranslate"><span class="pre">lights</span></code>. The <code class="docutils literal notranslate"><span class="pre">lights.push_back(light)</span></code> adds the current <code class="docutils literal notranslate"><span class="pre">light</span></code> to the end of the <code class="docutils literal notranslate"><span class="pre">lights</span></code> vector. Now we need to send the light and material values to the shader using uniforms, replace the existing code with the code below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send light source properties to the shader</span>
<span class="n">glUniform1i</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;numLights&quot;</span><span class="p">),</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lights</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">lights</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">viewSpaceLightPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].ambient&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ambient</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].diffuse&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">diffuse</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].specular&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">specular</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].position&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewSpaceLightPosition</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].constant&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">constant</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].linear&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">linear</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;lights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].quadratic&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">quadratic</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Send material (object) properties to the shader</span>
<span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Ns&quot;</span><span class="p">),</span><span class="w"> </span><span class="mf">20.0f</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we simply loop through the <code class="docutils literal notranslate"><span class="pre">lights</span></code> vector and send the values for each individual light to the shader (unfortunately we can’t send a vector of structs using a uniform, we could use <a href="https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)" target="_blank">GLSL interface blocks</a> but I wanted to keep things simple here).</p>
<p>Finally to draw each light source replace the code to draw the single one with the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Draw light sources</span>
<span class="n">glUseProgram</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">lights</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Calculate model matrix</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">));</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Send model, view, projection matrices and light colour to light shader</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;model&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;view&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">view</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;projection&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">projection</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lightColour&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">specular</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Draw light source</span>
<span class="w">    </span><span class="n">sphere</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">);</span>
<span class="p">}</span><span class="w">    </span>
</pre></div>
</div>
<p>Hopefully once you’ve made all of the changes it compiles and runs to show the following</p>
<figure class="align-default" id="multiple-lights-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_multiple_lights.png"><img alt="../_images/08_teapot_multiple_lights.png" src="../_images/08_teapot_multiple_lights.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.15 </span><span class="caption-text">Teapots lit using 2 light sources.</span><a class="headerlink" href="#multiple-lights-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Use the keyboard and mouse to move the camera around the teapots to see the affects of the light sources.</p>
</section>
<section id="spotlights">
<h2><span class="section-number">9.4. </span>Spotlights<a class="headerlink" href="#spotlights" title="Permalink to this heading">#</a></h2>
<p>A spotlight is a light source that emits light along a specific direction vector so that only those objects that are within some distance of this vector are illuminated. These are useful for modelling light sources such as flashlights, street lights, car headlights etc.</p>
<figure class="align-default" id="spot-light-figure">
<a class="reference internal image-reference" href="../_images/08_spot_light.svg"><img alt="../_images/08_spot_light.svg" src="../_images/08_spot_light.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.16 </span><span class="caption-text">A spotlight only illuminates fragments close to the light <span class="math notranslate nohighlight">\(\tt direction\)</span> vector.</span><a class="headerlink" href="#spot-light-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Consider <a class="reference internal" href="#spot-light-figure"><span class="std std-numref">Fig. 9.16</span></a> that shows a spotlight located at <span class="math notranslate nohighlight">\(\tt position\)</span> emitting light in the direction given by the <span class="math notranslate nohighlight">\(\tt direction\)</span> vector. The <span class="math notranslate nohighlight">\(\tt light\)</span> vector points from the light source position to the position of the fragment and the angle <span class="math notranslate nohighlight">\(\phi\)</span> determines the spread of the light. If the angle <span class="math notranslate nohighlight">\(\theta\)</span> between the <span class="math notranslate nohighlight">\(\tt light\)</span> vector and the <span class="math notranslate nohighlight">\(\tt direction\)</span> vector is less than <span class="math notranslate nohighlight">\(\phi\)</span> then the fragment is illuminated by the spotlight.</p>
<p>To add spotlights to our scene we declare a data structure for a spotlight in the fragment shader and the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file. Add the following to the top of the <code class="docutils literal notranslate"><span class="pre">multipleLightsFragmentShader.frag</span></code> file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">SpotLight</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosPhi</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="p">,</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="n">quadratic</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We will be using uniforms very similar to that for our point light sources so add the following to the fragment shader.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uniform</span><span class="w"> </span><span class="n">SpotLight</span><span class="w"> </span><span class="n">spotLights</span><span class="p">[</span><span class="n">maxLights</span><span class="p">];</span>
<span class="n">uniform</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numSpotLights</span><span class="p">;</span>
</pre></div>
</div>
<p>We will be defining a function called <code class="docutils literal notranslate"><span class="pre">calculateSpotLight()</span></code> to calculate our spotlight but first we need to declare the function prototype before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="nf">calculateSpotLight</span><span class="p">(</span><span class="n">SpotLight</span><span class="w"> </span><span class="n">spotLight</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">eye</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">calculateSpotLight()</span></code> function is below, copy and paste this after the <code class="docutils literal notranslate"><span class="pre">calculatePointLight()</span></code> function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate spotlight</span>
<span class="n">vec3</span><span class="w"> </span><span class="nf">calculateSpotLight</span><span class="p">(</span><span class="n">SpotLight</span><span class="w"> </span><span class="n">spotLight</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">eye</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Object colour</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">diffuse1</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">));</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Ambient reflection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spotLight</span><span class="p">.</span><span class="n">ambient</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Diffuse reflection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">light</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">spotLight</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosTheta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">light</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spotLight</span><span class="p">.</span><span class="n">diffuse</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cosTheta</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Specular reflection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">reflection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">light</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">light</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosAlpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">eye</span><span class="p">,</span><span class="w"> </span><span class="n">reflection</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spotLight</span><span class="p">.</span><span class="n">specular</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cosAlpha</span><span class="p">,</span><span class="w"> </span><span class="n">Ns</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Attenuation</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">spotLight</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">attenuation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">spotLight</span><span class="p">.</span><span class="n">constant</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">spotLight</span><span class="p">.</span><span class="n">linear</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">spotLight</span><span class="p">.</span><span class="n">quadratic</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Spotlight intensity</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">spotLight</span><span class="p">.</span><span class="n">direction</span><span class="p">);</span>
<span class="w">    </span><span class="n">cosTheta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">light</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">direction</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cosTheta</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">spotLight</span><span class="p">.</span><span class="n">cosPhi</span><span class="p">)</span>
<span class="w">        </span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Return fragment colour</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">attenuation</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">diffuse</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">specular</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">attenuation</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">intensity</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After calculating the ambient, diffuse and specular reflection and the attenuation in the same way as for the point light sources we have additional code to calculate <span class="math notranslate nohighlight">\(\cos(\theta)\)</span> between the <span class="math notranslate nohighlight">\(\texttt{light}\)</span> and <span class="math notranslate nohighlight">\(\texttt{direction}\)</span> vectors. A float <span class="math notranslate nohighlight">\(\tt intensity\)</span> is calculated so that its value is 1 if the fragment is within the boundary of the spotlight and 0 otherwise. The diffuse and specular components are then multiplied by <span class="math notranslate nohighlight">\(\tt intensity\)</span> so they are turned on or off depending on the position of the fragment. The ambient component isn’t multiplied by <span class="math notranslate nohighlight">\(\tt intensity\)</span> so that we can still see the objects not illuminated by the spotlight.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function of the fragment shader add the following code to apply the spotlights as well as the point lights.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Loop through the spotlight sources</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numSpotLights</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">fragmentColour</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">calculateSpotLight</span><span class="p">(</span><span class="n">spotLights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">fragmentPosition</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">eye</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we need to define our spotlight source values in the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file which is done in a similar way to the point light sources. Declare a data structure called <code class="docutils literal notranslate"><span class="pre">SpotLight</span></code> by adding the following before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">SpotLight</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosPhi</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">linear</span><span class="p">,</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="n">quadratic</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>and after we defined our point light sources add the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create vector of SpotLight structs</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpotLight</span><span class="o">&gt;</span><span class="w"> </span><span class="n">spotLights</span><span class="p">;</span>

<span class="c1">// Add spotlight</span>
<span class="n">SpotLight</span><span class="w"> </span><span class="n">spotLight</span><span class="p">;</span>
<span class="n">spotLight</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">spotLight</span><span class="p">.</span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">spotLight</span><span class="p">.</span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ka</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">white</span><span class="p">;</span>
<span class="n">spotLight</span><span class="p">.</span><span class="n">diffuse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">white</span><span class="p">;</span>
<span class="n">spotLight</span><span class="p">.</span><span class="n">specular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">white</span><span class="p">;</span>
<span class="n">spotLight</span><span class="p">.</span><span class="n">cosPhi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">45.0f</span><span class="p">));</span>
<span class="n">spotLight</span><span class="p">.</span><span class="n">constant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="n">spotLight</span><span class="p">.</span><span class="n">linear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1f</span><span class="p">;</span>
<span class="n">spotLight</span><span class="p">.</span><span class="n">quadratic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.02f</span><span class="p">;</span>
<span class="n">spotLights</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">spotLight</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we have defined a single spotlight with the same properties as our point lights the light spread angle of 45<span class="math notranslate nohighlight">\(^\circ\)</span>. Note that we are only going to use one spotlight for now but have the ability to add more if we want. The spotlights are sent to the shader in the same was as per the point lights.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send spotlights to the shader</span>
<span class="n">glUniform1i</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;numSpotLights&quot;</span><span class="p">),</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">spotLights</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">spotLights</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">viewSpaceSpotLightPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="n">spotLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">viewSpaceSpotLightDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat3</span><span class="p">(</span><span class="n">view</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">spotLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">direction</span><span class="p">;</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;spotLights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].position&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewSpaceSpotLightPosition</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;spotLights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].direction&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewSpaceSpotLightDirection</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;spotLights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].ambient&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">spotLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ambient</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;spotLights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].diffuse&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">spotLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">diffuse</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;spotLights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].specular&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">spotLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">specular</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;spotLights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].cosPhi&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="n">spotLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cosPhi</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;spotLights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].constant&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="n">spotLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">constant</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;spotLights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].linear&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="n">spotLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">linear</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;spotLights[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;].quadratic&quot;</span><span class="p">).</span><span class="n">c_str</span><span class="p">()),</span><span class="w"> </span><span class="n">spotLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">quadratic</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If we want to render the spotlight sources we replicate the code for the point lights.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">spotLights</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Calculate model matrix</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">spotLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">));</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Send model, view, projection matrices and light colour to light shader</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;model&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;view&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">view</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;projection&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">projection</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;lightColour&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">spotLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">specular</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Draw light source</span>
<span class="w">    </span><span class="n">sphere</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">lightShaderID</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Comment out the code where we add the two point light sources so that they are not used. Fingers crossed everything compiles and runs ok and you are presented with the following.</p>
<figure class="align-default" id="spot-light-harsh-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_spotlight_harsh.png"><img alt="../_images/08_teapot_spotlight_harsh.png" src="../_images/08_teapot_spotlight_harsh.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.17 </span><span class="caption-text">Teapots lit using a spotlight.</span><a class="headerlink" href="#spot-light-harsh-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Use the keyboard and mouse to move the camera around the teapots. You may notice that there is an abrupt cutoff between the region illuminated by the spotlight and the region in darkness. In the real world this doesn’t usually happen as light on this edge gets softened by various effects. We can model this softening by dividing the difference between <span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span> by some small angle <span class="math notranslate nohighlight">\(\delta\)</span> and limiting the values to between 0 and 1. The effect of this can be seen in <a class="reference internal" href="#soft-edge-figure"><span class="std std-numref">Fig. 9.18</span></a> where the intensity is 1 until <span class="math notranslate nohighlight">\(\phi - \delta\)</span> where it reduces to 0 at <span class="math notranslate nohighlight">\(\phi\)</span>. So using this will gradually reduce the intensity are the edge of the illuminated region.</p>
<figure class="align-default" id="soft-edge-figure">
<a class="reference internal image-reference" href="../_images/08_soft_edge.svg"><img alt="../_images/08_soft_edge.svg" src="../_images/08_soft_edge.svg" width="500" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.18 </span><span class="caption-text">Intensity value over a range of <span class="math notranslate nohighlight">\(\theta\)</span>.</span><a class="headerlink" href="#soft-edge-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Replace the <code class="docutils literal notranslate"><span class="pre">intensity</span></code> calculation with the following to soften the edge of the spotlight.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">radians</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clamp</span><span class="p">((</span><span class="n">cosTheta</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">spotLight</span><span class="p">.</span><span class="n">cosPhi</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
</pre></div>
</div>
<figure class="align-default" id="spot-light-soft-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_spotlight_soft.png"><img alt="../_images/08_teapot_spotlight_soft.png" src="../_images/08_teapot_spotlight_soft.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.19 </span><span class="caption-text">Teapots lit using a spotlight with softened edges.</span><a class="headerlink" href="#spot-light-soft-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="directional-light">
<h2><span class="section-number">9.5. </span>Directional light<a class="headerlink" href="#directional-light" title="Permalink to this heading">#</a></h2>
<p>The final light source type we will look at is <strong>directional light</strong>. When modelling a light source that is far away, for example the sun, the light rays are very close to being parallel. It does not matter where the object is in the view space as all objects are lit from the same direction.</p>
<figure class="align-default" id="directional-light-figure">
<a class="reference internal image-reference" href="../_images/08_directional_light.svg"><img alt="../_images/08_directional_light.svg" src="../_images/08_directional_light.svg" width="400" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.20 </span><span class="caption-text">Directional lighting</span><a class="headerlink" href="#directional-light-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The lighting calculations are the same as for the other light sources seen above with the exception that we do not need the light source position and we do not apply the attenuation. We will use another struct for the directional light source, add the following to the <code class="docutils literal notranslate"><span class="pre">multipleFragmentShader.frag</span></code> file</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">DirLight</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>and import the corresponding uniform.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uniform</span><span class="w"> </span><span class="n">DirLight</span><span class="w"> </span><span class="n">dirLight</span><span class="p">;</span>
</pre></div>
</div>
<p>We are going to use a function to calculate the directional lighting first add the function prototype before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="nf">calculateDirectionalLight</span><span class="p">(</span><span class="n">DirLight</span><span class="w"> </span><span class="n">dirLight</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">eye</span><span class="p">);</span>
</pre></div>
</div>
<p>and then copy and paste the following code after the <code class="docutils literal notranslate"><span class="pre">calculateSpotLight()</span></code> function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate directional light</span>
<span class="n">vec3</span><span class="w"> </span><span class="nf">calculateDirectionalLight</span><span class="p">(</span><span class="n">DirLight</span><span class="w"> </span><span class="n">dirLight</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">eye</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Object colour</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">diffuse1</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">));</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Ambient reflection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dirLight</span><span class="p">.</span><span class="n">ambient</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Diffuse refection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">light</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">dirLight</span><span class="p">.</span><span class="n">direction</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosTheta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">light</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dirLight</span><span class="p">.</span><span class="n">diffuse</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectColour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cosTheta</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Specular reflection</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">reflection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">light</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">light</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosAlpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">eye</span><span class="p">,</span><span class="w"> </span><span class="n">reflection</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dirLight</span><span class="p">.</span><span class="n">specular</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cosAlpha</span><span class="p">,</span><span class="w"> </span><span class="n">Ns</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Return fragment colour</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once we’ve defined the function to calculate the directional light we need to tell our <code class="docutils literal notranslate"><span class="pre">main()</span></code> function to use it and add the directional light colour to the fragment colour. Add the following code to after where we calculated the spotlight.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate the directional light</span>
<span class="n">fragmentColour</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">calculateDirectionalLight</span><span class="p">(</span><span class="n">dirLight</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">eye</span><span class="p">);</span>
</pre></div>
</div>
<p>Now we need to define a directional light source in the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file and send to to the shader, define a data structure before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">DirLight</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>and after we have defined the point light sources add the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define directional light</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">yellow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">DirLight</span><span class="w"> </span><span class="n">dirLight</span><span class="p">;</span>
<span class="n">dirLight</span><span class="p">.</span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">dirLight</span><span class="p">.</span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ka</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">yellow</span><span class="p">;</span>
<span class="n">dirLight</span><span class="p">.</span><span class="n">diffuse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">yellow</span><span class="p">;</span>
<span class="n">dirLight</span><span class="p">.</span><span class="n">specular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">yellow</span><span class="p">;</span>
</pre></div>
</div>
<p>Here we define a directional light source with rays coming down from the top left as we look down the <span class="math notranslate nohighlight">\(z\)</span>-axis. Colour of the light source is yellow (i.e., equal red and green mixed with zero blue) and the ambient, diffuse and specular colours have been scaled similarly to the point light sources above. The directional light values are sent to the shader in the same was as per the point light sources (although we only have one of these). Note that the <code class="docutils literal notranslate"><span class="pre">direction</span></code> vector is defined in the world space so we need to multiply it by the <code class="docutils literal notranslate"><span class="pre">view</span></code> matrix before sending it to the shader.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send directional light to the shader</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">viewSpaceLightDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat3</span><span class="p">(</span><span class="n">view</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dirLight</span><span class="p">.</span><span class="n">direction</span><span class="p">;</span>
<span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dirLight.direction&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewSpaceLightDirection</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dirLight.ambient&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dirLight</span><span class="p">.</span><span class="n">ambient</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dirLight.diffuse&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dirLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">glUniform3fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dirLight.specular&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dirLight</span><span class="p">.</span><span class="n">specular</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
<p>Make these changes and run the code and you should see something similar to this.</p>
<figure class="align-default" id="teapot-directional-light-figure">
<a class="reference internal image-reference" href="../_images/08_teapot_directional_light.png"><img alt="../_images/08_teapot_directional_light.png" src="../_images/08_teapot_directional_light.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.21 </span><span class="caption-text">Directional and point light sources.</span><a class="headerlink" href="#teapot-directional-light-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Note that we can see that the teapots have been illuminated from a directional light source from the left hand side in addition to the two point light sources and the spotlight (you may need to uncomment code for the point light sources). Since the directional light source colour was yellow our blue teapots take on a slightly green appearance.</p>
</section>
<hr class="docutils" />
<section id="exercises">
<h2><span class="section-number">9.6. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Experiment with the positions, colours and material properties of the various light sources to see what effects they have.</p></li>
<li><p>Use a spotlight to model a flashlight controlled by the user such that the light is positioned at <code class="docutils literal notranslate"><span class="pre">camera.position</span></code>, is pointing in the same direction as <code class="docutils literal notranslate"><span class="pre">camera.direction</span></code> and has a spread of <span class="math notranslate nohighlight">\(\phi = 20^\circ\)</span>. Turn off all other light sources (either by commenting out code or setting the colours to zero) for extra spookiness.</p></li>
</ol>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/10_exercise_2.mp4" type="video/mp4">
</video>
</center>
<ol class="arabic simple" start="3">
<li><p>Change the colour of the second point light source to magenta and rotate its position in a circle centred at (0,0,-5) with radius 5. Turn off any spotlights and directional lighting. Hint: the co-ordinates of points on a circle can be calculated using <span class="math notranslate nohighlight">\((x, y, z) = (0,0,-5) + 5 * (\cos({\tt time}), 0, \sin(\tt time))\)</span>.</p></li>
</ol>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/10_exercise_3.mp4" type="video/mp4">
</video>
</center>
<ol class="arabic simple" start="4">
<li><p>The planet Narkov has a red sun and a single day lasts for just 5 of our seconds. Use directional lighting to model the illumination of the sun as it passes through the sky and also beneath the horizon (fortunately Narkovians like tea so using our teapots would not seem unusual). The background colour can also be changed to match the colour of the light source.</p></li>
</ol>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/10_exercise_4.mp4" type="video/mp4">
</video>
</center>
</section>
<hr class="docutils" />
<section id="source-code">
<h2><span class="section-number">9.7. </span>Source code<a class="headerlink" href="#source-code" title="Permalink to this heading">#</a></h2>
<p>The source code for this lab, including the exercise solutions, can be downloaded using the links below.</p>
<ul class="simple">
<li><p><a class="reference download internal" download="" href="../_downloads/cf5e33e68955ebc48bc71ff6afba1cda/Lab10_single_light.cpp"><span class="xref download myst">Lab10_single_light.cpp</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/717d558f4333dffa0e43ca4b09299ec0/vertexShader.vert"><span class="xref download myst">vertexShader.vert</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/e627a4b5143e33f8cce51a424c1d6589/fragmentShader.frag"><span class="xref download myst">fragmentShader.frag</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/2093fd6dc2fb56a8a70d06b2c1506f1b/main.cpp"><span class="xref download myst">main.cpp</span></a> - multiple point light sources and directional light</p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/83d86af8b98e6f3d0ebaf656a853ebff/multipleLightsFragmentShader.frag"><span class="xref download myst">multipleLightsFragmentShader.frag</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/43d8f12deafa87d7342a4641d4633e77/Lab10_Exercises.cpp"><span class="xref download myst">Lab10_Exercises.cpp</span></a> - solutions to the exercises</p></li>
</ul>
<hr class="docutils" />
</section>
<section id="creating-an-obj-file-in-blender">
<span id="blender-section"></span><h2><span class="section-number">9.8. </span>Creating an .obj file in Blender<a class="headerlink" href="#creating-an-obj-file-in-blender" title="Permalink to this heading">#</a></h2>
<p>To create an .obj file we can use the popular open source application <a href="https://www.blender.org" target="_blank">Blender</a> (this is installed on the machines in the Dalton building).</p>
<ol class="arabic simple">
<li><p>Create your object in blender and sort out the material textures, UV co-ordinates etc. (lots of tutorials on youtube to help you with this). Or you can import a model produced by someone else (be sure to give credit if doing this).</p></li>
<li><p>Click on <strong>File &gt; Export &gt; Wavefront (.obj)</strong></p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/08_blender_export_obj_1.png"><img alt="../_images/08_blender_export_obj_1.png" src="../_images/08_blender_export_obj_1.png" style="width: 600px;" /></a>
</figure>
<ol class="arabic simple" start="3">
<li><p>Make sure <strong>Include Normals</strong>, <strong>Include UVs</strong> and <strong>Triangular Faces</strong> are selected.</p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/08_blender_export_obj_2.png"><img alt="../_images/08_blender_export_obj_2.png" src="../_images/08_blender_export_obj_2.png" style="width: 600px;" /></a>
</figure>
<ol class="arabic simple" start="4">
<li><p>Navigate to your chosen folder e.g., <code class="docutils literal notranslate"><span class="pre">Lab10_Lighting/objects/</span></code>, and give it an appropriate name.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Model class that we are using here is very simple and will only work with simple models.</p>
</div>
</section>
<hr class="docutils" />
<section id="video-walkthrough">
<h2><span class="section-number">9.9. </span>Video walkthrough<a class="headerlink" href="#video-walkthrough" title="Permalink to this heading">#</a></h2>
<p>The video below walks you through these lab materials.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/v9e_557Wl_U?si=6fLfaMWJL5s3P5Qs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="10_Quaternions.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">8. </span>Quaternions</p>
      </div>
    </a>
    <a class="right-next"
       href="09_Normal_mapping.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">10. </span>Normal Mapping</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-model-class">9.1. The Model class</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wavefront-obj-files">9.1.1. Wavefront (.obj) files</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#phong-s-lighting-model">9.2. Phong’s lighting model</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ambient-reflection">9.2.1. Ambient reflection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#diffuse-reflection">9.2.2. Diffuse reflection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#specular-reflection">9.2.3. Specular reflection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#attenuation">9.2.4. Attenuation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multiple-light-sources">9.3. Multiple light sources</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spotlights">9.4. Spotlights</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#directional-light">9.5. Directional light</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">9.6. Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">9.7. Source code</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-an-obj-file-in-blender">9.8. Creating an .obj file in Blender</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#video-walkthrough">9.9. Video walkthrough</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dr Jon Shiach
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>