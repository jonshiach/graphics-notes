

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>10. Normal Mapping &#8212; Computer Graphics</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"vec": ["\\mathbf{#1}", 1], "model": ["M\\!odel"], "view": ["V\\!iew"], "mvp": ["MV\\!P"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/09_Normal_mapping';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="A. Complex Numbers and Quaternions" href="A_Complex_numbers_and_quaternions.html" />
    <link rel="prev" title="9. Lighting" href="08_Lighting.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Computer Graphics
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_intro_to_cpp.html">1. Introduction to C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_basic_shapes_in_OpenGL.html">2. Basic Shapes in OpenGL</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_textures.html">3. Textures</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_vectors_and_matrices.html">4. Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_transformations.html">5. Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_3D_worlds.html">6. 3D Worlds</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_Moving_the_camera.html">7. Moving the camera</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_Quaternions.html">8. Quaternions</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_Lighting.html">9. Lighting</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">10. Normal Mapping</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="A_Complex_numbers_and_quaternions.html">A. Complex Numbers and Quaternions</a></li>
<li class="toctree-l1"><a class="reference internal" href="B_Code.html">B. Code and Assets</a></li>
<li class="toctree-l1"><a class="reference internal" href="C_Glossary.html">C Glossary</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs/issues/new?title=Issue%20on%20page%20%2F_pages/09_Normal_mapping.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/_pages/09_Normal_mapping.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Normal Mapping</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tangent-space">10.1. Tangent space</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#calculating-the-tangent-and-bitangent-vectors">10.1.1. Calculating the tangent and bitangent vectors</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#shaders">10.2. Shaders</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vertex-shader">10.2.1. Vertex shader</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fragment-shader">10.2.2. Fragment shader</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#re-orthogonalising-the-tangent-space-vectors">10.3. Re-orthogonalising the tangent space vectors</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#specular-maps">10.4. Specular maps</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#neutral-maps">10.4.1. Neutral maps</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">10.5. Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">10.6. Source code</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#video-walkthrough">10.7. Video walkthrough</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="normal-mapping">
<span id="normal-mapping-section"></span><h1><span class="section-number">10. </span>Normal Mapping<a class="headerlink" href="#normal-mapping" title="Permalink to this heading">#</a></h1>
<p>In <a class="reference internal" href="08_Lighting.html#lighting-section"><span class="std std-ref">Lab 8 on lighting</span></a> we saw that the diffuse and specular reflection models used the normal vector to determine the fragment colour. The vertex shader was used to interpolate the normal vectors for each fragment based on the normal vectors at the vertices of a triangle. This works well for smooth objects, but for objects with a rough or patterned surface we don’t get the benefits of highlights and shadow. <strong>Normal mapping</strong> is technique that uses a <a class="reference internal" href="03_textures.html#textures-section"><span class="std std-ref">texture map</span></a> to define the normal vectors for each fragment so that when a lighting model is applied it gives the appearance of a non-flat surface.</p>
<figure class="align-default" id="id2">
<a class="reference internal image-reference" href="../_images/09_normal_mapping.svg"><img alt="../_images/09_normal_mapping.svg" src="../_images/09_normal_mapping.svg" width="600" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.1 </span><span class="caption-text">Normal mapping applies a texture of normals for each fragment giving the appearance of a non-flat surface.</span><a class="headerlink" href="#id2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>A <strong>normal map</strong> is a texture where the RGB colour values of each textel is used for the x, y and z values of a normal vector (<a class="reference internal" href="#normal-map-figure"><span class="std std-numref">Fig. 10.2</span></a>). Since the OpenGL co-ordinate system has the z axis pointing out from the screen the colour of a normal map is mainly blue.</p>
<figure class="align-default" id="normal-map-figure">
<a class="reference internal image-reference" href="../_images/09_normal_map.svg"><img alt="../_images/09_normal_map.svg" src="../_images/09_normal_map.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.2 </span><span class="caption-text">The RBG values of a normal map give the values of the normal vectors.</span><a class="headerlink" href="#normal-map-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Download and build the project files for this lab.</p>
<p>Compile and run the project and you will see that we have the scene used at the end of <a class="reference internal" href="08_Lighting.html#lighting-section"><span class="std std-ref">Lab 9 Lighting</span></a> with the teapots lit using a point light, a spotlight and a directional light.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/09_teapots.png"><img alt="../_images/09_teapots.png" src="../_images/09_teapots.png" style="width: 500px;" /></a>
</figure>
<p>A Light class has been created to handle the light sources. Take a look at the <code class="docutils literal notranslate"><span class="pre">light.hpp</span></code> and <code class="docutils literal notranslate"><span class="pre">light.cpp</span></code> files and you will see the following Light class methods</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">addPointLight()</span></code>, <code class="docutils literal notranslate"><span class="pre">addSpotLight()</span></code>, <code class="docutils literal notranslate"><span class="pre">addDirLight()</span></code> - these are used to add another light source to the scene</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">toShader()</span></code> - sends all of the lighting uniforms to the shader</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">draw()</span></code> - draws the light source</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reorder()</span></code> - a private member function that reorders the <code class="docutils literal notranslate"><span class="pre">lights</span></code> vector so that all the point light sources come first, followed by the spotlight sources and then the directional light sources. This means we can avoid if statements in our shader files (this slows down the shaders significantly).</p></li>
</ul>
<hr class="docutils" />
<section id="tangent-space">
<h2><span class="section-number">10.1. </span>Tangent space<a class="headerlink" href="#tangent-space" title="Permalink to this heading">#</a></h2>
<p>We have already seen in <a class="reference internal" href="06_3D_worlds.html#d-worlds-section"><span class="std std-ref">Lab 6 3D worlds</span></a> that we can use transformations to map co-ordinates and vectors between the model, view and screen spaces. To apply normal mapping we need to perform our lighting calculations in a new space called the <strong>tangent space</strong>. The tangent space is a 3D space where vectors are defined in terms of three vectors: <strong>tangent</strong>, <strong>bitangent</strong> and <strong>normal</strong> vectors (<a class="reference internal" href="#bitangent-vector-figure"><span class="std std-numref">Fig. 10.3</span></a>).</p>
<figure class="align-default" id="bitangent-vector-figure">
<a class="reference internal image-reference" href="../_images/09_bitangent.svg"><img alt="../_images/09_bitangent.svg" src="../_images/09_bitangent.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.3 </span><span class="caption-text">Normal, tangent and the bitangent vectors.</span><a class="headerlink" href="#bitangent-vector-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p><strong>Normal vector</strong> - we have already met the normal vector which is a vector perpendicular to the surface</p></li>
<li><p><strong>Tangent vector</strong> - this is a vector that points along the surface so is perpendicular to the normal vector</p></li>
<li><p><strong>Bitangent vector</strong> - this is a vector that is perpendicular to both the normal and tangent vectors</p></li>
</ul>
<p>There are an infinite number of vectors on a plane that is perpendicular to the normal vector so we have a choice for the tangent and bitangent vectors. A natural choice is to use vectors that point along the edges of the normal map, we know these are perpendicular and this also means we are consistent for neighbouring triangles.</p>
<figure class="align-default" id="tbn-figure">
<a class="reference internal image-reference" href="../_images/09_TBN.svg"><img alt="../_images/09_TBN.svg" src="../_images/09_TBN.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.4 </span><span class="caption-text">The tangent space is defined by the tangent, bitangent and normal vectors.</span><a class="headerlink" href="#tbn-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The tangent and bitangent vectors are calculated using the model space vertex co-ordinates of the triangle <span class="math notranslate nohighlight">\(\mathsf{(x_0,y_0,z_0)}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{(x_1,y_1,z_1)}\)</span> and <span class="math notranslate nohighlight">\(\mathsf{(x_2,y_2,z_2)}\)</span> and their corresponding texture co-ordinates <span class="math notranslate nohighlight">\(\mathsf{(u_0,v_0)}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{(u_1,v_1)}\)</span> and <span class="math notranslate nohighlight">\(\mathsf{(u_2,v_2)}\)</span>.</p>
<figure class="align-default" id="uv-deltas-figure">
<a class="reference internal image-reference" href="../_images/09_UV_deltas.svg"><img alt="../_images/09_UV_deltas.svg" src="../_images/09_UV_deltas.svg" width="700" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.5 </span><span class="caption-text">The tangent, <span class="math notranslate nohighlight">\(\mathsf{T}\)</span>, and bitangent, <span class="math notranslate nohighlight">\(\mathsf{B}\)</span>, vectors are calculated by mapping the model space triangle onto the normal map space.</span><a class="headerlink" href="#uv-deltas-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>We first calculate vectors that point along two sides of the triangle in the model space</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \mathsf{E}_1 &amp;= \mathsf{(x_1, y_1, z_1) - (x_0, y_0, z_0),} \\
    \mathsf{E}_2 &amp;= \mathsf{(x_2, y_2, z_2) - (x_1, y_1, z_1),}
\end{align*}\end{split}\]</div>
<p>and calculate the difference in the <span class="math notranslate nohighlight">\(\mathsf{(u,v)}\)</span> co-ordinates for these edges</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \mathsf{\Delta u_1} &amp;= \mathsf{u_1 - u_0}, \\
    \mathsf{\Delta v_1} &amp;= \mathsf{v_1 - v_0}, \\
    \mathsf{\Delta u_2} &amp;= \mathsf{u_2 - u_1}, \\
    \mathsf{\Delta v_2} &amp;= \mathsf{v_2 - v_1}.
\end{align*} \end{split}\]</div>
<p>The tangent, <span class="math notranslate nohighlight">\(\mathsf{T}\)</span>, and bitangent, <span class="math notranslate nohighlight">\(\mathsf{B}\)</span>, vectors can then be calculated using</p>
<div class="math notranslate nohighlight" id="equation-tb-equation">
<span class="eqno">(10.1)<a class="headerlink" href="#equation-tb-equation" title="Permalink to this equation">#</a></span>\[\begin{split} \begin{align*}
    \mathsf{T} &amp;= \frac{1}{\mathsf{\Delta u_1\Delta v_2 - \Delta u_2\Delta v_1}}(\mathsf{\Delta v_2 \cdot E_1 - \Delta v_1 \cdot E_2}), \\
    \mathsf{B} &amp;= \frac{1}{\mathsf{\Delta u_1\Delta v_2 - \Delta u_2\Delta v_1}}(\mathsf{\Delta u_1 \cdot E_2 - \Delta u_2 \cdot E_1}).
\end{align*} \end{split}\]</div>
<p>To see the derivation of these equations click on the dropdown below.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Calculating the tangent and bitangent vectors<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">Consider <a class="reference internal" href="#uv-deltas-figure"><span class="std std-numref">Fig. 10.5</span></a> where a triangle is mapped onto the normal map using texture co-ordinates <span class="math notranslate nohighlight">\(\mathsf{(u_0,v_0)}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{(u_1,v_1)}\)</span> and <span class="math notranslate nohighlight">\(\mathsf{(u_2,v_2)}\)</span>. If the vectors <span class="math notranslate nohighlight">\(\mathsf{T}\)</span> and <span class="math notranslate nohighlight">\(\mathsf{B}\)</span> point in the co-ordinate directions of the normal map then the tangle space positions along the triangle edges <span class="math notranslate nohighlight">\(\mathsf{E_1}\)</span> and <span class="math notranslate nohighlight">\(\mathsf{E_2}\)</span> can be calculated using</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
    \mathsf{E_1} &amp;= \mathsf{\Delta u_1 \cdot T + \Delta v_1 \cdot B}, \\
    \mathsf{E_2} &amp;= \mathsf{\Delta u_2 \cdot T + \Delta v_2 \cdot B},
\end{align*}\end{split}\]</div>
<p class="sd-card-text">where <span class="math notranslate nohighlight">\(\mathsf{\Delta u_1 = u_1 - u_0}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{\Delta v_1 = v_1 - v_0}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{\Delta u_2 = u_2 - u_1}\)</span> and <span class="math notranslate nohighlight">\(\mathsf{\Delta v_2 = v_2 - v_1}\)</span>. We can express this using matrices</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \begin{pmatrix} \mathsf{E_1} \\ \mathsf{E_2} \end{pmatrix} &amp;=
    \begin{pmatrix}
        \mathsf{\Delta u_1} &amp; \mathsf{\Delta v_1} \\
        \mathsf{\Delta u_2} &amp; \mathsf{\Delta v_2}
    \end{pmatrix}
  \begin{pmatrix} \mathsf{T} \\ \mathsf{B} \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">We want to calculate <span class="math notranslate nohighlight">\(\mathsf{T}\)</span> and <span class="math notranslate nohighlight">\(\mathsf{B}\)</span> and we know the values of <span class="math notranslate nohighlight">\(\mathsf{E_1}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{E_2}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{\Delta u_1}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{\Delta v_1}\)</span>, <span class="math notranslate nohighlight">\(\mathsf{\Delta u_2}\)</span> and <span class="math notranslate nohighlight">\(\mathsf{\Delta v_2}\)</span>. Using the <a class="reference internal" href="04_vectors_and_matrices.html#inverse-matrix-section"><span class="std std-ref">inverse</span></a> of the square matrix we can rewrite this equation as</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \begin{pmatrix} \mathsf{T} \\ \mathsf{B} \end{pmatrix} &amp;=
    \begin{pmatrix}
        \mathsf{\Delta u_1} &amp; \mathsf{\Delta v_1} \\
        \mathsf{\Delta u_2} &amp; \mathsf{\Delta v_2}
    \end{pmatrix}^{-1}
    \begin{pmatrix} \mathsf{E_1} \\ \mathsf{E_2} \end{pmatrix} \\
    &amp;= 
    \frac{1}{\mathsf{\Delta u_1\Delta v_2 - \Delta u_2\Delta v_1}}
    \begin{pmatrix}
        \mathsf{\Delta v_2} &amp; \mathsf{-\Delta v_1} \\
        \mathsf{-\Delta u_2} &amp; \mathsf{\Delta u_1}
    \end{pmatrix}
    \begin{pmatrix} \mathsf{E_1} \\ \mathsf{E_2} \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Writing the out for the <span class="math notranslate nohighlight">\(\mathsf{T}\)</span> and <span class="math notranslate nohighlight">\(\mathsf{B}\)</span> vectors we have</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \mathsf{T} &amp;= \frac{1}{\mathsf{\Delta u_1\Delta v_2 - \Delta u_2\Delta v_1}}(\mathsf{\Delta v_2 \cdot E_1 - \Delta v_1 \cdot E_2}), \\
    \mathsf{B} &amp;= \frac{1}{\mathsf{\Delta u_1\Delta v_2 - \Delta u_2\Delta v_1}}(\mathsf{\Delta u_1 \cdot E_2 - \Delta u_2 \cdot E_1}).
\end{align*} \end{split}\]</div>
</div>
</details><p>Once we have the tangent, bitangent and normal vectors we can form a matrix that transforms from the tangent space to an arbitrary space (e.g., the view space). The matrix that achieves this a 3 <span class="math notranslate nohighlight">\(\times\)</span> 3 matrix known as the <strong>TBN matrix</strong> (we don’t need a 4 <span class="math notranslate nohighlight">\(\times\)</span> 4 matrix since we don’t need to perform a translation)</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{TBN} &amp;= 
    \begin{pmatrix}
        \mathsf{T_x} &amp; \mathsf{B_x} &amp; \mathsf{N_x} \\
        \mathsf{T_y} &amp; \mathsf{B_y} &amp; \mathsf{N_y} \\
        \mathsf{T_z} &amp; \mathsf{B_z} &amp; \mathsf{N_z}
    \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p>However, we will be performing our lighting calculations in the tangent space so we want to transform from the view space to the tangent space. To do this we calculate the <a class="reference internal" href="04_vectors_and_matrices.html#inverse-matrix-section"><span class="std std-ref">inverse</span></a> of the TBN matrix. Fortunately this is an orthogonal matrix where the inverse is simply the transpose, i.e., <span class="math notranslate nohighlight">\(\mathsf{(TBN)^{-1}} = \mathsf{(TBN)^{T}}\)</span>, which is an easy calculation.</p>
<section id="calculating-the-tangent-and-bitangent-vectors">
<h3><span class="section-number">10.1.1. </span>Calculating the tangent and bitangent vectors<a class="headerlink" href="#calculating-the-tangent-and-bitangent-vectors" title="Permalink to this heading">#</a></h3>
<p>All of the lighting calculations are performed by the shaders so we calculate the tangent and bitangent vectors in our C++ program and pass them to the vertex shader using uniforms. The model class contains all of the attributes for a model so we create two vectors that will contain the tangents and bitangents for each of the vertices of the model. In <code class="docutils literal notranslate"><span class="pre">model.hpp</span></code> add the following code after we have declared a vector array for the normals.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tangents</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bitangents</span><span class="p">;</span>
</pre></div>
</div>
<p>We are going to send the tangents and bitangents to the GPU using vertex buffers in the same way as we did for the vertices, texture co-ordinates and normal vectors. In <code class="docutils literal notranslate"><span class="pre">model.hpp</span></code> under the <code class="docutils literal notranslate"><span class="pre">private:</span></code> declaration add the identifiers for the tangent and bitangent buffers.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GLuint</span><span class="w"> </span><span class="n">tangentBuffer</span><span class="p">;</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">bitangentBuffer</span><span class="p">;</span>
</pre></div>
</div>
<p>We now create a private method for our model class to calculate the tangent and bitangent vectors. Add the following method declaration.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="c1">// Calculate tangents and bitangents</span>
<span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">calculateTangents</span><span class="p">();</span>
</pre></div>
</div>
<p>Then in the <code class="docutils literal notranslate"><span class="pre">model.cpp</span></code> we define the <code class="docutils literal notranslate"><span class="pre">calculateTangents()</span></code> method.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Model</span><span class="p">::</span><span class="n">calculateTangents</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vertices</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Calculate</span> <span class="n">edge</span> <span class="n">vectors</span> <span class="ow">and</span> <span class="n">deltas</span>
        <span class="n">glm</span><span class="p">::</span><span class="n">vec3</span> <span class="n">E1</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">glm</span><span class="p">::</span><span class="n">vec3</span> <span class="n">E2</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="nb">float</span> <span class="n">deltaU1</span> <span class="o">=</span> <span class="n">uvs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">uvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">;</span>
        <span class="nb">float</span> <span class="n">deltaV1</span> <span class="o">=</span> <span class="n">uvs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">uvs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">;</span>
        <span class="nb">float</span> <span class="n">deltaU2</span> <span class="o">=</span> <span class="n">uvs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">uvs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">;</span>
        <span class="nb">float</span> <span class="n">deltaV2</span> <span class="o">=</span> <span class="n">uvs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">uvs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">;</span>
        
        <span class="o">//</span> <span class="n">Calculate</span> <span class="n">tangents</span>
        <span class="nb">float</span> <span class="n">fact</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="p">(</span><span class="n">deltaU1</span> <span class="o">*</span> <span class="n">deltaV2</span> <span class="o">-</span> <span class="n">deltaU2</span> <span class="o">*</span> <span class="n">deltaV1</span><span class="p">);</span>
        <span class="n">glm</span><span class="p">::</span><span class="n">vec3</span> <span class="n">tangent</span> <span class="o">=</span> <span class="n">fact</span> <span class="o">*</span> <span class="p">(</span><span class="n">deltaV2</span> <span class="o">*</span> <span class="n">E1</span> <span class="o">-</span> <span class="n">deltaV1</span> <span class="o">*</span> <span class="n">E2</span><span class="p">);</span>
        <span class="n">glm</span><span class="p">::</span><span class="n">vec3</span> <span class="n">bitangent</span> <span class="o">=</span> <span class="n">fact</span> <span class="o">*</span> <span class="p">(</span><span class="n">deltaU1</span> <span class="o">*</span> <span class="n">E2</span> <span class="o">-</span> <span class="n">deltaU2</span> <span class="o">*</span> <span class="n">E1</span><span class="p">);</span>
        
        <span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">same</span> <span class="n">tangents</span> <span class="k">for</span> <span class="n">the</span> <span class="n">three</span> <span class="n">vertices</span> <span class="n">of</span> <span class="n">the</span> <span class="n">triangle</span>
        <span class="n">tangents</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tangent</span><span class="p">);</span>
        <span class="n">tangents</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tangent</span><span class="p">);</span>
        <span class="n">tangents</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tangent</span><span class="p">);</span>
        <span class="n">bitangents</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">bitangent</span><span class="p">);</span>
        <span class="n">bitangents</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">bitangent</span><span class="p">);</span>
        <span class="n">bitangents</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">bitangent</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This code calculates the tangent and bitangent vectors using equation <a class="reference internal" href="#equation-tb-equation">(10.1)</a> and adds them the <code class="docutils literal notranslate"><span class="pre">tangents</span></code> and <code class="docutils literal notranslate"><span class="pre">bitangents</span></code> lists. We want these to be calculated whenever we create a model so amend the Model class constructor so add the following above <code class="docutils literal notranslate"><span class="pre">setupBuffers()</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate tangent and bitangent vectors</span>
<span class="n">calculateTangents</span><span class="p">();</span>
</pre></div>
</div>
<p>The last addition we need to make to the Model class is to setup the buffers for the tangent and bitangent and copy these across to the GPU. In <code class="docutils literal notranslate"><span class="pre">model.cpp</span></code> add the following to the <code class="docutils literal notranslate"><span class="pre">setupBuffers()</span></code> method (before we unbind the VAO).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create tangent buffer</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">tangentBuffer</span><span class="p">;</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tangentBuffer</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">tangentBuffer</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">tangents</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tangents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span>

<span class="c1">// Create bitangent buffer</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">bitangentBuffer</span><span class="p">;</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bitangentBuffer</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">bitangentBuffer</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">bitangents</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bitangents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span>

<span class="c1">// Bind the tangent buffer</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">tangentBuffer</span><span class="p">);</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// Bind the bitangent buffer</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">bitangentBuffer</span><span class="p">);</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>These are essentially the same as what we’ve done previously for the vertices, texture co-ordinates and normal vectors. Note that the tangent and bitangent buffers are bound to attributes 3 and 4 respectively.</p>
</section>
</section>
<hr class="docutils" />
<section id="shaders">
<h2><span class="section-number">10.2. </span>Shaders<a class="headerlink" href="#shaders" title="Permalink to this heading">#</a></h2>
<section id="vertex-shader">
<h3><span class="section-number">10.2.1. </span>Vertex shader<a class="headerlink" href="#vertex-shader" title="Permalink to this heading">#</a></h3>
<p>In the vertex shader we need to calculate the tangent space fragment position, light position and light direction. We could do this in the fragment shader but since that is called for each fragment in the triangle and the vertex shader is just called 3 times per triangle it is much more efficient to do it in the vertex shader. Create a new shader file called <code class="docutils literal notranslate"><span class="pre">normalMapVertexShader.vert</span></code> in the <code class="docutils literal notranslate"><span class="pre">source/</span></code> folder and copy in the code from the <code class="docutils literal notranslate"><span class="pre">vertexShader.vert</span></code> file.</p>
<p>The first change we need to make to the vertex shader is to declare the new tangent and bitangent inputs. The <code class="docutils literal notranslate"><span class="pre">createBuffers()</span></code> model class bound these to attributes 3 and 4 respectively so edit your file so it looks like the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Input vertex data</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">tangent</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">bitangent</span><span class="p">;</span>
</pre></div>
</div>
<p>We need to transform the fragment position, light position and direction vector to the tangent space and to do so we calculate the TBN matrix. After the (u,v) co-ordinates have been outputted add the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate the TBN matrix that transforms view space to tangent space</span>
<span class="n">mat3</span><span class="w"> </span><span class="n">normalMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="p">)));</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">normalMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tangent</span><span class="p">);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">normalMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bitangent</span><span class="p">);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">normalMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normal</span><span class="p">);</span>
<span class="n">mat3</span><span class="w"> </span><span class="n">TBN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transpose</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">));</span>
</pre></div>
</div>
<p>Here we transform the tangent, bitangent and normal vectors to the view space using the matrix from equation <a class="reference internal" href="08_Lighting.html#equation-view-space-normal-equation">(9.1)</a> which are then used to calculate the TBN matrix. Remember that by transposing the TBN matrix we are calculating its inverse so here the TBN matrix will transform from the view space to the tangent space.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some people transform the vectors to the world space instead of the view space, however, this means that we need to also calculate the tangent space position of the camera for the eye vector calculation in the fragment shader. Doing this would mean we have additional uniforms and vector calculations. Since the camera position in the view space is (0,0,0) then it is also (0,0,0) in the tangent space so by transforming the vectors to the view space we don’t need to worry about this.</p>
</div>
<p>All that remains for us to do to the vertex shader is to calculate the tangent space fragment position, light position and direction vector using the TBN matrix. Replace the code used to calculate the view space vectors with the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Output tangent space fragment position</span>
<span class="n">fragmentPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TBN</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">));</span>

<span class="c1">// Output tangent space light positions and directions</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numPoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">numSpot</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">numDir</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">lightPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TBN</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">));</span>
<span class="w">    </span><span class="n">lightDirections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TBN</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">direction</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="fragment-shader">
<h3><span class="section-number">10.2.2. </span>Fragment shader<a class="headerlink" href="#fragment-shader" title="Permalink to this heading">#</a></h3>
<p>Now that we have transformed the vectors to the tangent space in the vertex shader we need to make a few changes to the fragment shader. The beauty of the tangent space is that it is orthogonal (T, B and N vectors are at right angles) so we don’t need to change any of our lighting calculations. This means we only need to make two changes to the fragment shader. Create a new shader file called <code class="docutils literal notranslate"><span class="pre">normalMapFragmentShader.frag</span></code> in the <code class="docutils literal notranslate"><span class="pre">source/</span></code> folder and copy in the contents of the <code class="docutils literal notranslate"><span class="pre">fragmentShader.frag</span></code> file.</p>
<p>We have an addition texture for the normal map so we use a sampler uniform to send this to the shader. Add the following where we declared the diffuse map uniform.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uniform</span><span class="w"> </span><span class="n">sampler2D</span><span class="w"> </span><span class="n">normalMap</span><span class="p">;</span>
</pre></div>
</div>
<p>Within the main function we obtain the normal vector from the normal map. Since the values in a texture are between 0 and 1 and we need the values of a normal vector to be between -1 and 1 we scale using the following</p>
<div class="math notranslate nohighlight">
\[ \mathsf{normal} = \mathsf{normalise}(2 * \textsf{textel colour} - 1). \]</div>
<p>So change the <code class="docutils literal notranslate"><span class="pre">normal</span></code> calculation to the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get the normal vector from the normal map</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">texture</span><span class="p">(</span><span class="n">normalMap</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">).</span><span class="n">rgb</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
</pre></div>
</div>
<p>We only have a couple of things we need to add to the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file. First tell the shader program we want to use our new vertex and fragment shaders.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">GLuint</span><span class="w"> </span><span class="n">shaderID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoadShaders</span><span class="p">(</span><span class="s">&quot;normalMapVertexShader.vert&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;normalMapFragmentShader.frag&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Then add the normal map texture to the <code class="docutils literal notranslate"><span class="pre">teapot</span></code> object.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Add textures to teapot object</span>
<span class="n">teapot</span><span class="p">.</span><span class="n">addTexture</span><span class="p">(</span><span class="s">&quot;../objects/blue_diffuse.bmp&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;diffuse&quot;</span><span class="p">);</span>
<span class="n">teapot</span><span class="p">.</span><span class="n">addTexture</span><span class="p">(</span><span class="s">&quot;../objects/diamond_normal.png&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;normal&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Compile and run the program and you should see the following.</p>
<figure class="align-default" id="id1">
<a class="reference internal image-reference" href="../_images/09_normal_map.png"><img alt="../_images/09_normal_map.png" src="../_images/09_normal_map.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.6 </span><span class="caption-text">Normal map applied to teapot objects.</span><a class="headerlink" href="#id1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The surfaces of the teapots which are smooth now have the appearance of bumpy diamond plate simply by getting the normal vectors from a texture and performing the lighting calculations in the tangent space. <a class="reference internal" href="#normal-map-closeup-figure"><span class="std std-numref">Fig. 10.7</span></a> shows a closeup of the surface so we can see the detail.</p>
<figure class="align-default" id="normal-map-closeup-figure">
<a class="reference internal image-reference" href="../_images/09_normal_map_closeup.png"><img alt="../_images/09_normal_map_closeup.png" src="../_images/09_normal_map_closeup.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.7 </span><span class="caption-text">Close up of the normal map applied to teapot objects.</span><a class="headerlink" href="#normal-map-closeup-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
</section>
<hr class="docutils" />
<section id="re-orthogonalising-the-tangent-space-vectors">
<h2><span class="section-number">10.3. </span>Re-orthogonalising the tangent space vectors<a class="headerlink" href="#re-orthogonalising-the-tangent-space-vectors" title="Permalink to this heading">#</a></h2>
<p>In the close up view of the normal mapped teapot in <a class="reference internal" href="#normal-map-closeup-figure"><span class="std std-numref">Fig. 10.7</span></a> we can see a distinct line in the specular highlights where polygons that form the surface of the teapot join. The reason for this is that the tangent vector is not exactly perpendicular to the normal vector.</p>
<p>When a vertex is shared by multiple triangles the 3D modelling software (e.g., Blender) calculates a single normal vector for the vertex by averaging of the normal vectors for the triangles (<a class="reference internal" href="#averaged-normal-figure"><span class="std std-numref">Fig. 10.8</span></a>). This saves memory and ensures that there is a smooth transition between the normal vectors across the surface.</p>
<figure class="align-default" id="averaged-normal-figure">
<a class="reference internal image-reference" href="../_images/09_averaged_normal.svg"><img alt="../_images/09_averaged_normal.svg" src="../_images/09_averaged_normal.svg" width="350" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.8 </span><span class="caption-text">The vertex normal is the average of the normal of the triangles sharing that vertex.</span><a class="headerlink" href="#averaged-normal-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>A problem with this is that when using a normal map we assume that the vertex normals are perpendicular to the triangle we are rendering. Since this is not the case so calculating the tangents and bitangents using equation <a class="reference internal" href="#equation-tb-equation">(10.1)</a> will not give an orthogonal set of vectors. We can get around this problem by <strong>re-orthogonalising</strong> the three vectors by adjusting the tangent vector a bit so that it is orthongonal to the normal vector.</p>
<figure class="align-default" id="reorthogonalise-t-figure">
<a class="reference internal image-reference" href="../_images/09_reorthogonalise_T.svg"><img alt="../_images/09_reorthogonalise_T.svg" src="../_images/09_reorthogonalise_T.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.9 </span><span class="caption-text">Re-orthogonalising T using the Gram-Schmidt process.</span><a class="headerlink" href="#reorthogonalise-t-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Consider <a class="reference internal" href="#reorthogonalise-t-figure"><span class="std std-numref">Fig. 10.9</span></a> where the tangent vector T is non-orthogonal to the normal vector N. If N and T are unit vectors then if we subtract <span class="math notranslate nohighlight">\(\mathsf{(T \cdot N)N}\)</span> from T then this creates a vector that is orthogonal to N (this is known as the <a href="https://en.wikipedia.org/wiki/Gram–Schmidt_process" target="_blank">Gram-Schmidt process</a>). We can use the cross product between N and T to calculate the bitangent vector B.</p>
<p>Edit the vertex shader so that we re-orthogonalise T and B</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate the TBN matrix that transforms view space to tangent space</span>
<span class="n">mat3</span><span class="w"> </span><span class="n">normalMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="p">)));</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">normalMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tangent</span><span class="p">);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">normalMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normal</span><span class="p">);</span>
<span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cross</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">);</span>
<span class="n">mat3</span><span class="w"> </span><span class="n">TBN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transpose</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">));</span>
</pre></div>
</div>
<p>You may notice that here we have calculated the bitangent in the vertex shader using normal and tangent vectors without needed to access the bitangent buffer. To save on memory you could remove the <code class="docutils literal notranslate"><span class="pre">bitangents</span></code> buffer from the Model class since we don’t need these anymore.</p>
<figure class="align-default" id="normal-map-orthogonalised-figure">
<a class="reference internal image-reference" href="../_images/09_normal_map_orthogonalised.png"><img alt="../_images/09_normal_map_orthogonalised.png" src="../_images/09_normal_map_orthogonalised.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.10 </span><span class="caption-text">A normal map with orthogonalised tangent and bitangent vectors.</span><a class="headerlink" href="#normal-map-orthogonalised-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>If you are having difficulty getting to this stage check out the source code files <a class="reference download internal" download="" href="../_downloads/72bf47163a4b8e405b3323433fa85c6a/Lab08_Normal_maps.cpp"><span class="xref download myst">Lab08_Normal_maps</span></a> and the shader files <a class="reference download internal" download="" href="../_downloads/cca81edca506589a84ac5edc0f58c661/normalMapVertexShader.vert"><span class="xref download myst">normalMapVertexShader.vert</span></a> and <a class="reference download internal" download="" href="../_downloads/5734ddff33bf8982478f17766bbdb1b0/normalMapFragmentShader.frag"><span class="xref download myst">normalMapFragmentShader.frag</span></a>.</p>
</section>
<hr class="docutils" />
<section id="specular-maps">
<h2><span class="section-number">10.4. </span>Specular maps<a class="headerlink" href="#specular-maps" title="Permalink to this heading">#</a></h2>
<p>In addition to diffuse (texture) and normal maps we can also apply a <strong>specular map</strong> which can be used to control the specular highlights across a surface. Lets say we want to add a stone floor to our scene. We can add a horizontal polygon object for the floor and use a texture map <a class="reference internal" href="#stones-diffuse-map-figure"><span class="std std-numref">Fig. 10.11</span></a> to give the impression of stones and a normal map <a class="reference internal" href="#stones-normal-map-figure"><span class="std std-numref">Fig. 10.12</span></a> so that the stones are lit by the light sources.</p>
<div class="sd-container-fluid sd-sphinx-override sd-mb-4 docutils">
<div class="sd-row docutils">
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="stones-diffuse-map-figure">
<img alt="../_images/09_stones_diffuse.png" src="../_images/09_stones_diffuse.png" />
<figcaption>
<p><span class="caption-number">Fig. 10.11 </span><span class="caption-text">Diffuse map</span><a class="headerlink" href="#stones-diffuse-map-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="stones-normal-map-figure">
<img alt="../_images/09_stones_normal.png" src="../_images/09_stones_normal.png" />
<figcaption>
<p><span class="caption-number">Fig. 10.12 </span><span class="caption-text">Normal map</span><a class="headerlink" href="#stones-normal-map-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="stones-specular-map-figure">
<img alt="../_images/09_stones_specular.png" src="../_images/09_stones_specular.png" />
<figcaption>
<p><span class="caption-number">Fig. 10.13 </span><span class="caption-text">Specular map</span><a class="headerlink" href="#stones-specular-map-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
</div>
</div>
<p>To apply our stone floor we are going to have a different object than our old friend the teapot. We will also want to add multiple different objects in the future so it we are going to use a data structure to contain the world space position, rotation and scaling of our objects and then store this in a vector. Add the following code to the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Data structures</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Object</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">rotation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ka</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.2f</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">kd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.7f</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">Ns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When we create an <code class="docutils literal notranslate"><span class="pre">Object</span></code> data structure the objects will have a default position at (0,0,0), the rotation and scale are unchanged and the object lighting properties are the same as what we have using so far (we can change these later if we want). Load the <code class="docutils literal notranslate"><span class="pre">floor</span></code> model and give it diffuse and normal textures where we load the <code class="docutils literal notranslate"><span class="pre">teapot</span></code> and <code class="docutils literal notranslate"><span class="pre">lightModel</span></code> models.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Load models</span>
<span class="n">Model</span><span class="w"> </span><span class="n">teapot</span><span class="p">(</span><span class="s">&quot;../objects/teapot.obj&quot;</span><span class="p">);</span>
<span class="n">Model</span><span class="w"> </span><span class="n">lightModel</span><span class="p">(</span><span class="s">&quot;../objects/sphere.obj&quot;</span><span class="p">);</span>
<span class="n">Model</span><span class="w"> </span><span class="n">floor</span><span class="p">(</span><span class="s">&quot;../objects/flat_plane.obj&quot;</span><span class="p">);</span>
<span class="w">    </span>
<span class="c1">// Add textures to models</span>
<span class="n">teapot</span><span class="p">.</span><span class="n">addTexture</span><span class="p">(</span><span class="s">&quot;../objects/blue_diffuse.bmp&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;diffuse&quot;</span><span class="p">);</span>
<span class="n">teapot</span><span class="p">.</span><span class="n">addTexture</span><span class="p">(</span><span class="s">&quot;../objects/diamond_normal.png&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;normal&quot;</span><span class="p">);</span>
<span class="n">floor</span><span class="p">.</span><span class="n">addTexture</span><span class="p">(</span><span class="s">&quot;../objects/stones_diffuse.png&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;diffuse&quot;</span><span class="p">);</span>
<span class="n">floor</span><span class="p">.</span><span class="n">addTexture</span><span class="p">(</span><span class="s">&quot;../objects/stones_normal.png&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;normal&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>We are going to create a vector to contain the different objects. Add the following code after we have added the textures to the models.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define objects</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">objects</span><span class="p">;</span>
<span class="n">Object</span><span class="w"> </span><span class="n">object</span><span class="p">;</span>
<span class="n">object</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;teapot&quot;</span><span class="p">;</span>
<span class="n">objects</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>

<span class="n">object</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;floor&quot;</span><span class="p">;</span>
<span class="n">object</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.85f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">objects</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we have created a <code class="docutils literal notranslate"><span class="pre">teapot</span></code> object with default position, rotation and scaling and a <code class="docutils literal notranslate"><span class="pre">floor</span></code> object positioned at (0, -0.85, 0) and have added both objects to the <code class="docutils literal notranslate"><span class="pre">objects</span></code> vector. Now all we need to do is loop through the <code class="docutils literal notranslate"><span class="pre">objects</span></code> vector, calculate the <code class="docutils literal notranslate"><span class="pre">model</span></code> matrix for each object, send it to the shader and draw the model. Replace the previous code used to draw the multiple teapots with the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Loop through objects</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Calculate model matrix</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">scale</span><span class="p">);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rotation</span><span class="p">);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Send the model matrix to the shader</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;model&quot;</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Send material properties to the shader</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ka&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ka</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;kd&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">kd</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ks&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ks</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Ns&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Ns</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Draw the model</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;teapot&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="n">teapot</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">shaderID</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;floor&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="n">floor</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">shaderID</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Compile and run the program and you should see a scene resembling the following.</p>
<figure class="align-default" id="stone-floor-no-specular-figure">
<a class="reference internal image-reference" href="../_images/09_floor_no_specular.png"><img alt="../_images/09_floor_no_specular.png" src="../_images/09_floor_no_specular.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.14 </span><span class="caption-text">Stone floor with no specular map applied.</span><a class="headerlink" href="#stone-floor-no-specular-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Move the camera around the floor and note how the mortar between the stones have specular highlights (an example of this can be seen in the bottom left-hand corner of <a class="reference internal" href="#stone-floor-no-specular-figure"><span class="std std-numref">Fig. 10.14</span></a>). This isn’t very realistic as in real life mortar is rough and does not appear shiny. To overcome this we can apply a specular map to switch off the specular highlights for certain fragments.</p>
<p>To apply the specular map we added to the <code class="docutils literal notranslate"><span class="pre">floor</span></code> object we first need to add a specular map to the <code class="docutils literal notranslate"><span class="pre">floor</span></code> model. Where we added the diffuse and normal maps add a specular map using the following code</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">floor</span><span class="p">.</span><span class="n">addTexture</span><span class="p">(</span><span class="s">&quot;../objects/stones_specular.png&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;specular&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>We now need to make minor changes to the fragment shader. First, declare a sampler uniform for the specular map near to where we did the same for the diffuse and normal maps.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">uniform</span><span class="w"> </span><span class="n">sampler2D</span><span class="w"> </span><span class="n">specularMap</span><span class="p">;</span>
</pre></div>
</div>
<p>Then, whenever we calculate the specular lighting in the <code class="docutils literal notranslate"><span class="pre">calculatePointLight()</span></code>, <code class="docutils literal notranslate"><span class="pre">calculateSpotlight()</span></code> and <code class="docutils literal notranslate"><span class="pre">calculateDirectionalLight()</span></code> functions multiply by the colour of the textel from the specular map.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="n">specular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">light</span><span class="p">.</span><span class="n">colour</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">cosAlpha</span><span class="p">,</span><span class="w"> </span><span class="n">Ns</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">texture</span><span class="p">(</span><span class="n">specularMap</span><span class="p">,</span><span class="w"> </span><span class="n">UV</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</pre></div>
</div>
<p>Compile and run the program and now you will notice that the mortar between the stones no longer have specular highlights.</p>
<figure class="align-default" id="stone-floor-specular-figure">
<a class="reference internal image-reference" href="../_images/09_floor_specular.png"><img alt="../_images/09_floor_specular.png" src="../_images/09_floor_specular.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.15 </span><span class="caption-text">Stone floor with specular map applied.</span><a class="headerlink" href="#stone-floor-specular-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="neutral-maps">
<h3><span class="section-number">10.4.1. </span>Neutral maps<a class="headerlink" href="#neutral-maps" title="Permalink to this heading">#</a></h3>
<p>We may not always want to apply a normal map or specular map to an object. Rather than writing a fragment shader for each case we can apply <strong>neutral maps</strong> which is a texture that when normal and specular mapping is applied it has no affect. Since the normal vector is calculated using</p>
<div class="math notranslate nohighlight">
\[ \mathsf{normal} = \mathsf{normalise}(2.0 * \textsf{textel colour} - 1.0), \]</div>
<p>then if the normal maps has pixels with the RGB colour code (0.5, 0.5, 1) then all fragments will have a normal vector of (0, 0, 1) which is perpendicular to the surface.</p>
<p>A neutral specular map is simply a texture with all white pixels that have the RGB colour code (1, 1, 1) so multiplying this by the specular colour has no affect.</p>
<p>The neutral maps for normal and specular mapping are contained in the <code class="docutils literal notranslate"><span class="pre">neutral_normal.png</span></code> and <code class="docutils literal notranslate"><span class="pre">neutral_specular.png</span></code> files in the <code class="docutils literal notranslate"><span class="pre">objects/</span></code> folder and are applied to a model when it is created. When we use the <code class="docutils literal notranslate"><span class="pre">addTexture()</span></code> Model class method the neutral maps are replaced.</p>
</section>
</section>
<hr class="docutils" />
<section id="exercises">
<h2><span class="section-number">10.5. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Add another object using the .obj model <code class="docutils literal notranslate"><span class="pre">../objects/wall.obj</span></code> to your scene and position it at (0, 4, -2), scale it up by a factor of 5 in the x and z directions and rotate it 90<span class="math notranslate nohighlight">\(^\circ\)</span> about the x axis. Apply the diffuse map <code class="docutils literal notranslate"><span class="pre">../objects/bricks_diffuse.png</span></code>.</p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/09_ex1.png"><img alt="../_images/09_ex1.png" src="../_images/09_ex1.png" style="width: 500px;" /></a>
</figure>
<ol class="arabic simple" start="2">
<li><p>Apply the normal map <code class="docutils literal notranslate"><span class="pre">../objects/bricks_normal.png</span></code> to the wall object.</p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/09_ex2.png"><img alt="../_images/09_ex2.png" src="../_images/09_ex2.png" style="width: 500px;" /></a>
</figure>
<ol class="arabic simple" start="3">
<li><p>Apply the specular map <code class="docutils literal notranslate"><span class="pre">../objects/bricks_specular.png</span></code> to the wall object.</p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/09_ex3.png"><img alt="../_images/09_ex3.png" src="../_images/09_ex3.png" style="width: 500px;" /></a>
</figure>
</section>
<hr class="docutils" />
<section id="source-code">
<h2><span class="section-number">10.6. </span>Source code<a class="headerlink" href="#source-code" title="Permalink to this heading">#</a></h2>
<p>The source code for this lab, including the exercise solutions, can be downloaded using the links below.</p>
<ul class="simple">
<li><p><a class="reference download internal" download="" href="../_downloads/72bf47163a4b8e405b3323433fa85c6a/Lab08_Normal_maps.cpp"><span class="xref download myst">Lab08_Normal_maps.cpp</span></a> - normal map applied to a single teapot object</p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/cca81edca506589a84ac5edc0f58c661/normalMapVertexShader.vert"><span class="xref download myst">normalMapVertexShader.vert</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/5734ddff33bf8982478f17766bbdb1b0/normalMapFragmentShader.frag"><span class="xref download myst">normalMapFragmentShader.vert</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/030ddb3c6975df435aa22aff94d61c7e/main.cpp"><span class="xref download myst">main.cpp</span></a> - solutions to the exercises</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="video-walkthrough">
<h2><span class="section-number">10.7. </span>Video walkthrough<a class="headerlink" href="#video-walkthrough" title="Permalink to this heading">#</a></h2>
<p>The video below walks you through these lab materials.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/TVsZjf1Gwu4?si=ezQkt9g-UwzWfnxM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="08_Lighting.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">9. </span>Lighting</p>
      </div>
    </a>
    <a class="right-next"
       href="A_Complex_numbers_and_quaternions.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">A. Complex Numbers and Quaternions</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tangent-space">10.1. Tangent space</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#calculating-the-tangent-and-bitangent-vectors">10.1.1. Calculating the tangent and bitangent vectors</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#shaders">10.2. Shaders</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vertex-shader">10.2.1. Vertex shader</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fragment-shader">10.2.2. Fragment shader</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#re-orthogonalising-the-tangent-space-vectors">10.3. Re-orthogonalising the tangent space vectors</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#specular-maps">10.4. Specular maps</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#neutral-maps">10.4.1. Neutral maps</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">10.5. Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">10.6. Source code</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#video-walkthrough">10.7. Video walkthrough</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dr Jon Shiach
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>